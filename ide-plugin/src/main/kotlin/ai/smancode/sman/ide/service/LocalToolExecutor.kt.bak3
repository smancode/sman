package ai.smancode.sman.ide.service

import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.application.ReadAction
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.project.Project
import com.intellij.openapi.roots.ProjectRootManager
import com.intellij.openapi.vfs.LocalFileSystem
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.psi.*
import com.intellij.psi.search.GlobalSearchScope
import com.intellij.psi.search.searches.ReferencesSearch
import org.json.JSONObject
import java.io.File
import java.nio.charset.Charset
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths

/**
 * æœ¬åœ°å·¥å…·æ‰§è¡Œå™¨
 * 
 * æ¥æ”¶ Agent çš„å·¥å…·è°ƒç”¨è¯·æ±‚ï¼Œåœ¨æœ¬åœ°æ‰§è¡Œå¹¶è¿”å›ç»“æœ
 * 
 * æ”¯æŒçš„å·¥å…·ï¼š
 * - read_class: è¯»å–ç±»æºç 
 * - read_method: è¯»å–æ–¹æ³•æºç 
 * - text_search: æ–‡æœ¬æœç´¢
 * - list_dir: åˆ—å‡ºç›®å½•
 */
class LocalToolExecutor(private val project: Project) {
    
    private val logger = Logger.getInstance(LocalToolExecutor::class.java)
    
    data class ToolResult(
        val success: Boolean,
        val result: String,
        val executionTime: Long = 0
    )
    
    /**
     * æ‰§è¡Œå·¥å…·
     */
    fun execute(toolName: String, parameters: Map<String, Any?>, projectPath: String?): ToolResult {
        val startTime = System.currentTimeMillis()
        
        logger.info("æ‰§è¡Œæœ¬åœ°å·¥å…·: $toolName, params=$parameters, projectPath=$projectPath")
        
        return try {
            val result = when (toolName) {
                "read_file" -> executeReadFile(parameters, projectPath, null)
                "grep_file" -> executeGrepFile(parameters, projectPath)
                "call_chain" -> executeCallChain(parameters)
                "apply_change" -> executeApplyChange(parameters, projectPath)
                else -> ToolResult(false, "ä¸æ”¯æŒçš„å·¥å…·: $toolName")
            }
            
            val elapsed = System.currentTimeMillis() - startTime
            ToolResult(result.success, result.result, elapsed)
            
        } catch (e: Exception) {
            logger.error("å·¥å…·æ‰§è¡Œå¤±è´¥: $toolName", e)
            val elapsed = System.currentTimeMillis() - startTime
            ToolResult(false, "å·¥å…·æ‰§è¡Œå¼‚å¸¸: ${e.message}", elapsed)
        }
    }
    
    /**
     * è¯»å–ç±»æºç 
     *
     * å‚è€ƒ Agent ç«¯ ReadClassTool.java å®ç°
     * æ”¯æŒï¼šrelativePath/class_nameã€mode(structure/full/imports_fields)ã€
     *      search_keywordã€start_line/end_lineã€context_lines
     */
    private fun executeReadClass(parameters: Map<String, Any?>): ToolResult {
        val className = parameters["class_name"]?.toString()
            ?: parameters["className"]?.toString()

        val relativePath = parameters["relativePath"]?.toString()

        if (className.isNullOrEmpty() && relativePath.isNullOrEmpty()) {
            return ToolResult(false, "ç¼ºå°‘ class_name æˆ– relativePath å‚æ•°")
        }
        
        val mode = parameters["mode"]?.toString() ?: "structure"
        val searchKeyword = parameters["search_keyword"]?.toString()
        val startLine = (parameters["start_line"] as? Number)?.toInt()
        val endLine = (parameters["end_line"] as? Number)?.toInt()
        val contextLines = (parameters["context_lines"] as? Number)?.toInt() ?: 10
        val basePath = project.basePath ?: ""
        
        return ReadAction.compute<ToolResult, Exception> {
            // å¦‚æœæœ‰æ–‡ä»¶è·¯å¾„ï¼Œç›´æ¥è¯»å–
            if (!relativePath.isNullOrEmpty()) {
                val file = if (File(relativePath).isAbsolute) File(relativePath) else File(basePath, relativePath)
                if (file.exists()) {
                    val content = readFileWithEncoding(file)  // ğŸ”¥ æ”¯æŒå¤šç§ç¼–ç 
                    val computedRelativePath = toRelativePath(file.absolutePath, basePath)
                    return@compute formatClassContent(
                        file.nameWithoutExtension, computedRelativePath, content,
                        mode, searchKeyword, startLine, endLine, contextLines
                    )
                }
                return@compute ToolResult(false, "æ–‡ä»¶ä¸å­˜åœ¨: $relativePath")
            }
            
            // é€šè¿‡ç±»åæŸ¥æ‰¾
            val psiClass = findClass(className!!)
            if (psiClass != null) {
                val vFile = psiClass.containingFile?.virtualFile
                val absolutePath = vFile?.path ?: "æœªçŸ¥è·¯å¾„"
                val relativePath = toRelativePath(absolutePath, basePath)
                val content = psiClass.containingFile?.text ?: ""
                return@compute formatClassContent(
                    className, relativePath, content,
                    mode, searchKeyword, startLine, endLine, contextLines
                )
            }
            
            ToolResult(false, "æœªæ‰¾åˆ°ç±»: $className")
        }
    }
    
    /**
     * å°†ç»å¯¹è·¯å¾„è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„
     */
    private fun toRelativePath(absolutePath: String, basePath: String): String {
        if (basePath.isEmpty()) return absolutePath
        
        // ç»Ÿä¸€è·¯å¾„åˆ†éš”ç¬¦
        val normalizedAbsolute = absolutePath.replace("\\", "/")
        val normalizedBase = basePath.replace("\\", "/").removeSuffix("/")
        
        return if (normalizedAbsolute.startsWith(normalizedBase)) {
            normalizedAbsolute.removePrefix(normalizedBase).removePrefix("/")
        } else {
            absolutePath
        }
    }
    
    /**
     * æ ¼å¼åŒ–ç±»å†…å®¹è¾“å‡º
     *
     * å‚è€ƒ Agent ç«¯ ReadClassTool.java çš„å®ç°é€»è¾‘
     */
    private fun formatClassContent(
        className: String,
        relativePath: String,
        content: String,
        mode: String,
        searchKeyword: String?,
        startLine: Int?,
        endLine: Int?,
        contextLines: Int
    ): ToolResult {
        val lines = content.lines()
        val sb = StringBuilder()

        // ğŸ”¥ 1. å¦‚æœæœ‰æœç´¢å…³é”®è¯ï¼Œä¼˜å…ˆå¤„ç†ç±»å†…æœç´¢
        if (!searchKeyword.isNullOrEmpty()) {
            sb.append("## ç±»å†…æœç´¢: $className\n\n")
            sb.append("**relativePath**: `$relativePath`\n")
            sb.append("**å…³é”®è¯**: `$searchKeyword`\n\n")
            
            val matchedIndices = lines.mapIndexedNotNull { index, line ->
                if (line.contains(searchKeyword)) index else null
            }
            
            if (matchedIndices.isEmpty()) {
                return ToolResult(false, "åœ¨ç±» $className ä¸­æœªæ‰¾åˆ°å…³é”®è¯: \"$searchKeyword\"")
            }
            
            sb.append("**åŒ¹é…**: ${matchedIndices.size} å¤„\n\n")
            
            for (idx in matchedIndices) {
                val start = maxOf(0, idx - contextLines)
                val end = minOf(lines.size - 1, idx + contextLines)
                
                sb.append("### ç¬¬ ${start + 1} - ${end + 1} è¡Œ\n\n")
                sb.append("```java\n")
                for (i in start..end) {
                    val lineNum = String.format("%4d", i + 1)
                    val marker = if (lines[i].contains(searchKeyword)) " >>> " else " |   "
                    sb.append("$lineNum$marker${lines[i]}\n")
                }
                sb.append("```\n\n")
            }
            
            return ToolResult(true, sb.toString())
        }
        
        // ğŸ”¥ 2. å¦‚æœæŒ‡å®šäº†è¡Œå·èŒƒå›´ï¼Œåˆ†æ®µè¯»å–
        if (startLine != null && endLine != null) {
            val actualStart = maxOf(1, startLine) - 1  // è½¬ä¸º 0-based
            val actualEnd = minOf(lines.size, endLine)

            sb.append("**ç±»å**: `$className`\n")
            sb.append("**relativePath**: `$relativePath`\n")
            sb.append("**æ€»è¡Œæ•°**: ${lines.size}\n\n")
            sb.append("```java\n")
            for (i in actualStart until actualEnd) {
                sb.append("${String.format("%4d", i + 1)} |   ${lines[i]}\n")
            }
            sb.append("```\n")
            
            if (actualEnd < lines.size) {
                sb.append("\n> ğŸ’¡ è¿˜æœ‰ ${lines.size - actualEnd} è¡Œæœªæ˜¾ç¤ºï¼Œä½¿ç”¨ start_line=${actualEnd + 1} ç»§ç»­è¯»å–\n")
            }
            
            return ToolResult(true, sb.toString())
        }
        
        // ğŸ”¥ 3. æ ¹æ® mode è¿”å›ä¸åŒæ ¼å¼
        sb.append("**ç±»å**: `$className`\n")
        sb.append("**relativePath**: `$relativePath`\n")
        sb.append("**mode**: `$mode`\n")
        sb.append("**æ€»è¡Œæ•°**: ${lines.size}\n\n")
        
        when (mode) {
            "full" -> {
                // å®Œæ•´æºç ï¼ˆâš ï¸ å¤§ç±»æ…ç”¨ï¼‰
                sb.append("```java\n")
                lines.forEachIndexed { idx, line ->
                    sb.append("${String.format("%4d", idx + 1)} |   $line\n")
                }
                sb.append("```\n")
            }
            "imports_fields" -> {
                // ğŸ”¥ åªè¯»å– import å’Œ field åŒºåŸŸï¼ˆé«˜æ•ˆï¼Œå‚è€ƒ Agent ç«¯ï¼‰
                sb.append("### Import å’Œ Field åŒºåŸŸ\n\n")
                sb.append("```java\n")
                var inClass = false
                var fieldRegionEnd = false
                
                lines.forEachIndexed { idx, line ->
                    val trimmed = line.trim()
                    
                    // import åŒºåŸŸ
                    if (trimmed.startsWith("package ") || trimmed.startsWith("import ")) {
                        sb.append("${String.format("%4d", idx + 1)} |   $line\n")
                        return@forEachIndexed
                    }
                    
                    // ç±»å£°æ˜
                    if (trimmed.matches(Regex("^(public |private |protected )?(abstract )?(class |interface |enum ).*"))) {
                        sb.append("${String.format("%4d", idx + 1)} |   $line\n")
                        inClass = true
                        return@forEachIndexed
                    }
                    
                    // è¿›å…¥ç±»åï¼Œæ£€æµ‹å­—æ®µåŒºåŸŸ
                    if (inClass && !fieldRegionEnd) {
                        // å­—æ®µæˆ–æ³¨è§£
                        if (trimmed.startsWith("@") || 
                            trimmed.matches(Regex("^(public |private |protected )?(static )?(final )?[A-Z].*[;=].*")) ||
                            trimmed.isEmpty()) {
                            sb.append("${String.format("%4d", idx + 1)} |   $line\n")
                        }
                        // é‡åˆ°æ–¹æ³•å®šä¹‰ï¼Œå­—æ®µåŒºåŸŸç»“æŸ
                        else if (trimmed.matches(Regex("^(public |private |protected )?(static )?(synchronized )?[a-zA-Z<>\\[\\]]+\\s+[a-zA-Z]+\\s*\\(.*"))) {
                            fieldRegionEnd = true
                            sb.append("${String.format("%4d", idx + 1)} |   // ... æ–¹æ³•åŒºåŸŸçœç•¥ ...\n")
                        }
                    }
                }
                sb.append("```\n")
            }
            else -> {
                // structure æ¨¡å¼ï¼šæ˜¾ç¤ºå­—æ®µå’Œæ–¹æ³•ç­¾å
                sb.append("### ç±»ç»“æ„ï¼ˆå­—æ®µ + æ–¹æ³•ç­¾åï¼‰\n\n")
                sb.append("```java\n")
                
                var braceDepth = 0
                lines.forEachIndexed { idx, line ->
                    val trimmed = line.trim()
                    
                    // è·Ÿè¸ªå¤§æ‹¬å·æ·±åº¦
                    braceDepth += line.count { it == '{' } - line.count { it == '}' }
                    
                    // package/import
                    if (trimmed.startsWith("package ") || trimmed.startsWith("import ")) {
                        sb.append("${String.format("%4d", idx + 1)} |   $line\n")
                        return@forEachIndexed
                    }
                    
                    // ç±»å£°æ˜ã€æ³¨è§£ã€å­—æ®µã€æ–¹æ³•ç­¾åï¼ˆæ·±åº¦ <= 1 çš„è¡Œï¼‰
                    if (braceDepth <= 1) {
                        if (trimmed.isNotEmpty() && !trimmed.startsWith("//") && !trimmed.startsWith("*")) {
                            sb.append("${String.format("%4d", idx + 1)} |   $line\n")
                        }
                    }
                }
                sb.append("```\n")
            }
        }
        
        return ToolResult(true, sb.toString())
    }
    
    /**
     * è¯»å–æ–¹æ³•æºç 
     */
    private fun executeReadMethod(parameters: Map<String, Any?>): ToolResult {
        val className = parameters["class_name"]?.toString()
        val methodName = parameters["method_name"]?.toString()
            ?: return ToolResult(false, "ç¼ºå°‘ method_name å‚æ•°")
        
        // å¦‚æœæ–¹æ³•ååŒ…å«ç±»åï¼ˆå¦‚ ClassName.methodNameï¼‰ï¼Œæ‹†åˆ†
        val parts = methodName.split(".", "#")
        val actualClassName = if (parts.size > 1) parts.dropLast(1).joinToString(".") else className
        val actualMethodName = parts.last().substringBefore("(")
        
        if (actualClassName.isNullOrEmpty()) {
            return ToolResult(false, "ç¼ºå°‘ class_name å‚æ•°")
        }
        
        val basePath = project.basePath ?: ""
        
        return ReadAction.compute<ToolResult, Exception> {
            val psiClass = findClass(actualClassName)
            if (psiClass == null) {
                return@compute ToolResult(false, "æœªæ‰¾åˆ°ç±»: $actualClassName")
            }
            
            val methods = psiClass.findMethodsByName(actualMethodName, false)
            if (methods.isEmpty()) {
                return@compute ToolResult(false, "åœ¨ç±» $actualClassName ä¸­æœªæ‰¾åˆ°æ–¹æ³•: $actualMethodName")
            }
            
            val absolutePath = psiClass.containingFile?.virtualFile?.path ?: "æœªçŸ¥è·¯å¾„"
            val relativePath = toRelativePath(absolutePath, basePath)
            
            val sb = StringBuilder()
            sb.append("## $actualClassName.$actualMethodName\n\n")
            sb.append("**relativePath**: `$relativePath`\n\n")
            
            methods.forEachIndexed { idx, method ->
                if (methods.size > 1) {
                    sb.append("### é‡è½½ç‰ˆæœ¬ ${idx + 1}\n\n")
                }
                sb.append("```java\n")
                sb.append(method.text)
                sb.append("\n```\n\n")
            }
            
            ToolResult(true, sb.toString())
        }
    }
    
    /**
     * æ–‡æœ¬æœç´¢
     *
     * æ”¯æŒå¤šæ¨¡å—é¡¹ç›®ï¼šè‡ªåŠ¨æ‰«ææ‰€æœ‰åŒ…å« src ç›®å½•çš„æ¨¡å—
     * æ”¯æŒï¼šæ™®é€šæœç´¢ã€æ­£åˆ™è¡¨è¾¾å¼æœç´¢
     * å‚è€ƒ Agent ç«¯ TextSearchTool.java å®ç°
     */
    private fun executeTextSearch(parameters: Map<String, Any?>, projectPath: String?): ToolResult {
        val keyword = parameters["keyword"]?.toString()
            ?: parameters["query"]?.toString()
            ?: parameters["text"]?.toString()
            ?: parameters["search"]?.toString()
            ?: return ToolResult(false, "ç¼ºå°‘ keyword å‚æ•°")

        val limit = (parameters["limit"] as? Number)?.toInt() ?: 20
        val fileType = parameters["file_type"]?.toString() ?: "all"
        val includeContext = parameters["include_context"] as? Boolean ?: true
        val contextLines = (parameters["context_lines"] as? Number)?.toInt() ?: 10
        val useRegex = parameters["regex"] as? Boolean ?: false  // ğŸ”¥ æ–°å¢ï¼šæ­£åˆ™æ¨¡å¼
        
        val basePath = projectPath ?: project.basePath ?: return ToolResult(false, "æ— æ³•ç¡®å®šé¡¹ç›®è·¯å¾„")
        val baseDir = File(basePath)
        
        val extensions = when (fileType) {
            "java" -> listOf(".java")
            "config" -> listOf(".properties", ".yml", ".yaml", ".xml")
            else -> listOf(".java", ".properties", ".yml", ".yaml", ".xml")
        }

        // ğŸ”¥ ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        val regexPattern = if (useRegex) {
            try {
                Regex(keyword, setOf(RegexOption.IGNORE_CASE))
            } catch (e: Exception) {
                return ToolResult(false, "æ— æ•ˆçš„æ­£åˆ™è¡¨è¾¾å¼: $keyword\né”™è¯¯: ${e.message}")
            }
        } else null

        // å­˜å‚¨æœç´¢ç»“æœ
        data class SearchMatch(
            val relativePath: String,
            val lineNumber: Int,
            val matchedLine: String,
            val context: String?
        )
        val results = mutableListOf<SearchMatch>()

        try {
            // ğŸ”¥ é€’å½’æ‰«ææ‰€æœ‰ src/main ç›®å½•ï¼ˆæ”¯æŒä»»æ„æ·±åº¦çš„å¤šæ¨¡å—é¡¹ç›®ï¼‰
            val excludedDirNames = setOf(
                "target", "build", ".git", ".gradle", "node_modules",
                ".idea", ".vscode", "bin", "out", "test", "tests"
            )
            
            val srcMainDirs = mutableListOf<File>()
            
            // é€’å½’æŸ¥æ‰¾æ‰€æœ‰ src/main ç›®å½•ï¼ˆé™åˆ¶æ·±åº¦é¿å…è¿‡æ·±æ‰«æï¼‰
            baseDir.walkTopDown()
                .maxDepth(5)  // æ”¯æŒ parent/child/grandchild/src/main è¿™æ ·çš„ç»“æ„
                .onEnter { dir -> 
                    // è·³è¿‡æ’é™¤ç›®å½•ï¼Œæé«˜æ•ˆç‡
                    !excludedDirNames.contains(dir.name) && !dir.name.startsWith(".")
                }
                .filter { it.isDirectory }
                .forEach { dir ->
                    // åŒ¹é… src/main ç›®å½•ç»“æ„
                    if (dir.name == "main" && dir.parentFile?.name == "src") {
                        srcMainDirs.add(dir)
                    }
                    // å…¼å®¹æ²¡æœ‰ main å­ç›®å½•çš„è€é¡¹ç›®ï¼šç›´æ¥ä½¿ç”¨ src/java æˆ– src/resources
                    else if (dir.name == "src" && !File(dir, "main").exists()) {
                        val srcJava = File(dir, "java")
                        val srcResources = File(dir, "resources")
                        if (srcJava.exists()) srcMainDirs.add(srcJava)
                        if (srcResources.exists()) srcMainDirs.add(srcResources)
                    }
                }
            
            if (srcMainDirs.isEmpty()) {
                return ToolResult(false, "æœªæ‰¾åˆ° src/main ç›®å½•ï¼ˆå·²é€’å½’æ‰«æé¡¹ç›®ï¼Œæ·±åº¦é™åˆ¶ 5 å±‚ï¼‰")
            }
            
            logger.info("text_search: æœç´¢ '$keyword' in ${srcMainDirs.size} ä¸ªæºç ç›®å½•: ${srcMainDirs.map { "${it.parentFile?.parentFile?.name ?: "?"}/${it.parentFile?.name}/${it.name}" }}")
            
            // éå†æ‰€æœ‰æºç ç›®å½•
            for (srcMainDir in srcMainDirs) {
                if (results.size >= limit) break
                
                srcMainDir.walkTopDown()
                    .filter { it.isFile }
                    .filter { file -> extensions.any { file.name.endsWith(it) } }
                    .filter { file -> 
                        // æ’é™¤ç¼–è¯‘è¾“å‡ºå’Œæµ‹è¯•ç›®å½•ï¼ˆåŒé‡ä¿é™©ï¼‰
                        val pathLower = file.path.replace("\\", "/").lowercase()
                        !excludedDirNames.any { excluded -> 
                            pathLower.contains("/$excluded/") 
                        }
                    }
                    .take(3000)  // æé«˜é™åˆ¶ï¼Œå¤§é¡¹ç›®å¯èƒ½æœ‰æ›´å¤šæ–‡ä»¶
                    .forEach { file ->
                        if (results.size >= limit) return@forEach
                        
                        try {
                            val content = readFileWithEncoding(file)  // ğŸ”¥ æ”¯æŒå¤šç§ç¼–ç 
                            val lines = content.lines()
                            lines.forEachIndexed { idx, line ->
                                if (results.size < limit) {
                                    // ğŸ”¥ æ ¹æ®æ¨¡å¼é€‰æ‹©åŒ¹é…æ–¹å¼
                                    val isMatch = if (useRegex) {
                                        regexPattern?.containsMatchIn(line) ?: false
                                    } else {
                                        line.contains(keyword)
                                    }

                                    if (isMatch) {
                                        val relativePath = toRelativePath(file.absolutePath, basePath)

                                        // ğŸ”¥ æå–ä¸Šä¸‹æ–‡ï¼ˆå‚è€ƒ Agent ç«¯ extractContextï¼‰
                                        val context = if (includeContext) {
                                            extractContext(lines, idx, contextLines, keyword, useRegex)
                                        } else null

                                        results.add(SearchMatch(relativePath, idx + 1, line.trim(), context))
                                    }
                                }
                            }
                        } catch (e: Exception) {
                            // å¿½ç•¥è¯»å–å¤±è´¥çš„æ–‡ä»¶
                        }
                    }
            }
        } catch (e: Exception) {
            return ToolResult(false, "æœç´¢å¤±è´¥: ${e.message}")
        }
        
        if (results.isEmpty()) {
            return ToolResult(true, "æœªæ‰¾åˆ°åŒ¹é…å…³é”®è¯ '$keyword' çš„ç»“æœ")
        }
        
        // ğŸ”¥ æ ¼å¼åŒ–è¾“å‡ºï¼ˆå‚è€ƒ Agent ç«¯æ ¼å¼ï¼‰
        val sb = StringBuilder()
        sb.append("## æ–‡æœ¬æœç´¢ç»“æœ: $keyword\n\n")
        if (useRegex) {
            sb.append("**æ¨¡å¼**: æ­£åˆ™è¡¨è¾¾å¼ (å¿½ç•¥å¤§å°å†™)\n\n")
        }
        sb.append("æ‰¾åˆ° ${results.size} ä¸ªåŒ¹é…:\n\n")
        
        for (result in results) {
            val fileName = result.relativePath.substringAfterLast("/")
            val ext = fileName.substringAfterLast(".", "")
            
            sb.append("### $fileName\n")
            sb.append("- **relativePath**: `${result.relativePath}`\n")
            sb.append("- è¡Œå·: ${result.lineNumber}\n")
            
            if (includeContext && result.context != null) {
                sb.append("```$ext\n${result.context}```\n")
            } else {
                sb.append("- åŒ¹é…è¡Œ: `${result.matchedLine.take(120)}`\n")
            }
            sb.append("\n")
        }
        
        return ToolResult(true, sb.toString())
    }
    
    /**
     * æå–ä¸Šä¸‹æ–‡ï¼ˆå‚è€ƒ Agent ç«¯ TextSearchTool.extractContextï¼‰
     */
    private fun extractContext(lines: List<String>, matchIndex: Int, contextLines: Int, keyword: String, useRegex: Boolean = false): String {
        val start = maxOf(0, matchIndex - contextLines)
        val end = minOf(lines.size, matchIndex + contextLines + 1)

        val sb = StringBuilder()
        for (i in start until end) {
            val lineNum = String.format("%4d", i + 1)
            if (i == matchIndex) {
                sb.append("$lineNum >>> ${lines[i]}  // <-- åŒ¹é…è¡Œ\n")
            } else {
                sb.append("$lineNum |   ${lines[i]}\n")
            }
        }
        return sb.toString()
    }
    
    /**
     * åˆ—å‡ºç›®å½•
     * 
     * å‚è€ƒ Agent ç«¯ ListDirTool.java
     * æ”¯æŒ absolute_path æˆ– path å‚æ•°
     */
    private fun executeListDir(parameters: Map<String, Any?>, projectPath: String?): ToolResult {
        // ğŸ”¥ æ”¯æŒ absolute_pathï¼ˆAgent ç«¯æ ‡å‡†ï¼‰å’Œ pathï¼ˆå…¼å®¹ï¼‰
        val absolutePath = parameters["absolute_path"]?.toString()
        val path = parameters["path"]?.toString()
        val basePath = projectPath ?: project.basePath ?: return ToolResult(false, "æ— æ³•ç¡®å®šé¡¹ç›®è·¯å¾„")
        
        val targetPath = when {
            !absolutePath.isNullOrEmpty() -> absolutePath
            !path.isNullOrEmpty() -> if (File(path).isAbsolute) path else File(basePath, path).absolutePath
            else -> basePath
        }
        
        val dir = File(targetPath)
        
        if (!dir.exists()) {
            return ToolResult(false, "ç›®å½•ä¸å­˜åœ¨æˆ–è·¯å¾„é”™è¯¯: $targetPath")
        }
        if (!dir.isDirectory) {
            return ToolResult(false, "ä¸æ˜¯ç›®å½•: $targetPath")
        }
        
        val files = dir.listFiles()?.sortedWith(compareBy({ !it.isDirectory }, { it.name })) ?: emptyList()
        val relativePath = toRelativePath(targetPath, basePath)
        
        val sb = StringBuilder()
        sb.append("## ç›®å½•: $relativePath\n\n")
        sb.append("**ç»å¯¹è·¯å¾„**: `$targetPath`\n")
        sb.append("**å†…å®¹æ•°é‡**: ${files.size} ä¸ª\n\n")
        
        files.forEach { file ->
            val suffix = if (file.isDirectory) "/" else ""
            sb.append("- ${file.name}$suffix\n")
        }
        
        return ToolResult(true, sb.toString())
    }
    
    /**
     * è¯»å– XML æ–‡ä»¶
     *
     * å‚è€ƒ Agent ç«¯ ReadXmlTool.java å®ç°
     * æ”¯æŒï¼š
     * - relativePath: ç›´æ¥æŒ‡å®šæ–‡ä»¶è·¯å¾„
     * - namespace: é€šè¿‡ Mapper ç±»åæŸ¥æ‰¾
     * - line + context_lines: å¤§æ–‡ä»¶åˆ†æ®µè¯»å–
     * - method: åªæå–æŒ‡å®šæ–¹æ³•çš„ SQL
     */
    private fun executeReadXml(parameters: Map<String, Any?>, projectPath: String?): ToolResult {
        val inputRelativePath = parameters["relativePath"]?.toString()
        val namespace = parameters["namespace"]?.toString()
        val method = parameters["method"]?.toString()?.substringBefore("(")
        val line = (parameters["line"] as? Number)?.toInt()
        val contextLines = (parameters["context_lines"] as? Number)?.toInt() ?: 20

        if (inputRelativePath.isNullOrEmpty() && namespace.isNullOrEmpty()) {
            return ToolResult(false, "éœ€è¦ relativePath æˆ– namespace å‚æ•°")
        }

        val basePath = projectPath ?: project.basePath ?: return ToolResult(false, "æ— æ³•ç¡®å®šé¡¹ç›®è·¯å¾„")

        // ç¡®å®š XML æ–‡ä»¶è·¯å¾„
        val xmlFile: File = if (!inputRelativePath.isNullOrEmpty()) {
            if (File(inputRelativePath).isAbsolute) File(inputRelativePath) else File(basePath, inputRelativePath)
        } else {
            // é€šè¿‡ namespace æŸ¥æ‰¾
            findXmlByNamespace(namespace!!, basePath) ?: return ToolResult(false, "æœªæ‰¾åˆ°åŒ¹é…çš„ XML: $namespace")
        }

        if (!xmlFile.exists()) {
            return ToolResult(false, "XML æ–‡ä»¶ä¸å­˜åœ¨: ${xmlFile.absolutePath}")
        }

        // ğŸ”¥ æ™ºèƒ½ç¼–ç è¯»å–ï¼ˆæ”¯æŒ UTF-8, GBK, GB2312ï¼‰
        val content = readFileWithEncoding(xmlFile)
        val relativePath = toRelativePath(xmlFile.absolutePath, basePath)
        
        // ğŸ”¥ æ™ºèƒ½è¯†åˆ« XML ç±»å‹
        return if (isMapperXml(content)) {
            // MyBatis Mapper XMLï¼šæå– SQL
            extractMapperSql(content, relativePath, namespace, method)
        } else {
            // å…¶ä»– XMLï¼šæŒ‰è¡Œè¯»å–
            readXmlByLine(content, relativePath, line, contextLines)
        }
    }
    
    /**
     * åˆ¤æ–­æ˜¯å¦æ˜¯ MyBatis Mapper XML
     */
    private fun isMapperXml(content: String): Boolean {
        return content.contains("</mapper>", ignoreCase = true)
    }
    
    /**
     * æŒ‰è¡Œè¯»å– XMLï¼ˆæ”¯æŒå¤§æ–‡ä»¶åˆ†æ®µï¼‰
     */
    private fun readXmlByLine(content: String, relativePath: String, centerLine: Int?, contextLines: Int): ToolResult {
        val lines = content.lines()
        val totalLines = lines.size
        
        // ç¡®å®šè¯»å–èŒƒå›´
        val (start, end) = if (centerLine != null && centerLine > 0) {
            maxOf(1, centerLine - contextLines) to minOf(totalLines, centerLine + contextLines)
        } else {
            // ğŸ”¥ å¤§æ–‡ä»¶é»˜è®¤åªè¯»å‰ 100 è¡Œ
            1 to if (totalLines <= 100) totalLines else 100
        }
        
        val sb = StringBuilder()
        val fileName = relativePath.substringAfterLast("/")
        
        sb.append("## æ–‡ä»¶: $fileName\n\n")
        sb.append("- **relativePath**: `$relativePath`\n")
        sb.append("- **ç±»å‹**: XMLï¼ˆé Mapperï¼‰\n")
        sb.append("- **æ€»è¡Œæ•°**: $totalLines\n")
        sb.append("- **è¯»å–èŒƒå›´**: ç¬¬ $start - $end è¡Œï¼ˆå…± ${end - start + 1} è¡Œï¼‰\n\n")
        
        sb.append("```xml\n")
        for (i in start..end) {
            val lineContent = lines[i - 1]
            val lineNum = String.format("%4d", i)
            
            if (centerLine != null && i == centerLine) {
                sb.append("$lineNum >>> $lineContent  // <-- åŒ¹é…è¡Œ\n")
            } else {
                sb.append("$lineNum |   $lineContent\n")
            }
        }
        sb.append("```\n")
        
        if (end < totalLines) {
            sb.append("\n> ğŸ’¡ æ–‡ä»¶è¿˜æœ‰ ${totalLines - end} è¡Œæœªæ˜¾ç¤ºã€‚")
            sb.append("å¦‚éœ€æŸ¥çœ‹æ›´å¤šï¼Œè¯·è®¾ç½® `line` å‚æ•°æˆ–å¢å¤§ `context_lines`ã€‚\n")
        }
        
        return ToolResult(true, sb.toString())
    }
    
    /**
     * æå– Mapper XML çš„ SQL è¯­å¥
     */
    private fun extractMapperSql(content: String, relativePath: String, namespace: String?, method: String?): ToolResult {
        val sb = StringBuilder()
        sb.append("## XML æ–‡ä»¶\n\n")
        sb.append("- **relativePath**: `$relativePath`\n")
        if (namespace != null) {
            sb.append("- **Namespace**: `$namespace`\n")
        }
        sb.append("\n")
        
        // æå– SQL è¯­å¥
        val sqlPattern = Regex(
            "<(select|insert|update|delete)\\s+([^>]+)>(.*?)</\\1>",
            setOf(RegexOption.IGNORE_CASE, RegexOption.DOT_MATCHES_ALL)
        )
        
        val sqlList = sqlPattern.findAll(content).mapNotNull { match ->
            val type = match.groupValues[1].lowercase()
            val attributes = match.groupValues[2]
            val sqlContent = match.groupValues[3].trim()
            
            val id = extractAttribute(attributes, "id") ?: return@mapNotNull null
            val parameterType = extractAttribute(attributes, "parameterType")
            val resultType = extractAttribute(attributes, "resultType")
            val resultMap = extractAttribute(attributes, "resultMap")
            
            SqlInfo(type, id, parameterType, resultType, resultMap, cleanSqlContent(sqlContent))
        }.toList()
        
        if (sqlList.isEmpty()) {
            sb.append("æœªæ‰¾åˆ° SQL è¯­å¥\n")
            return ToolResult(true, sb.toString())
        }
        
        // æŒ‰æ–¹æ³•åè¿‡æ»¤
        val filteredList = if (!method.isNullOrEmpty()) {
            sqlList.filter { it.id == method }
        } else sqlList
        
        if (filteredList.isEmpty()) {
            sb.append("æœªæ‰¾åˆ°æ–¹æ³• `$method` å¯¹åº”çš„ SQL\n")
            return ToolResult(true, sb.toString())
        }
        
        sb.append("## SQL è¯­å¥ (${filteredList.size} ä¸ª)\n\n")
        
        for (sql in filteredList) {
            sb.append("### ${sql.type.uppercase()}: ${sql.id}\n\n")
            sql.parameterType?.let { sb.append("- **parameterType**: `$it`\n") }
            sql.resultType?.let { sb.append("- **resultType**: `$it`\n") }
            sql.resultMap?.let { sb.append("- **resultMap**: `$it`\n") }
            sb.append("\n```sql\n${sql.content}\n```\n\n")
        }
        
        return ToolResult(true, sb.toString())
    }
    
    /**
     * é€šè¿‡ namespace æŸ¥æ‰¾ XML æ–‡ä»¶
     * 
     * ğŸ”¥ ä¿®å¤ï¼šåªæœç´¢ src/main ç›®å½•ï¼Œç»Ÿä¸€è·¯å¾„å¤„ç†ï¼Œæ”¯æŒå¤šç§ç¼–ç 
     */
    private fun findXmlByNamespace(namespace: String, basePath: String): File? {
        val excludedDirNames = setOf(
            "target", "build", ".git", ".gradle", "node_modules", 
            ".idea", ".vscode", "bin", "out", "test", "tests"
        )
        val namespacePattern = Regex(
            "<mapper\\s+[^>]*namespace\\s*=\\s*[\"']([^\"']+)[\"']",
            RegexOption.IGNORE_CASE
        )
        
        val baseDir = File(basePath)
        
        // ğŸ”¥ é€’å½’æŸ¥æ‰¾æ‰€æœ‰ src/main ç›®å½•ï¼ˆä¸ text_search ä¿æŒä¸€è‡´ï¼‰
        val srcMainDirs = mutableListOf<File>()
        baseDir.walkTopDown()
            .maxDepth(5)
            .onEnter { dir -> 
                !excludedDirNames.contains(dir.name) && !dir.name.startsWith(".")
            }
            .filter { it.isDirectory }
            .forEach { dir ->
                if (dir.name == "main" && dir.parentFile?.name == "src") {
                    srcMainDirs.add(dir)
                }
            }
        
        if (srcMainDirs.isEmpty()) {
            logger.warn("findXmlByNamespace: æœªæ‰¾åˆ° src/main ç›®å½•")
            return null
        }
        
        // ğŸ”¥ åœ¨ src/main ç›®å½•ä¸­æœç´¢ XML æ–‡ä»¶
        for (srcMainDir in srcMainDirs) {
            val xmlFiles = srcMainDir.walkTopDown()
                .filter { it.isFile && it.name.endsWith(".xml") }
                .filter { file -> 
                    val pathLower = file.path.replace("\\", "/").lowercase()
                    !excludedDirNames.any { excluded -> pathLower.contains("/$excluded/") }
                }
                .take(500)
                .toList()
            
            for (xmlFile in xmlFiles) {
                try {
                    val content = readFileWithEncoding(xmlFile)  // ğŸ”¥ æ”¯æŒå¤šç§ç¼–ç 
                    val match = namespacePattern.find(content)
                    if (match != null) {
                        val foundNamespace = match.groupValues[1]
                        if (matchesNamespace(foundNamespace, namespace)) {
                            logger.info("æ‰¾åˆ°åŒ¹é… XML: ${xmlFile.absolutePath} (namespace=$foundNamespace)")
                            return xmlFile
                        }
                    }
                } catch (e: Exception) {
                    // å¿½ç•¥è¯»å–å¤±è´¥
                }
            }
        }
        
        return null
    }
    
    /**
     * æ£€æŸ¥ namespace æ˜¯å¦åŒ¹é…ï¼ˆæ”¯æŒç®€å•ç±»åï¼‰
     */
    private fun matchesNamespace(foundNamespace: String, targetNamespace: String): Boolean {
        if (foundNamespace == targetNamespace) return true
        // æ”¯æŒç®€å•ç±»ååŒ¹é…
        if (!targetNamespace.contains(".")) {
            return foundNamespace.endsWith(".$targetNamespace")
        }
        return false
    }
    
    /**
     * æå– XML å±æ€§å€¼
     */
    private fun extractAttribute(attributes: String, attrName: String): String? {
        val pattern = Regex("$attrName\\s*=\\s*[\"']([^\"']+)[\"']", RegexOption.IGNORE_CASE)
        return pattern.find(attributes)?.groupValues?.get(1)
    }
    
    /**
     * æ¸…ç† SQL å†…å®¹
     */
    private fun cleanSqlContent(content: String): String {
        return content
            .replace(Regex("(?m)^\\s*$[\n\r]+"), "\n")
            .replace(Regex("\n{3,}"), "\n\n")
            .trim()
    }
    
    /**
     * SQL ä¿¡æ¯æ•°æ®ç±»
     */
    private data class SqlInfo(
        val type: String,
        val id: String,
        val parameterType: String?,
        val resultType: String?,
        val resultMap: String?,
        val content: String
    )
    
    /**
     * âœ… è¯»å–æ–‡ä»¶ï¼ˆä½¿ç”¨ PSIï¼‰
     *
     * å‚æ•°ï¼š
     * - relativePath: æ–‡ä»¶è·¯å¾„ï¼ˆå¿…éœ€ï¼‰
     * - start_line: èµ·å§‹è¡Œå·ï¼ˆå¯é€‰ï¼Œ1-basedï¼‰
     * - end_line: ç»“æŸè¡Œå·ï¼ˆå¯é€‰ï¼Œ1-basedï¼‰
     * - line: ä¸­å¿ƒè¡Œå·ï¼ˆå¯é€‰ï¼Œè¿”å›å‰åå„ context_lines è¡Œï¼‰
     * - context_lines: ä¸Šä¸‹æ–‡è¡Œæ•°ï¼ˆé»˜è®¤ 20ï¼Œä»…åœ¨æŒ‡å®š line æ—¶ç”Ÿæ•ˆï¼‰
     */
    private fun executeReadFile(parameters: Map<String, Any?>, projectPath: String?, allowedExtensions: List<String>?): ToolResult {
        val inputRelativePath = parameters["relativePath"]?.toString()
            ?: parameters["path"]?.toString()
            ?: return ToolResult(false, "ç¼ºå°‘ relativePath å‚æ•°")

        val basePath = projectPath ?: project.basePath ?: ""
        val file = if (File(inputRelativePath).isAbsolute) File(inputRelativePath) else File(basePath, inputRelativePath)

        if (!file.exists()) {
            return ToolResult(false, "æ–‡ä»¶ä¸å­˜åœ¨: ${file.absolutePath}")
        }

        if (allowedExtensions != null && !allowedExtensions.any { file.name.endsWith(it) }) {
            return ToolResult(false, "ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ${file.name}")
        }

        // âœ… ä½¿ç”¨ PSI è¯»å–æ–‡ä»¶ï¼ˆæ”¯æŒ IDE å†…å­˜ä¸­çš„æœªä¿å­˜æ–‡ä»¶ï¼‰
        return ReadAction.compute<ToolResult, Exception> {
            val virtualFile = LocalFileSystem.getInstance().findFileByIoFile(file)
                ?: return@compute ToolResult(false, "æ— æ³•æ‰¾åˆ°æ–‡ä»¶: ${file.absolutePath}")

            val psiFile = PsiManager.getInstance(project).findFile(virtualFile)
                ?: return@compute ToolResult(false, "æ— æ³•è¯»å– PSI: ${file.absolutePath}")

            // è·å–æ–‡ä»¶å†…å®¹ï¼ˆæ”¯æŒç¼–ç ï¼‰
            val content = psiFile.text
            val lines = content.lines()
            val ext = file.extension.ifEmpty { "text" }

            // è®¡ç®—ç›¸å¯¹è·¯å¾„
            val relativePath = toRelativePath(file.absolutePath, basePath)

            // æ”¯æŒæŒ‰è¡Œå·èŒƒå›´è¯»å–
            val startLine = (parameters["start_line"] as? Number)?.toInt()
            val endLine = (parameters["end_line"] as? Number)?.toInt()
            val centerLine = (parameters["line"] as? Number)?.toInt()
            val contextLines = (parameters["context_lines"] as? Number)?.toInt() ?: 20

            val sb = StringBuilder()
            sb.append("## æ–‡ä»¶: ${file.name}\n\n")
            sb.append("**relativePath**: `$relativePath`\n")
            sb.append("**absolutePath**: `${file.absolutePath}`\n")
            sb.append("**ç±»å‹**: $ext\n")
            sb.append("**æ€»è¡Œæ•°**: ${lines.size}\n")
            sb.append("**æ–‡ä»¶å¤§å°**: ${content.length} å­—ç¬¦\n\n")

            // ç¡®å®šè¯»å–èŒƒå›´
            val (readStart, readEnd) = when {
                startLine != null && endLine != null -> startLine to endLine
                centerLine != null -> maxOf(1, centerLine - contextLines) to minOf(lines.size, centerLine + contextLines)
                else -> 1 to lines.size  // é»˜è®¤è¯»å–å…¨éƒ¨
            }

            // âœ… è¾¹ç•Œå¤„ç†ï¼šè‡ªåŠ¨æˆªæ–­åˆ°æ–‡ä»¶è¡Œæ•°
            val actualStart = maxOf(1, readStart)
            val actualEnd = minOf(lines.size, readEnd)

            sb.append("**è¯·æ±‚èŒƒå›´**: ç¬¬ $readStart - $readEnd è¡Œ\n")
            sb.append("**å®é™…èŒƒå›´**: ç¬¬ $actualStart - $actualEnd è¡Œ\n")

            if (actualEnd < readEnd) {
                sb.append("**âš ï¸ å·²è‡ªåŠ¨æˆªæ–­**: endLine è¶…å‡ºæ–‡ä»¶è¡Œæ•°ï¼Œå·²æˆªæ–­åˆ°ç¬¬ $actualEnd è¡Œ\n")
            }

            sb.append("**è¯»å–è¡Œæ•°**: ${actualEnd - actualStart + 1} è¡Œ\n\n")

            sb.append("```$ext\n")
            for (i in (actualStart - 1) until actualEnd) {
                val lineNum = String.format("%4d", i + 1)
                val marker = if (centerLine != null && i + 1 == centerLine) " >>> " else " |   "
                sb.append("$lineNum$marker${lines[i]}\n")
            }
            sb.append("```\n")

            if (actualEnd < lines.size) {
                sb.append("\n> ğŸ’¡ æ–‡ä»¶è¿˜æœ‰ ${lines.size - actualEnd} è¡Œæœªæ˜¾ç¤ºã€‚")
                if (centerLine != null) {
                    sb.append("ä½¿ç”¨ start_line=${actualEnd + 1} ç»§ç»­è¯»å–ã€‚\n")
                } else {
                    sb.append("ä½¿ç”¨ start_line/end_line å‚æ•°æŒ‡å®šè¯»å–èŒƒå›´ã€‚\n")
                }
            }

            ToolResult(true, sb.toString())
        }
    }

    /**
     * ğŸ”¥ æ–‡ä»¶å†…å®¹æœç´¢ï¼ˆæ”¯æŒæ­£åˆ™è¡¨è¾¾å¼ï¼‰
     *
     * âœ… ä½¿ç”¨ IDE PSI èƒ½åŠ›ï¼š
     * - å•æ–‡ä»¶æœç´¢ï¼šä½¿ç”¨ PSI + æ­£åˆ™è¡¨è¾¾å¼
     * - å…¨é¡¹ç›®æœç´¢ï¼šä½¿ç”¨ PsiSearchHelperï¼ˆIDE ç´¢å¼•åŠ é€Ÿï¼‰
     *
     * å‚æ•°ï¼š
     * - relativePath: æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼Œä¸æŒ‡å®šåˆ™ä¸ºå…¨é¡¹ç›®æœç´¢ï¼‰
     * - pattern: æœç´¢å…³é”®è¯æˆ–æ­£åˆ™è¡¨è¾¾å¼ï¼ˆå¿…éœ€ï¼‰
     * - regex: æ˜¯å¦å¯ç”¨æ­£åˆ™è¡¨è¾¾å¼ï¼ˆé»˜è®¤ falseï¼‰
     * - case_sensitive: æ˜¯å¦å¤§å°å†™æ•æ„Ÿï¼ˆé»˜è®¤ falseï¼‰
     * - context_lines: ä¸Šä¸‹æ–‡è¡Œæ•°ï¼ˆé»˜è®¤ 0ï¼‰
     * - limit: æœ€å¤§ç»“æœæ•°ï¼ˆå…¨é¡¹ç›®æœç´¢æ—¶æœ‰æ•ˆï¼Œé»˜è®¤ 20ï¼‰
     * - file_type: æ–‡ä»¶ç±»å‹è¿‡æ»¤ï¼ˆå…¨é¡¹ç›®æœç´¢æ—¶æœ‰æ•ˆï¼Œé»˜è®¤ "all"ï¼‰
     */
    private fun executeGrepFile(parameters: Map<String, Any?>, projectPath: String?): ToolResult {
        val inputRelativePath = parameters["relativePath"]?.toString()
            ?: parameters["path"]?.toString()

        val pattern = parameters["pattern"]?.toString()
            ?: return ToolResult(false, "ç¼ºå°‘ pattern å‚æ•°ï¼ˆæœç´¢å…³é”®è¯æˆ–æ­£åˆ™è¡¨è¾¾å¼ï¼‰")

        val useRegex = parameters["regex"] as? Boolean ?: false
        val caseSensitive = parameters["case_sensitive"] as? Boolean ?: false
        val contextLines = (parameters["context_lines"] as? Number)?.toInt() ?: 0
        val limit = (parameters["limit"] as? Number)?.toInt() ?: 20
        val fileType = parameters["file_type"]?.toString() ?: "all"

        // ğŸ”¥ åˆ¤æ–­æ˜¯å•æ–‡ä»¶æœç´¢è¿˜æ˜¯å…¨é¡¹ç›®æœç´¢
        return if (inputRelativePath != null && inputRelativePath.isNotEmpty()) {
            // å•æ–‡ä»¶æœç´¢ï¼ˆä½¿ç”¨ PSIï¼‰
            grepSingleFile(inputRelativePath, pattern, useRegex, caseSensitive, contextLines, projectPath)
        } else {
            // å…¨é¡¹ç›®æœç´¢ï¼ˆä½¿ç”¨ PsiSearchHelperï¼‰
            grepProjectWide(pattern, useRegex, caseSensitive, contextLines, limit, fileType)
        }
    }

    /**
     * å•æ–‡ä»¶æœç´¢ï¼ˆä½¿ç”¨ PSIï¼‰
     */
    private fun grepSingleFile(
        relativePath: String,
        pattern: String,
        useRegex: Boolean,
        caseSensitive: Boolean,
        contextLines: Int,
        projectPath: String?
    ): ToolResult {
        val basePath = projectPath ?: project.basePath ?: ""
        val file = if (File(relativePath).isAbsolute) File(relativePath) else File(basePath, relativePath)

        if (!file.exists()) {
            return ToolResult(false, "æ–‡ä»¶ä¸å­˜åœ¨: ${file.absolutePath}")
        }

        return ReadAction.compute<ToolResult, Exception> {
            val virtualFile = LocalFileSystem.getInstance().findFileByIoFile(file)
                ?: return@compute ToolResult(false, "æ— æ³•æ‰¾åˆ°æ–‡ä»¶: ${file.absolutePath}")

            val psiFile = PsiManager.getInstance(project).findFile(virtualFile)
                ?: return@compute ToolResult(false, "æ— æ³•è¯»å– PSI: ${file.absolutePath}")

            val content = psiFile.text
            val lines = content.lines()
            val ext = file.extension.ifEmpty { "text" }

            // ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼æˆ–å‡†å¤‡å…³é”®è¯
            val regexPattern = if (useRegex) {
                try {
                    val options = if (caseSensitive) emptySet() else setOf(RegexOption.IGNORE_CASE)
                    Regex(pattern, options)
                } catch (e: Exception) {
                    return@compute ToolResult(false, "æ— æ•ˆçš„æ­£åˆ™è¡¨è¾¾å¼: $pattern\né”™è¯¯: ${e.message}")
                }
            } else null

            // æœç´¢åŒ¹é…è¡Œ
            val matches = mutableListOf<GrepMatch>()
            lines.forEachIndexed { index, line ->
                val isMatch = if (useRegex) {
                    regexPattern?.containsMatchIn(line) ?: false
                } else {
                    if (caseSensitive) line.contains(pattern)
                    else line.contains(pattern, ignoreCase = true)
                }

                if (isMatch) {
                    val matchedText = if (useRegex) {
                        regexPattern?.find(line)?.value ?: pattern
                    } else pattern
                    matches.add(GrepMatch(index + 1, line.trim(), matchedText))
                }
            }

            if (matches.isEmpty()) {
                return@compute ToolResult(true, "æœªæ‰¾åˆ°åŒ¹é… `$pattern` çš„å†…å®¹\n\næ–‡ä»¶: `${toRelativePath(file.absolutePath, basePath)}`")
            }

            // æ ¼å¼åŒ–è¾“å‡º
            val sb = StringBuilder()
            val displayPath = toRelativePath(file.absolutePath, basePath)
            sb.append("## æ–‡ä»¶å†…å®¹æœç´¢: ${file.name}\n\n")
            sb.append("**relativePath**: `$displayPath`\n")
            sb.append("**æœç´¢å†…å®¹**: `$pattern`\n")
            sb.append("**æ­£åˆ™æ¨¡å¼**: ${if (useRegex) "æ˜¯" else "å¦"}\n")
            sb.append("**å¤§å°å†™æ•æ„Ÿ**: ${if (caseSensitive) "æ˜¯" else "å¦"}\n")
            sb.append("**åŒ¹é…æ•°é‡**: ${matches.size}\n\n")

            for (match in matches) {
                if (contextLines > 0) {
                    val start = maxOf(0, match.lineNumber - contextLines - 1)
                    val end = minOf(lines.size, match.lineNumber + contextLines)

                    sb.append("### ç¬¬ ${match.lineNumber} è¡Œ\n\n")
                    sb.append("```$ext\n")
                    for (i in start until end) {
                        val lineNum = String.format("%4d", i + 1)
                        if (i + 1 == match.lineNumber) {
                            sb.append("$lineNum >>> ${lines[i]}  // <-- åŒ¹é…: ${match.matchedText}\n")
                        } else {
                            sb.append("$lineNum |   ${lines[i]}\n")
                        }
                    }
                    sb.append("```\n\n")
                } else {
                    sb.append("- **ç¬¬ ${match.lineNumber} è¡Œ**: `${match.lineContent}`\n")
                }
            }

            ToolResult(true, sb.toString())
        }
    }

    /**
     * å…¨é¡¹ç›®æœç´¢ï¼ˆä½¿ç”¨ PsiSearchHelperï¼‰
     */
    private fun grepProjectWide(
        pattern: String,
        useRegex: Boolean,
        caseSensitive: Boolean,
        contextLines: Int,
        limit: Int,
        fileType: String
    ): ToolResult {
        logger.info("å…¨é¡¹ç›®æœç´¢: pattern=$pattern, fileType=$fileType, limit=$limit")

        return ReadAction.compute<ToolResult, Exception> {
            val searchHelper = PsiSearchHelper.getInstance(project)
            val scope = GlobalSearchScope.projectScope(project)

            // æ–‡ä»¶ç±»å‹è¿‡æ»¤
            val allowedExtensions = when (fileType) {
                "java" -> listOf("java")
                "config" -> listOf("properties", "yml", "yaml", "xml")
                else -> null  // all
            }

            val matches = mutableListOf<ProjectGrepMatch>()
            val usageInfo = ProcessedItemsInfo()

            // ä½¿ç”¨ PsiSearchHelper æ‰§è¡Œæœç´¢
            val consumer = { element: PsiElement ->
                if (matches.size >= limit) return@ReadAction false

                val containingFile = element.containingFile
                val virtualFile = containingFile?.virtualFile ?: return@ReadAction true

                // æ–‡ä»¶ç±»å‹è¿‡æ»¤
                if (allowedExtensions != null) {
                    val ext = virtualFile.extension
                    if (ext != null && ext !in allowedExtensions) {
                        return@ReadAction true
                    }
                }

                // è·å–è¡Œå·å’Œå†…å®¹
                val document = PsiDocumentManager.getInstance(project).getDocument(containingFile)
                    ?: return@ReadAction true

                val lineNumber = document.getLineNumber(element.textOffset) + 1
                val lineStart = document.getLineStartOffset(lineNumber - 1)
                val lineEnd = document.getLineEndOffset(lineNumber - 1)
                val lineText = document.getText(TextRange(lineStart, lineEnd)).trim()

                val relativePath = toRelativePath(virtualFile.path, project.basePath ?: "")

                matches.add(ProjectGrepMatch(
                    relativePath = relativePath,
                    lineNumber = lineNumber,
                    content = lineText,
                    matchedText = element.text
                ))

                true
            }

            // æ‰§è¡Œæœç´¢
            if (useRegex) {
                // æ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼ï¼šä½¿ç”¨è‡ªå®šä¹‰æœç´¢å¤„ç†å™¨
                // æ³¨æ„ï¼šPsiSearchHelper ä¸ç›´æ¥æ”¯æŒæ­£åˆ™ï¼Œè¿™é‡Œç®€åŒ–ä¸ºæ–‡æœ¬æœç´¢
                searchHelper.processAllFilesWithWordInLiterals(
                    pattern.split(Regex("[\\s\\p{Punct}]")).firstOrNull { it.isNotEmpty() } ?: pattern,
                    scope,
                    consumer,
                    !caseSensitive
                )
            } else {
                // ç®€å•æ–‡æœ¬æœç´¢
                searchHelper.processAllFilesWithWordInLiterals(
                    pattern,
                    scope,
                    consumer,
                    !caseSensitive
                )
            }

            if (matches.isEmpty()) {
                return@compute ToolResult(true, "æœªæ‰¾åˆ°åŒ¹é… `$pattern` çš„å†…å®¹\n\næœç´¢èŒƒå›´: å…¨é¡¹ç›®\næ–‡ä»¶ç±»å‹: $fileType")
            }

            // æ ¼å¼åŒ–è¾“å‡º
            val sb = StringBuilder()
            sb.append("## ğŸ” å…¨é¡¹ç›®æœç´¢ç»“æœ\n\n")
            sb.append("**æœç´¢å†…å®¹**: `$pattern`\n")
            sb.append("**æ­£åˆ™æ¨¡å¼**: ${if (useRegex) "æ˜¯" else "å¦"}\n")
            sb.append("**å¤§å°å†™æ•æ„Ÿ**: ${if (caseSensitive) "æ˜¯" else "å¦"}\n")
            sb.append("**æ–‡ä»¶ç±»å‹**: $fileType\n")
            sb.append("**åŒ¹é…æ•°é‡**: ${matches.size}\n\n")

            for (match in matches) {
                sb.append("### `${match.relativePath}`\n\n")
                sb.append("- **è¡Œå·**: ${match.lineNumber}\n")
                sb.append("- **å†…å®¹**: `${match.content}`\n")
                sb.append("- **åŒ¹é…**: `${match.matchedText}`\n\n")
            }

            ToolResult(true, sb.toString())
        }
    }

    /**
     * å•æ–‡ä»¶ Grep åŒ¹é…ç»“æœ
     */
    private data class GrepMatch(
        val lineNumber: Int,
        val lineContent: String,
        val matchedText: String
    )

    /**
     * å…¨é¡¹ç›® Grep åŒ¹é…ç»“æœ
     */
    private data class ProjectGrepMatch(
        val relativePath: String,
        val lineNumber: Int,
        val content: String,
        val matchedText: String
    )

    /**
     * é€šè¿‡ç±»åæŸ¥æ‰¾ PsiClass
     */
    private fun findClass(className: String): PsiClass? {
        val javaPsiFacade = JavaPsiFacade.getInstance(project)
        val scope = GlobalSearchScope.projectScope(project)
        
        // å°è¯•å…¨é™å®šå
        var psiClass = javaPsiFacade.findClass(className, scope)
        if (psiClass != null) return psiClass
        
        // å°è¯•ç®€å•åæŸ¥æ‰¾
        val classes = javaPsiFacade.findClasses(className, scope)
        if (classes.isNotEmpty()) return classes[0]
        
        // éå†é¡¹ç›®æŸ¥æ‰¾
        val shortName = className.substringAfterLast(".")
        ProjectRootManager.getInstance(project).contentSourceRoots.forEach { root ->
            psiClass = findClassInDirectory(root, shortName)
            if (psiClass != null) return psiClass
        }
        
        return null
    }
    
    private fun findClassInDirectory(dir: VirtualFile, className: String): PsiClass? {
        if (!dir.isDirectory) return null
        
        for (child in dir.children) {
            if (child.isDirectory) {
                val found = findClassInDirectory(child, className)
                if (found != null) return found
            } else if (child.name == "$className.java") {
                val psiFile = PsiManager.getInstance(project).findFile(child)
                if (psiFile is PsiJavaFile) {
                    return psiFile.classes.firstOrNull { it.name == className }
                }
            }
        }
        return null
    }
    
    // ==================== æ–°å¢å·¥å…·å®ç° ====================
    
    /**
     * è°ƒç”¨é“¾åˆ†æå·¥å…·
     * 
     * ä½¿ç”¨ IntelliJ API åˆ†ææ–¹æ³•çš„è°ƒç”¨å…³ç³»
     * å‚è€ƒ Agent ç«¯ CallChainTool.java
     */
    private fun executeCallChain(parameters: Map<String, Any?>): ToolResult {
        val method = parameters["method"]?.toString()
            ?: return ToolResult(false, "ç¼ºå°‘ method å‚æ•°ï¼ˆæ ¼å¼ï¼šClassName.methodNameï¼‰")

        val direction = parameters["direction"]?.toString() ?: "both"
        val depth = (parameters["depth"] as? Number)?.toInt() ?: 1  // é»˜è®¤1å±‚ï¼Œé¿å…å‘æ•£
        // å…¼å®¹ä¸¤ç§å‘½åï¼šincludeSource (é©¼å³°) å’Œ include_source (ä¸‹åˆ’çº¿)
        val includeSource = (parameters["includeSource"] as? Boolean)
            ?: (parameters["include_source"] as? Boolean)
            ?: false
        
        // è§£æç±»åå’Œæ–¹æ³•å
        if (!method.contains(".")) {
            return ToolResult(false, "æ–¹æ³•ç­¾åæ ¼å¼é”™è¯¯ï¼Œåº”ä¸º: ClassName.methodName")
        }
        
        val lastDot = method.lastIndexOf(".")
        val className = method.substring(0, lastDot)
        val methodName = method.substring(lastDot + 1).substringBefore("(")
        
        logger.info("åˆ†æè°ƒç”¨é“¾: class=$className, method=$methodName, direction=$direction, depth=$depth")
        
        return ReadAction.compute<ToolResult, Exception> {
            val psiClass = findClass(className)
            if (psiClass == null) {
                return@compute ToolResult(false, "æœªæ‰¾åˆ°ç±»: $className")
            }
            
            val methods = psiClass.findMethodsByName(methodName, false)
            if (methods.isEmpty()) {
                return@compute ToolResult(false, "åœ¨ç±» $className ä¸­æœªæ‰¾åˆ°æ–¹æ³•: $methodName")
            }
            
            val targetMethod = methods[0]
            val basePath = project.basePath ?: ""
            val sb = StringBuilder()
            sb.append("## è°ƒç”¨é“¾åˆ†æ: $method\n\n")
            sb.append("**åˆ†ææ–¹å‘**: $direction\n")
            sb.append("**åˆ†ææ·±åº¦**: $depth\n\n")
            
            // åˆ†æè°ƒç”¨è€…ï¼ˆè°è°ƒç”¨äº†è¿™ä¸ªæ–¹æ³•ï¼‰
            if (direction == "callers" || direction == "both") {
                sb.append("### ğŸ”¼ è°ƒç”¨è€…ï¼ˆè°è°ƒç”¨äº†è¿™ä¸ªæ–¹æ³•ï¼‰\n\n")
                val callers = ReferencesSearch.search(targetMethod).findAll()
                if (callers.isEmpty()) {
                    sb.append("æœªæ‰¾åˆ°è°ƒç”¨è€…\n\n")
                } else {
                    callers.take(20).forEach { ref ->
                        val element = ref.element
                        val containingMethod = element.parentOfType<com.intellij.psi.PsiMethod>()
                        val containingClass = element.parentOfType<com.intellij.psi.PsiClass>()
                        
                        if (containingMethod != null && containingClass != null) {
                            val absolutePath = containingClass.containingFile?.virtualFile?.path ?: ""
                            val relativePath = toRelativePath(absolutePath, basePath)
                            sb.append("- `${containingClass.name}.${containingMethod.name}()`")
                            sb.append(" â†’ `$relativePath`\n")
                            
                            if (includeSource) {
                                sb.append("  ```java\n")
                                sb.append("  ${containingMethod.text.take(500)}")
                                if (containingMethod.text.length > 500) sb.append("...")
                                sb.append("\n  ```\n")
                            }
                        }
                    }
                    sb.append("\n")
                }
            }
            
            // åˆ†æè¢«è°ƒç”¨è€…ï¼ˆè¿™ä¸ªæ–¹æ³•è°ƒç”¨äº†è°ï¼‰
            if (direction == "callees" || direction == "both") {
                sb.append("### ğŸ”½ è¢«è°ƒç”¨è€…ï¼ˆè¿™ä¸ªæ–¹æ³•è°ƒç”¨äº†è°ï¼‰\n\n")
                val callees = mutableListOf<String>()
                
                targetMethod.body?.accept(object : com.intellij.psi.JavaRecursiveElementVisitor() {
                    override fun visitMethodCallExpression(expression: com.intellij.psi.PsiMethodCallExpression) {
                        super.visitMethodCallExpression(expression)
                        val calledMethod = expression.resolveMethod()
                        if (calledMethod != null) {
                            val calledClass = calledMethod.containingClass
                            if (calledClass != null) {
                                callees.add("${calledClass.name}.${calledMethod.name}()")
                            }
                        }
                    }
                })
                
                if (callees.isEmpty()) {
                    sb.append("æœªæ‰¾åˆ°è¢«è°ƒç”¨çš„æ–¹æ³•\n\n")
                } else {
                    callees.distinct().take(30).forEach { callee ->
                        sb.append("- `$callee`\n")
                    }
                    sb.append("\n")
                }
            }
            
            ToolResult(true, sb.toString())
        }
    }
    
    /**
     * å†™å…¥æ–‡ä»¶å·¥å…·
     *
     * å‚è€ƒ Agent ç«¯ WriteFileTool.java
     */
    private fun executeWriteFile(parameters: Map<String, Any?>, projectPath: String?): ToolResult {
        val inputRelativePath = parameters["relativePath"]?.toString()
        val content = parameters["content"]?.toString()
            ?: return ToolResult(false, "ç¼ºå°‘ content å‚æ•°")
        val packageName = parameters["package_name"]?.toString()
        val className = parameters["class_name"]?.toString()
        val overwrite = parameters["overwrite"] as? Boolean ?: false

        val basePath = projectPath ?: project.basePath ?: return ToolResult(false, "æ— æ³•ç¡®å®šé¡¹ç›®è·¯å¾„")

        // ç¡®å®šç›®æ ‡æ–‡ä»¶è·¯å¾„
        val targetFile: File = when {
            !inputRelativePath.isNullOrEmpty() -> {
                if (File(inputRelativePath).isAbsolute) File(inputRelativePath) else File(basePath, inputRelativePath)
            }
            !packageName.isNullOrEmpty() && !className.isNullOrEmpty() -> {
                val packagePath = packageName.replace(".", "/")
                val fileName = if (className.endsWith(".java")) className else "$className.java"
                File(basePath, "src/main/java/$packagePath/$fileName")
            }
            else -> return ToolResult(false, "éœ€è¦ relativePath æˆ– (package_name + class_name)")
        }

        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if (targetFile.exists() && !overwrite) {
            return ToolResult(false, "æ–‡ä»¶å·²å­˜åœ¨: ${targetFile.absolutePath}ï¼Œè®¾ç½® overwrite=true å¯è¦†ç›–")
        }

        return try {
            // åˆ›å»ºç›®å½•
            targetFile.parentFile?.mkdirs()

            // å†™å…¥æ–‡ä»¶
            targetFile.writeText(content)

            val relativePath = toRelativePath(targetFile.absolutePath, basePath)
            
            val sb = StringBuilder()
            sb.append("## æ–‡ä»¶åˆ›å»ºæˆåŠŸ\n\n")
            sb.append("- **relativePath**: `$relativePath`\n")
            sb.append("- **æ–‡ä»¶å¤§å°**: ${content.length} å­—ç¬¦\n")
            
            logger.info("âœ… åˆ›å»ºæ–‡ä»¶æˆåŠŸ: ${targetFile.absolutePath}")
            ToolResult(true, sb.toString())
            
        } catch (e: Exception) {
            logger.error("åˆ›å»ºæ–‡ä»¶å¤±è´¥", e)
            ToolResult(false, "åˆ›å»ºæ–‡ä»¶å¤±è´¥: ${e.message}")
        }
    }
    
    /**
     * ä¿®æ”¹æ–‡ä»¶å·¥å…·
     *
     * å‚è€ƒ Agent ç«¯ ModifyFileTool.java
     * æ”¯æŒ 4 ç§æ“ä½œæ¨¡å¼ï¼šreplace/insert/delete/add_import
     */
    private fun executeModifyFile(parameters: Map<String, Any?>, projectPath: String?): ToolResult {
        val inputRelativePath = parameters["relativePath"]?.toString()
            ?: return ToolResult(false, "ç¼ºå°‘ relativePath å‚æ•°")
        val operation = parameters["operation"]?.toString()?.lowercase() ?: "replace"

        val basePath = projectPath ?: project.basePath ?: ""
        val file = if (File(inputRelativePath).isAbsolute) File(inputRelativePath) else File(basePath, inputRelativePath)

        if (!file.exists()) {
            return ToolResult(false, "æ–‡ä»¶ä¸å­˜åœ¨: ${file.absolutePath}")
        }

        val relativePath = toRelativePath(file.absolutePath, basePath)
        
        return try {
            when (operation) {
                "replace" -> executeReplace(file, relativePath, parameters)
                "insert" -> executeInsert(file, relativePath, parameters)
                "delete" -> executeDelete(file, relativePath, parameters)
                "add_import" -> executeAddImport(file, relativePath, parameters)
                else -> {
                    // ğŸ”¥ å…¼å®¹æ¨¡å¼ï¼šæ²¡æœ‰ operation æ—¶æŒ‰ old_string/new_string å¤„ç†
                    executeReplace(file, relativePath, parameters)
                }
            }
        } catch (e: Exception) {
            logger.error("ä¿®æ”¹æ–‡ä»¶å¤±è´¥", e)
            ToolResult(false, "ä¿®æ”¹æ–‡ä»¶å¤±è´¥: ${e.message}")
        }
    }
    
    /**
     * æ‰§è¡Œæ›¿æ¢æ“ä½œ
     */
    private fun executeReplace(file: File, relativePath: String, parameters: Map<String, Any?>): ToolResult {
        val oldContent = parameters["old_content"]?.toString()
            ?: parameters["old_string"]?.toString()
            ?: parameters["search"]?.toString()
            ?: return ToolResult(false, "replace æ“ä½œéœ€è¦ old_content å‚æ•°")
        val newContent = parameters["new_content"]?.toString()
            ?: parameters["new_string"]?.toString()
            ?: parameters["replace"]?.toString()
            ?: ""
        val replaceAll = parameters["replace_all"] as? Boolean ?: false
        
        val content = readFileWithEncoding(file)  // ğŸ”¥ æ”¯æŒå¤šç§ç¼–ç 
        
        if (!content.contains(oldContent)) {
            return ToolResult(false, "æœªæ‰¾åˆ°è¦æ›¿æ¢çš„å†…å®¹:\n```\n${oldContent.take(200)}...\n```")
        }
        
        // æ£€æŸ¥å”¯ä¸€æ€§
        if (!replaceAll) {
            val count = content.split(oldContent).size - 1
            if (count > 1) {
                return ToolResult(false, "æ‰¾åˆ° $count å¤„åŒ¹é…ï¼Œè¯·ä½¿ç”¨ replace_all=true æˆ–æä¾›æ›´ç²¾ç¡®çš„ old_content")
            }
        }
        
        val result = if (replaceAll) content.replace(oldContent, newContent) else content.replaceFirst(oldContent, newContent)
        file.writeText(result)
        
        logger.info("âœ… æ›¿æ¢æˆåŠŸ: $relativePath")
        return ToolResult(true, "## æ›¿æ¢æˆåŠŸ\n\n- **relativePath**: `$relativePath`\n")
    }
    
    /**
     * æ‰§è¡Œæ’å…¥æ“ä½œ
     */
    private fun executeInsert(file: File, relativePath: String, parameters: Map<String, Any?>): ToolResult {
        val newContent = parameters["new_content"]?.toString()
            ?: return ToolResult(false, "insert æ“ä½œéœ€è¦ new_content å‚æ•°")
        val insertAfterLine = (parameters["insert_after_line"] as? Number)?.toInt() ?: -1
        val insertPosition = parameters["insert_position"]?.toString()
        
        val lines = readFileWithEncoding(file).lines().toMutableList()  // ğŸ”¥ æ”¯æŒå¤šç§ç¼–ç 
        
        // ç¡®å®šæ’å…¥ä½ç½®
        var insertLine = insertAfterLine
        if (insertLine <= 0 && insertPosition != null) {
            insertLine = findInsertPosition(lines, insertPosition)
        }
        if (insertLine <= 0) {
            // é»˜è®¤æ’å…¥åˆ°ç±»æœ«å°¾
            insertLine = findClassEnd(lines) - 1
        }
        insertLine = insertLine.coerceIn(0, lines.size)
        
        // æ’å…¥
        val insertLines = newContent.split("\n")
        lines.addAll(insertLine, insertLines)
        
        file.writeText(lines.joinToString("\n"))
        
        logger.info("âœ… æ’å…¥æˆåŠŸ: $relativePath (ç¬¬ ${insertLine} è¡Œå)")
        return ToolResult(true, "## æ’å…¥æˆåŠŸ\n\n- **relativePath**: `$relativePath`\n- **ä½ç½®**: ç¬¬ ${insertLine} è¡Œå\n")
    }
    
    /**
     * æ‰§è¡Œåˆ é™¤æ“ä½œ
     */
    private fun executeDelete(file: File, relativePath: String, parameters: Map<String, Any?>): ToolResult {
        val oldContent = parameters["old_content"]?.toString()
            ?: return ToolResult(false, "delete æ“ä½œéœ€è¦ old_content å‚æ•°")
        
        val content = readFileWithEncoding(file)  // ğŸ”¥ æ”¯æŒå¤šç§ç¼–ç 
        if (!content.contains(oldContent)) {
            return ToolResult(false, "æœªæ‰¾åˆ°è¦åˆ é™¤çš„å†…å®¹")
        }
        
        file.writeText(content.replace(oldContent, ""))
        
        logger.info("âœ… åˆ é™¤æˆåŠŸ: $relativePath")
        return ToolResult(true, "## åˆ é™¤æˆåŠŸ\n\n- **relativePath**: `$relativePath`\n")
    }
    
    /**
     * æ‰§è¡Œæ·»åŠ  import æ“ä½œ
     */
    @Suppress("UNCHECKED_CAST")
    private fun executeAddImport(file: File, relativePath: String, parameters: Map<String, Any?>): ToolResult {
        val importsObj = parameters["imports"]
        val imports: List<String> = when (importsObj) {
            is List<*> -> importsObj.filterIsInstance<String>()
            is String -> listOf(importsObj)
            else -> return ToolResult(false, "add_import æ“ä½œéœ€è¦ imports å‚æ•°")
        }
        
        if (imports.isEmpty()) {
            return ToolResult(false, "imports åˆ—è¡¨ä¸ºç©º")
        }
        
        val fileContent = readFileWithEncoding(file)  // ğŸ”¥ æ”¯æŒå¤šç§ç¼–ç 
        val lines = fileContent.lines().toMutableList()
        
        // æ‰¾åˆ°æœ€åä¸€ä¸ª import è¡Œ
        var lastImportLine = -1
        var packageLine = -1
        lines.forEachIndexed { i, line ->
            val trimmed = line.trim()
            if (trimmed.startsWith("package ")) packageLine = i
            if (trimmed.startsWith("import ")) lastImportLine = i
        }
        
        val insertPos = if (lastImportLine >= 0) lastImportLine + 1 else if (packageLine >= 0) packageLine + 2 else 0
        
        var addedCount = 0
        for (imp in imports.reversed()) {
            var importLine = imp.trim()
            if (!importLine.startsWith("import ")) importLine = "import $importLine"
            if (!importLine.endsWith(";")) importLine = "$importLine;"
            
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            val className = importLine.removePrefix("import ").removeSuffix(";").trim()
            if (!fileContent.contains(className)) {
                lines.add(insertPos, importLine)
                addedCount++
            }
        }
        
        if (addedCount > 0) {
            file.writeText(lines.joinToString("\n"))
            logger.info("âœ… æ·»åŠ  import æˆåŠŸ: $relativePath ($addedCount ä¸ª)")
            return ToolResult(true, "## æ·»åŠ  import æˆåŠŸ\n\n- **relativePath**: `$relativePath`\n- **æ–°å¢**: $addedCount ä¸ª\n")
        }
        
        return ToolResult(true, "æ‰€æœ‰ import å·²å­˜åœ¨ï¼Œæ— éœ€æ·»åŠ ")
    }
    
    /**
     * æŸ¥æ‰¾æ’å…¥ä½ç½®
     */
    private fun findInsertPosition(lines: List<String>, insertPosition: String): Int {
        val lower = insertPosition.lowercase()
        
        if ("ç±»æœ«å°¾" in lower || "class end" in lower) {
            return findClassEnd(lines) - 1
        }
        
        if ("æ–¹æ³•" in lower && "å" in lower) {
            val methodPattern = Regex("æ–¹æ³•\\s*(\\w+)\\s*å")
            methodPattern.find(insertPosition)?.let { match ->
                val methodName = match.groupValues[1]
                return findMethodEnd(lines, methodName)
            }
        }
        
        return -1
    }
    
    /**
     * æŸ¥æ‰¾ç±»ç»“æŸä½ç½®
     */
    private fun findClassEnd(lines: List<String>): Int {
        var braceCount = 0
        var inClass = false
        
        for ((i, line) in lines.withIndex()) {
            if ("class " in line && "{" in line) inClass = true
            if (inClass) {
                braceCount += line.count { it == '{' } - line.count { it == '}' }
                if (braceCount == 0) return i
            }
        }
        return lines.size - 1
    }
    
    /**
     * æŸ¥æ‰¾æ–¹æ³•ç»“æŸä½ç½®
     */
    private fun findMethodEnd(lines: List<String>, methodName: String): Int {
        var braceCount = 0
        var inMethod = false
        
        for ((i, line) in lines.withIndex()) {
            if (methodName in line && "(" in line) inMethod = true
            if (inMethod) {
                braceCount += line.count { it == '{' } - line.count { it == '}' }
                if (braceCount == 0 && "}" in line) return i + 1
            }
        }
        return -1
    }
    
    // è¾…åŠ©æ–¹æ³•ï¼šè·å–çˆ¶å…ƒç´ 
    private inline fun <reified T : PsiElement> PsiElement.parentOfType(): T? {
        var parent = this.parent
        while (parent != null) {
            if (parent is T) return parent
            parent = parent.parent
        }
        return null
    }
    
    /**
     * ğŸ”¥ æ™ºèƒ½è¯»å–æ–‡ä»¶ï¼Œè‡ªåŠ¨æ£€æµ‹ç¼–ç ï¼ˆæ”¯æŒ UTF-8ã€GBKã€GB2312ï¼‰
     * 
     * å‚è€ƒ Agent ç«¯ XmlDocumentExtractor.readFileWithEncoding å®ç°
     */
    private fun readFileWithEncoding(file: File): String {
        val bytes = file.readBytes()
        
        // 1. æ£€æŸ¥ XML å£°æ˜ä¸­çš„ encoding
        val declaredEncoding = detectEncodingFromXmlDeclaration(bytes)
        if (declaredEncoding != null) {
            try {
                val charset = Charset.forName(declaredEncoding)
                return String(bytes, charset)
            } catch (e: Exception) {
                logger.debug("å£°æ˜çš„ç¼–ç  $declaredEncoding ä¸å¯ç”¨ï¼Œå°è¯•å…¶ä»–ç¼–ç ")
            }
        }
        
        // 2. å°è¯• UTF-8ï¼ˆæ—  BOMï¼‰
        try {
            val content = String(bytes, Charsets.UTF_8)
            // æ£€æŸ¥æ˜¯å¦æœ‰ä¹±ç ï¼ˆç®€å•æ£€æµ‹ï¼šæ˜¯å¦æœ‰æ›¿æ¢å­—ç¬¦ï¼‰
            if (!content.contains("\uFFFD")) {
                return content
            }
        } catch (e: Exception) {
            // å¿½ç•¥
        }
        
        // 3. å°è¯• GBKï¼ˆä¸­æ–‡ Windows é»˜è®¤ç¼–ç ï¼‰
        try {
            val gbk = Charset.forName("GBK")
            return String(bytes, gbk)
        } catch (e: Exception) {
            logger.debug("GBK ç¼–ç è¯»å–å¤±è´¥: ${file.path}")
        }
        
        // 4. å°è¯• GB2312
        try {
            val gb2312 = Charset.forName("GB2312")
            return String(bytes, gb2312)
        } catch (e: Exception) {
            logger.debug("GB2312 ç¼–ç è¯»å–å¤±è´¥: ${file.path}")
        }
        
        // 5. æœ€åé™çº§åˆ° ISO-8859-1ï¼ˆä¸ä¼šå¤±è´¥ï¼Œä½†å¯èƒ½ä¹±ç ï¼‰
        return String(bytes, Charsets.ISO_8859_1)
    }
    
    /**
     * ä» XML å£°æ˜ä¸­æ£€æµ‹ç¼–ç 
     * ä¾‹å¦‚: <?xml version="1.0" encoding="GBK"?>
     */
    private fun detectEncodingFromXmlDeclaration(bytes: ByteArray): String? {
        try {
            // è¯»å–å‰ 200 å­—èŠ‚ï¼ˆè¶³å¤ŸåŒ…å« XML å£°æ˜ï¼‰
            val len = minOf(bytes.size, 200)
            val header = String(bytes, 0, len, Charsets.ISO_8859_1)
            
            // æŸ¥æ‰¾ encoding="xxx" æˆ– encoding='xxx'
            val pattern = Regex("encoding\\s*=\\s*[\"']([^\"']+)[\"']", RegexOption.IGNORE_CASE)
            val match = pattern.find(header)
            
            if (match != null) {
                return match.groupValues[1].uppercase()
            }
        } catch (e: Exception) {
            // å¿½ç•¥
        }
        return null
    }
    
    // ==================== æ–°å¢å·¥å…·ï¼šread_config å’Œ find_usages ====================
    
    /**
     * è¯»å–é…ç½®æ–‡ä»¶
     * 
     * æ”¯æŒ yml, yaml, properties, xml ç­‰é…ç½®æ–‡ä»¶
     * å‚è€ƒ Agent ç«¯ ReadConfigTool.java
     */
    private fun executeReadConfig(parameters: Map<String, Any?>, projectPath: String?): ToolResult {
        val relativePath = parameters["relativePath"]?.toString()
            ?: return ToolResult(false, "ç¼ºå°‘ relativePath å‚æ•°")
        
        val line = (parameters["line"] as? Number)?.toInt()
        val contextLines = (parameters["context_lines"] as? Number)?.toInt() ?: 20
        val startLine = (parameters["start_line"] as? Number)?.toInt()
        val endLine = (parameters["end_line"] as? Number)?.toInt()

        val basePath = projectPath ?: project.basePath ?: ""
        val absoluteFile = File(basePath, relativePath)  // ğŸ”¥ relativePath + basePath = absolutePath

        if (!absoluteFile.exists()) {
            return ToolResult(false, "é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: ${absoluteFile.absolutePath}")
        }

        val content = readFileWithEncoding(absoluteFile)
        val lines = content.lines()
        // æ³¨æ„ï¼šrelativePath å·²ç»æ˜¯å‚æ•°ä¼ å…¥çš„ï¼Œä¸éœ€è¦å†è½¬æ¢
        val ext = absoluteFile.extension.lowercase()

        val sb = StringBuilder()
        sb.append("## é…ç½®æ–‡ä»¶: ${absoluteFile.name}\n\n")
        sb.append("- **relativePath**: `$relativePath`\n")
        sb.append("- **ç±»å‹**: $ext\n")
        sb.append("- **æ€»è¡Œæ•°**: ${lines.size}\n\n")
        
        // ç¡®å®šè¯»å–èŒƒå›´
        val (readStart, readEnd) = when {
            startLine != null && endLine != null -> startLine to endLine
            line != null -> maxOf(1, line - contextLines) to minOf(lines.size, line + contextLines)
            else -> 1 to minOf(lines.size, 100)  // é»˜è®¤å‰ 100 è¡Œ
        }
        
        sb.append("```$ext\n")
        for (i in (readStart - 1) until minOf(readEnd, lines.size)) {
            val lineNum = String.format("%4d", i + 1)
            val marker = if (line != null && i + 1 == line) " >>> " else " |   "
            sb.append("$lineNum$marker${lines[i]}\n")
        }
        sb.append("```\n")
        
        if (readEnd < lines.size) {
            sb.append("\n> ğŸ’¡ è¿˜æœ‰ ${lines.size - readEnd} è¡Œæœªæ˜¾ç¤ºï¼Œä½¿ç”¨ start_line=${readEnd + 1} ç»§ç»­è¯»å–\n")
        }
        
        return ToolResult(true, sb.toString())
    }
    
    /**
     * æŸ¥æ‰¾å¼•ç”¨ï¼ˆfind_usagesï¼‰
     * 
     * ç»„åˆ call_chain + text_search å®ç°å®Œæ•´çš„å¼•ç”¨æŸ¥æ‰¾
     * å‚è€ƒ Agent ç«¯ FindUsagesTool.java
     */
    private fun executeFindUsages(parameters: Map<String, Any?>, projectPath: String?): ToolResult {
        val target = parameters["target"]?.toString()
            ?: run {
                val className = parameters["class_name"]?.toString() ?: parameters["className"]?.toString()
                val methodName = parameters["method_name"]?.toString() ?: parameters["methodName"]?.toString()
                if (className != null) {
                    if (methodName != null) "$className.$methodName" else className
                } else null
            }
            ?: return ToolResult(false, "ç¼ºå°‘ target æˆ– class_name å‚æ•°")
        
        val includeContext = parameters["include_context"] as? Boolean ?: true
        val contextLines = (parameters["context_lines"] as? Number)?.toInt() ?: 5
        val maxResults = (parameters["max_results"] as? Number)?.toInt() ?: 30
        
        val basePath = projectPath ?: project.basePath ?: return ToolResult(false, "æ— æ³•ç¡®å®šé¡¹ç›®è·¯å¾„")
        
        logger.info("find_usages: æœç´¢ '$target' in $basePath")
        
        val sb = StringBuilder()
        sb.append("## ğŸ” æ‰¾åˆ° `$target` çš„å¼•ç”¨\n\n")
        
        // è§£æç›®æ ‡
        val parts = target.replace("#", ".").split(".")
        val className = if (parts.size > 1) parts.dropLast(1).joinToString(".") else null
        val memberName = parts.last()
        
        var callChainCount = 0
        var textSearchCount = 0
        val results = mutableListOf<UsageResult>()
        val seenLocations = mutableSetOf<String>()
        
        // 1. ä½¿ç”¨ IntelliJ PSI æŸ¥æ‰¾å¼•ç”¨ï¼ˆç±»ä¼¼ call_chainï¼‰
        if (className != null) {
            ReadAction.run<Exception> {
                val psiClass = findClass(className)
                if (psiClass != null) {
                    val methods = psiClass.findMethodsByName(memberName, false)
                    if (methods.isNotEmpty()) {
                        val refs = ReferencesSearch.search(methods[0]).findAll()
                        refs.take(maxResults).forEach { ref ->
                            val element = ref.element
                            val containingFile = element.containingFile?.virtualFile?.path ?: return@forEach
                            val lineNum = com.intellij.openapi.editor.Document::class.java.let {
                                val doc = com.intellij.openapi.fileEditor.FileDocumentManager.getInstance()
                                    .getDocument(element.containingFile?.virtualFile ?: return@forEach)
                                doc?.getLineNumber(element.textOffset)?.plus(1) ?: 0
                            }
                            
                            val location = "$containingFile:$lineNum"
                            if (!seenLocations.contains(location)) {
                                seenLocations.add(location)
                                results.add(UsageResult(
                                    absolutePath = containingFile,
                                    lineNumber = lineNum,
                                    source = "call_chain",
                                    usageType = "ç›´æ¥è°ƒç”¨"
                                ))
                                callChainCount++
                            }
                        }
                    }
                }
            }
        }
        
        // 2. ä½¿ç”¨ text_search è¡¥å……ï¼ˆæœç´¢é…ç½®æ–‡ä»¶ã€åå°„è°ƒç”¨ç­‰ï¼‰
        val textSearchParams = mapOf(
            "keyword" to memberName,
            "limit" to (maxResults - results.size).coerceAtLeast(10),
            "include_context" to false
        )
        val textSearchResult = executeTextSearch(textSearchParams, projectPath)
        if (textSearchResult.success) {
            // è§£æ text_search ç»“æœ
            val textMatches = parseTextSearchResult(textSearchResult.result)
            textMatches.forEach { match ->
                val location = "${match.absolutePath}:${match.lineNumber}"
                if (!seenLocations.contains(location) && results.size < maxResults) {
                    seenLocations.add(location)
                    results.add(UsageResult(
                        absolutePath = match.absolutePath,
                        lineNumber = match.lineNumber,
                        matchedLine = match.matchedLine,
                        source = "text_search",
                        usageType = if (match.absolutePath.endsWith(".xml") || match.absolutePath.endsWith(".yml") || match.absolutePath.endsWith(".properties"))
                            "é…ç½®æ–‡ä»¶å¼•ç”¨" else "æ–‡æœ¬åŒ¹é…"
                    ))
                    textSearchCount++
                }
            }
        }
        
        sb.append("### ğŸ“Š ç»Ÿè®¡\n")
        sb.append("- call_chain æ‰¾åˆ°: $callChainCount å¤„\n")
        sb.append("- text_search è¡¥å……: $textSearchCount å¤„\n")
        sb.append("- æ€»è®¡ï¼ˆå»é‡åï¼‰: ${results.size} å¤„\n\n")
        
        if (results.isEmpty()) {
            sb.append("**æœªæ‰¾åˆ°å¼•ç”¨ã€‚**\n")
            return ToolResult(true, sb.toString())
        }
        
        sb.append("---\n\n")
        
        // æ ¼å¼åŒ–ç»“æœ
        results.forEachIndexed { idx, r ->
            val fileName = r.absolutePath.substringAfterLast("/")
            val relativePath = toRelativePath(r.absolutePath, basePath)

            sb.append("### ${idx + 1}. $fileName\n")
            sb.append("- **relativePath**: `$relativePath`\n")
            sb.append("- **è¡Œå·**: ${r.lineNumber}\n")
            sb.append("- **æ¥æº**: ${r.source}\n")
            sb.append("- **ç±»å‹**: ${r.usageType}\n")

            if (includeContext && r.absolutePath.isNotEmpty()) {
                try {
                    val file = File(r.absolutePath)
                    if (file.exists()) {
                        val lines = readFileWithEncoding(file).lines()
                        val start = maxOf(0, r.lineNumber - contextLines - 1)
                        val end = minOf(lines.size, r.lineNumber + contextLines)
                        val ext = file.extension.ifEmpty { "text" }

                        sb.append("```$ext\n")
                        for (i in start until end) {
                            val lineNum = String.format("%4d", i + 1)
                            val marker = if (i + 1 == r.lineNumber) " >>> " else " |   "
                            sb.append("$lineNum$marker${lines[i]}\n")
                        }
                        sb.append("```\n")
                    }
                } catch (e: Exception) {
                    // å¿½ç•¥è¯»å–å¤±è´¥
                }
            }
            sb.append("\n")
        }
        
        return ToolResult(true, sb.toString())
    }
    
    /**
     * è§£æ text_search ç»“æœ
     */
    private fun parseTextSearchResult(result: String): List<TextSearchMatch> {
        val matches = mutableListOf<TextSearchMatch>()
        
        // è§£ææ ¼å¼ï¼šrelativePath: xxx, è¡Œå·: N
        val pathPattern = Regex("\\*\\*relativePath\\*\\*:\\s*`([^`]+)`")
        val linePattern = Regex("è¡Œå·:\\s*(\\d+)")
        
        val lines = result.lines()
        var currentPath: String? = null
        
        for (line in lines) {
            val pathMatch = pathPattern.find(line)
            if (pathMatch != null) {
                currentPath = pathMatch.groupValues[1]
            }
            
            val lineMatch = linePattern.find(line)
            if (lineMatch != null && currentPath != null) {
                val lineNum = lineMatch.groupValues[1].toIntOrNull() ?: continue
                val basePath = project.basePath ?: ""
                val fullPath = if (File(currentPath).isAbsolute) currentPath else File(basePath, currentPath).absolutePath
                matches.add(TextSearchMatch(fullPath, lineNum, line))
                currentPath = null  // é‡ç½®ï¼Œå‡†å¤‡ä¸‹ä¸€ä¸ª
            }
        }
        
        return matches
    }
    
    /**
     * å¼•ç”¨ç»“æœæ•°æ®ç±»
     */
    private data class UsageResult(
        val absolutePath: String,
        val lineNumber: Int,
        val matchedLine: String? = null,
        val source: String,
        val usageType: String
    )

    /**
     * æ–‡æœ¬æœç´¢åŒ¹é…æ•°æ®ç±»
     */
    private data class TextSearchMatch(
        val absolutePath: String,
        val lineNumber: Int,
        val matchedLine: String
    )

    // ==================== æ–°å¢å·¥å…·ï¼šapply_change ====================

    /**
     * ğŸ”¥ åº”ç”¨ä»£ç å˜æ›´å·¥å…·ï¼ˆSEARCH/REPLACE + è‡ªåŠ¨æ ¼å¼åŒ–ï¼‰
     *
     * åŠŸèƒ½ï¼š
     * 1. è¯»å–æ–‡ä»¶
     * 2. æ‰§è¡Œ SEARCH/REPLACE
     * 3. è‡ªåŠ¨æ ¼å¼åŒ–ä¿®æ”¹çš„éƒ¨åˆ†
     * 4. è®°å½• TODO/doneï¼ˆé˜²æ­¢é‡å¤æ‰§è¡Œï¼‰
     *
     * å‚æ•°ï¼š
     * - projectRoot (å¿…éœ€): é¡¹ç›®æ ¹è·¯å¾„
     * - relativePath (å¿…éœ€): æ–‡ä»¶ç›¸å¯¹è·¯å¾„ï¼ˆä»é¡¹ç›®æ ¹ç›®å½•ï¼‰
     * - searchContent (å¿…éœ€): è¦æœç´¢çš„å†…å®¹ï¼ˆSEARCHå—ï¼‰
     * - replaceContent (å¿…éœ€): è¦æ›¿æ¢çš„å†…å®¹ï¼ˆREPLACEå—ï¼‰
     * - description (å¯é€‰): ä¿®æ”¹æè¿°
     *
     * å‚è€ƒ Agent ç«¯ ApplyCodeChangeTool.java
     */
    private fun executeApplyChange(parameters: Map<String, Any?>, projectPath: String?): ToolResult {
        val projectRoot = parameters["projectRoot"]?.toString()
            ?: parameters["project_root"]?.toString()
        val relativePath = parameters["relativePath"]?.toString()
        val searchContent = parameters["searchContent"]?.toString()
            ?: parameters["search_content"]?.toString()
        val replaceContent = parameters["replaceContent"]?.toString()
            ?: parameters["replace_content"]?.toString()
        val description = parameters["description"]?.toString() ?: "ä»£ç ä¿®æ”¹"

        // 1. å‚æ•°æ ¡éªŒ
        if (relativePath.isNullOrEmpty()) {
            return ToolResult(false, "ç¼ºå°‘å¿…éœ€å‚æ•°: relativePath")
        }
        // ğŸ”¥ searchContent å¯ä»¥ä¸ºç©ºï¼ˆæ–°å¢æ–‡ä»¶æ“ä½œï¼‰
        if (replaceContent == null) {
            return ToolResult(false, "ç¼ºå°‘å¿…éœ€å‚æ•°: replaceContent")
        }

        val basePath = projectRoot ?: projectPath ?: project.basePath ?: return ToolResult(false, "æ— æ³•ç¡®å®šé¡¹ç›®è·¯å¾„")
        val targetFile = if (File(relativePath).isAbsolute) File(relativePath) else File(basePath, relativePath)

        // ğŸ”¥ åˆ¤æ–­æ˜¯å¦æ˜¯æ–°å¢æ–‡ä»¶æ“ä½œ
        val isAddOperation = searchContent.isNullOrEmpty()

        logger.info("ğŸ”§ åº”ç”¨ä»£ç å˜æ›´: relativePath=$relativePath, isAdd=$isAddOperation, desc=$description")

        return try {
            val codeEditService = project.getService(ai.smancode.sman.ide.service.CodeEditService::class.java)
                ?: return ToolResult(false, "æ— æ³•è·å– CodeEditService")

            // ğŸ”¥ æ–°å¢æ–‡ä»¶ vs ä¿®æ”¹æ–‡ä»¶
            if (isAddOperation) {
                // æ–°å¢æ–‡ä»¶æ“ä½œ
                val editJson = org.json.JSONObject().apply {
                    put("projectPath", basePath)
                    put("summary", description)
                    put("edits", org.json.JSONArray().apply {
                        put(org.json.JSONObject().apply {
                            put("relativePath", relativePath)  // ğŸ”¥ ç»Ÿä¸€ä½¿ç”¨ relativePath
                            put("action", "ADD")  // ğŸ”¥ æ–°å¢
                            put("content", replaceContent)
                            put("description", description)
                        })
                    })
                }

                logger.info("ğŸ”§ æ‰§è¡Œæ–°å¢æ–‡ä»¶æ“ä½œ: $relativePath")
                val batchResult = codeEditService.executeEdits(editJson)

                if (batchResult.allSuccess) {
                    logger.info("âœ… apply_change (ADD) æˆåŠŸ: $relativePath")
                    val sb = StringBuilder()
                    sb.append("## æ–‡ä»¶åˆ›å»ºæˆåŠŸ\n\n")
                    sb.append("- **relativePath**: `$relativePath`\n")
                    sb.append("- **ä¿®æ”¹**: $description\n")
                    sb.append("- **å¤§å°**: ${replaceContent.length} å­—ç¬¦\n")
                    return ToolResult(true, sb.toString())
                } else {
                    // ğŸ”¥ è¯¦ç»†è®°å½•å¤±è´¥åŸå› 
                    val failedResults = batchResult.results.filter { !it.success }
                    val sb = StringBuilder()
                    sb.append("âŒ æ–‡ä»¶åˆ›å»ºå¤±è´¥: ${batchResult.failedCount}/${batchResult.totalEdits}\n\n")
                    sb.append("**æ–‡ä»¶**: `$relativePath`\n")
                    sb.append("**æè¿°**: $description\n\n")

                    failedResults.forEach { editResult ->
                        sb.append("- **å¤±è´¥åŸå› **: ${editResult.message}\n")
                    }

                    logger.error("âŒ apply_change (ADD) å¤±è´¥:\n{}", sb.toString())
                    return ToolResult(false, sb.toString())
                }
            } else {
                // ä¿®æ”¹æ–‡ä»¶æ“ä½œï¼ˆåŸæœ‰é€»è¾‘ï¼‰
                logger.info("ğŸ”§ æ‰§è¡Œä¿®æ”¹æ–‡ä»¶æ“ä½œ: $relativePath")
                logger.info("ğŸ”§ searchContent.len=${searchContent!!.length}, replaceContent.len=${replaceContent!!.length}")
                logger.debug("ğŸ”§ searchContent (å‰150å­—ç¬¦): ${searchContent.take(150)}")
                logger.debug("ğŸ”§ replaceContent (å‰150å­—ç¬¦): ${replaceContent.take(150)}")

                val editJson = org.json.JSONObject().apply {
                    put("projectPath", basePath)
                    put("summary", description)
                    put("edits", org.json.JSONArray().apply {
                        put(org.json.JSONObject().apply {
                            put("relativePath", relativePath)  // ğŸ”¥ ç»Ÿä¸€ä½¿ç”¨ relativePath
                            put("action", "MODIFY")
                            put("content", replaceContent)
                            put("oldContent", searchContent)
                            put("description", description)
                        })
                    })
                }

                val batchResult = codeEditService.executeEdits(editJson)

                if (batchResult.allSuccess) {
                    logger.info("âœ… apply_change (MODIFY) æˆåŠŸ: $relativePath")
                    val sb = StringBuilder()
                    sb.append("## ä»£ç å˜æ›´åº”ç”¨æˆåŠŸ\n\n")
                    sb.append("- **relativePath**: `$relativePath`\n")
                    sb.append("- **ä¿®æ”¹**: $description\n")
                    sb.append("- **çŠ¶æ€**: âœ… å·²è‡ªåŠ¨æ ¼å¼åŒ–\n")
                    return ToolResult(true, sb.toString())
                } else {
                    // ğŸ”¥ è¯¦ç»†è®°å½•å¤±è´¥åŸå› 
                    val failedResults = batchResult.results.filter { !it.success }
                    val sb = StringBuilder()
                    sb.append("âŒ ä»£ç å˜æ›´å¤±è´¥: ${batchResult.failedCount}/${batchResult.totalEdits}\n\n")
                    sb.append("**æ–‡ä»¶**: `$relativePath`\n")
                    sb.append("**æè¿°**: $description\n\n")

                    failedResults.forEach { editResult ->
                        sb.append("- **å¤±è´¥åŸå› **: ${editResult.message}\n")
                    }

                    logger.error("âŒ apply_change (MODIFY) å¤±è´¥:\n{}", sb.toString())
                    return ToolResult(false, sb.toString())
                }
            }

        } catch (e: Exception) {
            logger.error("âŒ apply_change å¼‚å¸¸: ${e.message}", e)
            return ToolResult(false, "ä»£ç å˜æ›´å¼‚å¸¸: ${e.message}")
        }
    }
}

