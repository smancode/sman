package com.smancode.sman.analysis.persistence

import com.smancode.sman.analysis.config.VectorDatabaseConfig
import com.smancode.sman.analysis.model.*
import com.zaxxer.hikari.HikariConfig
import com.zaxxer.hikari.HikariDataSource
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import org.slf4j.LoggerFactory
import java.sql.ResultSet
import javax.sql.DataSource

/**
 * 分析状态持久化仓储
 *
 * 负责分析循环状态和分析结果的持久化操作
 */
class AnalysisStateRepository(
    private val config: VectorDatabaseConfig
) {
    private val logger = LoggerFactory.getLogger(AnalysisStateRepository::class.java)
    private val dataSource: DataSource = createDataSource()
    private val json = Json {
        ignoreUnknownKeys = true
        encodeDefaults = true
    }

    companion object {
        // ========== 分析循环状态 SQL ==========
        private const val SQL_CREATE_LOOP_STATE_TABLE = """
            CREATE TABLE IF NOT EXISTS analysis_loop_state (
                project_key VARCHAR(255) PRIMARY KEY,
                enabled BOOLEAN DEFAULT TRUE,
                current_phase VARCHAR(50) DEFAULT 'IDLE',
                current_analysis_type VARCHAR(50),
                current_step INT DEFAULT 0,
                analysis_todos TEXT,
                total_analyses INT DEFAULT 0,
                successful_analyses INT DEFAULT 0,
                last_analysis_time BIGINT,
                last_analysis_time_readable VARCHAR(50),
                last_error TEXT,
                last_updated_at BIGINT NOT NULL
            )
        """

        private const val SQL_INSERT_LOOP_STATE = """
            INSERT INTO analysis_loop_state (
                project_key, enabled, current_phase,
                current_analysis_type, current_step, analysis_todos,
                total_analyses, successful_analyses,
                last_analysis_time, last_analysis_time_readable,
                last_error, last_updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """

        private const val SQL_UPDATE_LOOP_STATE = """
            UPDATE analysis_loop_state SET
                enabled = ?, current_phase = ?,
                current_analysis_type = ?, current_step = ?, analysis_todos = ?,
                total_analyses = ?, successful_analyses = ?,
                last_analysis_time = ?, last_analysis_time_readable = ?,
                last_error = ?, last_updated_at = ?
            WHERE project_key = ?
        """

        private const val SQL_GET_LOOP_STATE = """
            SELECT * FROM analysis_loop_state WHERE project_key = ?
        """

        // ========== 分析结果 SQL ==========
        private const val SQL_CREATE_RESULT_TABLE = """
            CREATE TABLE IF NOT EXISTS analysis_result (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                project_key VARCHAR(255) NOT NULL,
                analysis_type VARCHAR(50) NOT NULL,
                md_file_path VARCHAR(255),
                completeness DOUBLE DEFAULT 0.0,
                missing_sections TEXT,
                analysis_todos TEXT,
                task_status VARCHAR(20) DEFAULT 'PENDING',
                current_step INT DEFAULT 0,
                tool_call_history TEXT,
                created_at BIGINT NOT NULL,
                created_at_readable VARCHAR(50),
                updated_at BIGINT NOT NULL,
                updated_at_readable VARCHAR(50)
            )
        """

        private const val SQL_CREATE_RESULT_INDEX_PROJECT = """
            CREATE INDEX IF NOT EXISTS idx_ar_project_key ON analysis_result(project_key)
        """

        private const val SQL_CREATE_RESULT_INDEX_STATUS = """
            CREATE INDEX IF NOT EXISTS idx_ar_status ON analysis_result(task_status)
        """

        private const val SQL_CREATE_RESULT_UNIQUE = """
            ALTER TABLE analysis_result ADD CONSTRAINT IF NOT EXISTS uk_project_analysis UNIQUE (project_key, analysis_type)
        """

        private const val SQL_INSERT_RESULT = """
            INSERT INTO analysis_result (
                project_key, analysis_type, md_file_path,
                completeness, missing_sections, analysis_todos,
                task_status, current_step, tool_call_history,
                created_at, created_at_readable, updated_at, updated_at_readable
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """

        private const val SQL_UPDATE_RESULT = """
            UPDATE analysis_result SET
                md_file_path = ?, completeness = ?, missing_sections = ?, analysis_todos = ?,
                task_status = ?, current_step = ?, tool_call_history = ?,
                updated_at = ?, updated_at_readable = ?
            WHERE project_key = ? AND analysis_type = ?
        """

        private const val SQL_GET_RESULT = """
            SELECT * FROM analysis_result WHERE project_key = ? AND analysis_type = ?
        """

        private const val SQL_GET_ALL_RESULTS = """
            SELECT * FROM analysis_result WHERE project_key = ? ORDER BY analysis_type
        """

        private const val SQL_GET_DOING_TASKS = """
            SELECT * FROM analysis_result WHERE project_key = ? AND task_status = 'DOING'
        """

        private const val SQL_UPDATE_TASK_STATUS = """
            UPDATE analysis_result SET task_status = ?, updated_at = ?, updated_at_readable = ?
            WHERE project_key = ? AND analysis_type = ?
        """

        private const val SQL_UPDATE_COMPLETENESS = """
            UPDATE analysis_result SET completeness = ?, updated_at = ?, updated_at_readable = ?
            WHERE project_key = ? AND analysis_type = ?
        """

        private const val SQL_UPDATE_TODOS = """
            UPDATE analysis_result SET analysis_todos = ?, updated_at = ?, updated_at_readable = ?
            WHERE project_key = ? AND analysis_type = ?
        """

        private const val SQL_RESET_DOING_TO_PENDING = """
            UPDATE analysis_result SET task_status = 'PENDING', updated_at = ?, updated_at_readable = ?
            WHERE project_key = ? AND task_status = 'DOING'
        """

        private const val SQL_GET_STATISTICS = """
            SELECT
                COUNT(*) as total_tasks,
                SUM(CASE WHEN task_status = 'COMPLETED' THEN 1 ELSE 0 END) as completed_tasks,
                SUM(CASE WHEN task_status = 'PENDING' THEN 1 ELSE 0 END) as pending_tasks,
                SUM(CASE WHEN task_status = 'DOING' THEN 1 ELSE 0 END) as doing_tasks,
                SUM(CASE WHEN task_status = 'FAILED' THEN 1 ELSE 0 END) as failed_tasks,
                AVG(CASE WHEN task_status = 'COMPLETED' THEN completeness ELSE NULL END) as avg_completeness
            FROM analysis_result WHERE project_key = ?
        """
    }

    private fun createDataSource(): DataSource {
        val hikariConfig = HikariConfig().apply {
            jdbcUrl = "jdbc:h2:${config.databasePath};MODE=PostgreSQL;AUTO_SERVER=TRUE"
            driverClassName = "org.h2.Driver"
            username = "sa"
            password = ""
            maximumPoolSize = 10
            minimumIdle = 2
            connectionTimeout = 30000
            idleTimeout = 600000
            maxLifetime = 1800000
        }
        return HikariDataSource(hikariConfig).also { initTables(it) }
    }

    private fun initTables(dataSource: DataSource) {
        dataSource.connection.use { conn ->
            conn.createStatement().use { it.execute(SQL_CREATE_LOOP_STATE_TABLE) }
            conn.createStatement().use { it.execute(SQL_CREATE_RESULT_TABLE) }
            conn.createStatement().use { it.execute(SQL_CREATE_RESULT_INDEX_PROJECT) }
            conn.createStatement().use { it.execute(SQL_CREATE_RESULT_INDEX_STATUS) }

            try {
                conn.createStatement().use { it.execute(SQL_CREATE_RESULT_UNIQUE) }
            } catch (e: Exception) {
                logger.debug("唯一约束已存在: ${e.message}")
            }

            logger.info("分析状态表初始化完成")
        }
    }

    // ========== 分析循环状态方法 ==========

    /**
     * 保存/更新分析循环状态
     */
    suspend fun saveLoopState(state: AnalysisLoopState) = withContext(Dispatchers.IO) {
        require(state.projectKey.isNotBlank()) { "projectKey 不能为空" }

        val existing = getLoopState(state.projectKey)
        val todosJson = state.analysisTodos.toJsonOrNull()

        dataSource.connection.use { connection ->
            if (existing != null) {
                updateLoopState(connection, state, todosJson)
            } else {
                insertLoopState(connection, state, todosJson)
            }
        }
    }

    private fun updateLoopState(connection: java.sql.Connection, state: AnalysisLoopState, todosJson: String?) {
        connection.prepareStatement(SQL_UPDATE_LOOP_STATE).use { stmt ->
            stmt.setBoolean(1, state.enabled)
            stmt.setString(2, state.currentPhase.name)
            stmt.setString(3, state.currentAnalysisType?.name)
            stmt.setInt(4, state.currentStep)
            stmt.setString(5, todosJson)
            stmt.setInt(6, state.totalAnalyses)
            stmt.setInt(7, state.successfulAnalyses)
            stmt.setObject(8, state.lastAnalysisTime)
            stmt.setString(9, state.lastAnalysisTimeReadable)
            stmt.setString(10, state.lastError)
            stmt.setLong(11, System.currentTimeMillis())
            stmt.setString(12, state.projectKey)
            stmt.executeUpdate()
        }
        logger.debug("更新分析循环状态: projectKey={}", state.projectKey)
    }

    private fun insertLoopState(connection: java.sql.Connection, state: AnalysisLoopState, todosJson: String?) {
        connection.prepareStatement(SQL_INSERT_LOOP_STATE).use { stmt ->
            stmt.setString(1, state.projectKey)
            stmt.setBoolean(2, state.enabled)
            stmt.setString(3, state.currentPhase.name)
            stmt.setString(4, state.currentAnalysisType?.name)
            stmt.setInt(5, state.currentStep)
            stmt.setString(6, todosJson)
            stmt.setInt(7, state.totalAnalyses)
            stmt.setInt(8, state.successfulAnalyses)
            stmt.setObject(9, state.lastAnalysisTime)
            stmt.setString(10, state.lastAnalysisTimeReadable)
            stmt.setString(11, state.lastError)
            stmt.setLong(12, System.currentTimeMillis())
            stmt.executeUpdate()
        }
        logger.debug("保存分析循环状态: projectKey={}", state.projectKey)
    }

    /**
     * 获取分析循环状态
     */
    suspend fun getLoopState(projectKey: String): AnalysisLoopState? = withContext(Dispatchers.IO) {
        require(projectKey.isNotBlank()) { "projectKey 不能为空" }

        dataSource.connection.use { connection ->
            connection.prepareStatement(SQL_GET_LOOP_STATE).use { stmt ->
                stmt.setString(1, projectKey)
                val rs = stmt.executeQuery()
                if (rs.next()) rs.toLoopState() else null
            }
        }
    }

    // ========== 分析结果方法 ==========

    /**
     * 保存/更新分析结果
     */
    suspend fun saveAnalysisResult(result: AnalysisResultEntity) = withContext(Dispatchers.IO) {
        require(result.projectKey.isNotBlank()) { "projectKey 不能为空" }

        val existing = getAnalysisResult(result.projectKey, result.analysisType)
        val missingSectionsJson = result.missingSections.toJsonOrNull()
        val todosJson = result.analysisTodos.toJsonOrNull()

        dataSource.connection.use { connection ->
            if (existing != null) {
                updateAnalysisResult(connection, result, missingSectionsJson, todosJson)
            } else {
                insertAnalysisResult(connection, result, missingSectionsJson, todosJson)
            }
        }
    }

    private fun updateAnalysisResult(
        connection: java.sql.Connection,
        result: AnalysisResultEntity,
        missingSectionsJson: String?,
        todosJson: String?
    ) {
        connection.prepareStatement(SQL_UPDATE_RESULT).use { stmt ->
            stmt.setString(1, result.mdFilePath)
            stmt.setDouble(2, result.completeness)
            stmt.setString(3, missingSectionsJson)
            stmt.setString(4, todosJson)
            stmt.setString(5, result.taskStatus.name)
            stmt.setInt(6, result.currentStep)
            stmt.setString(7, result.toolCallHistory)
            stmt.setLong(8, System.currentTimeMillis())
            stmt.setString(9, TimestampFormatter.now())
            stmt.setString(10, result.projectKey)
            stmt.setString(11, result.analysisType.name)
            stmt.executeUpdate()
        }
        logger.debug("更新分析结果: projectKey={}, type={}", result.projectKey, result.analysisType)
    }

    private fun insertAnalysisResult(
        connection: java.sql.Connection,
        result: AnalysisResultEntity,
        missingSectionsJson: String?,
        todosJson: String?
    ) {
        connection.prepareStatement(SQL_INSERT_RESULT).use { stmt ->
            stmt.setString(1, result.projectKey)
            stmt.setString(2, result.analysisType.name)
            stmt.setString(3, result.mdFilePath)
            stmt.setDouble(4, result.completeness)
            stmt.setString(5, missingSectionsJson)
            stmt.setString(6, todosJson)
            stmt.setString(7, result.taskStatus.name)
            stmt.setInt(8, result.currentStep)
            stmt.setString(9, result.toolCallHistory)
            stmt.setLong(10, result.createdAt)
            stmt.setString(11, result.createdAtReadable)
            stmt.setLong(12, System.currentTimeMillis())
            stmt.setString(13, TimestampFormatter.now())
            stmt.executeUpdate()
        }
        logger.debug("保存分析结果: projectKey={}, type={}", result.projectKey, result.analysisType)
    }

    /**
     * 获取分析结果
     */
    suspend fun getAnalysisResult(projectKey: String, type: AnalysisType): AnalysisResultEntity? =
        withContext(Dispatchers.IO) {
            require(projectKey.isNotBlank()) { "projectKey 不能为空" }

            dataSource.connection.use { connection ->
                connection.prepareStatement(SQL_GET_RESULT).use { stmt ->
                    stmt.setString(1, projectKey)
                    stmt.setString(2, type.name)
                    val rs = stmt.executeQuery()
                    if (rs.next()) rs.toResultEntity() else null
                }
            }
        }

    /**
     * 获取项目的所有分析结果
     */
    suspend fun getAllAnalysisResults(projectKey: String): List<AnalysisResultEntity> =
        withContext(Dispatchers.IO) {
            require(projectKey.isNotBlank()) { "projectKey 不能为空" }

            dataSource.connection.use { connection ->
                connection.prepareStatement(SQL_GET_ALL_RESULTS).use { stmt ->
                    stmt.setString(1, projectKey)
                    val rs = stmt.executeQuery()
                    val results = mutableListOf<AnalysisResultEntity>()
                    while (rs.next()) {
                        results.add(rs.toResultEntity())
                    }
                    results
                }
            }
        }

    /**
     * 更新任务状态
     */
    suspend fun updateTaskStatus(projectKey: String, type: AnalysisType, status: TaskStatus) =
        withContext(Dispatchers.IO) {
            require(projectKey.isNotBlank()) { "projectKey 不能为空" }

            dataSource.connection.use { connection ->
                connection.prepareStatement(SQL_UPDATE_TASK_STATUS).use { stmt ->
                    stmt.setString(1, status.name)
                    stmt.setLong(2, System.currentTimeMillis())
                    stmt.setString(3, TimestampFormatter.now())
                    stmt.setString(4, projectKey)
                    stmt.setString(5, type.name)
                    stmt.executeUpdate()
                }
            }
            logger.debug("更新任务状态: projectKey={}, type={}, status={}", projectKey, type, status)
        }

    /**
     * 更新完整度
     */
    suspend fun updateCompleteness(projectKey: String, type: AnalysisType, completeness: Double) =
        withContext(Dispatchers.IO) {
            require(projectKey.isNotBlank()) { "projectKey 不能为空" }

            dataSource.connection.use { connection ->
                connection.prepareStatement(SQL_UPDATE_COMPLETENESS).use { stmt ->
                    stmt.setDouble(1, completeness)
                    stmt.setLong(2, System.currentTimeMillis())
                    stmt.setString(3, TimestampFormatter.now())
                    stmt.setString(4, projectKey)
                    stmt.setString(5, type.name)
                    stmt.executeUpdate()
                }
            }
            logger.debug("更新完整度: projectKey={}, type={}, completeness={}", projectKey, type, completeness)
        }

    /**
     * 获取 DOING 状态的任务
     */
    suspend fun getDoingTasks(projectKey: String): List<AnalysisResultEntity> = withContext(Dispatchers.IO) {
        require(projectKey.isNotBlank()) { "projectKey 不能为空" }

        dataSource.connection.use { connection ->
            connection.prepareStatement(SQL_GET_DOING_TASKS).use { stmt ->
                stmt.setString(1, projectKey)
                val rs = stmt.executeQuery()
                val results = mutableListOf<AnalysisResultEntity>()
                while (rs.next()) {
                    results.add(rs.toResultEntity())
                }
                results
            }
        }
    }

    /**
     * 重置 DOING 任务为 PENDING
     */
    suspend fun resetDoingTasksToPending(projectKey: String) = withContext(Dispatchers.IO) {
        require(projectKey.isNotBlank()) { "projectKey 不能为空" }

        dataSource.connection.use { connection ->
            connection.prepareStatement(SQL_RESET_DOING_TO_PENDING).use { stmt ->
                stmt.setLong(1, System.currentTimeMillis())
                stmt.setString(2, TimestampFormatter.now())
                stmt.setString(3, projectKey)
                val count = stmt.executeUpdate()
                logger.debug("重置 DOING 任务为 PENDING: projectKey={}, count={}", projectKey, count)
            }
        }
    }

    /**
     * 添加 TODO
     */
    suspend fun addTodo(projectKey: String, type: AnalysisType, todo: AnalysisTodo) =
        withContext(Dispatchers.IO) {
            require(projectKey.isNotBlank()) { "projectKey 不能为空" }

            val existing = getAnalysisResult(projectKey, type)
            if (existing == null) {
                logger.warn("分析结果不存在，无法添加 TODO: projectKey={}, type={}", projectKey, type)
                return@withContext
            }

            val updatedTodos = existing.analysisTodos + todo
            updateTodos(projectKey, type, updatedTodos)
            logger.debug("添加 TODO: projectKey={}, type={}, todoId={}", projectKey, type, todo.id)
        }

    /**
     * 更新 TODO 状态
     */
    suspend fun updateTodoStatus(
        projectKey: String,
        type: AnalysisType,
        todoId: String,
        status: TodoStatus
    ) = withContext(Dispatchers.IO) {
        require(projectKey.isNotBlank()) { "projectKey 不能为空" }

        val existing = getAnalysisResult(projectKey, type)
        if (existing == null) {
            logger.warn("分析结果不存在，无法更新 TODO 状态: projectKey={}, type={}", projectKey, type)
            return@withContext
        }

        val updatedTodos = existing.analysisTodos.map { todo ->
            if (todo.id == todoId) todo.copy(status = status) else todo
        }
        updateTodos(projectKey, type, updatedTodos)
        logger.debug("更新 TODO 状态: projectKey={}, type={}, todoId={}, status={}", projectKey, type, todoId, status)
    }

    /**
     * 删除已完成的 TODO
     */
    suspend fun removeCompletedTodos(projectKey: String, type: AnalysisType) = withContext(Dispatchers.IO) {
        require(projectKey.isNotBlank()) { "projectKey 不能为空" }

        val existing = getAnalysisResult(projectKey, type)
        if (existing == null) {
            logger.warn("分析结果不存在，无法删除 TODO: projectKey={}, type={}", projectKey, type)
            return@withContext
        }

        val remainingTodos = existing.analysisTodos.filter { it.status != TodoStatus.COMPLETED }
        updateTodos(projectKey, type, remainingTodos)
        logger.debug(
            "删除已完成 TODO: projectKey={}, type={}, removed={}",
            projectKey, type, existing.analysisTodos.size - remainingTodos.size
        )
    }

    private suspend fun updateTodos(projectKey: String, type: AnalysisType, todos: List<AnalysisTodo>) =
        withContext(Dispatchers.IO) {
            val todosJson = if (todos.isNotEmpty()) json.encodeToString(todos) else null

            dataSource.connection.use { connection ->
                connection.prepareStatement(SQL_UPDATE_TODOS).use { stmt ->
                    stmt.setString(1, todosJson)
                    stmt.setLong(2, System.currentTimeMillis())
                    stmt.setString(3, TimestampFormatter.now())
                    stmt.setString(4, projectKey)
                    stmt.setString(5, type.name)
                    stmt.executeUpdate()
                }
            }
        }

    /**
     * 获取项目统计信息
     */
    suspend fun getProjectStatistics(projectKey: String): AnalysisStatistics = withContext(Dispatchers.IO) {
        require(projectKey.isNotBlank()) { "projectKey 不能为空" }

        dataSource.connection.use { connection ->
            connection.prepareStatement(SQL_GET_STATISTICS).use { stmt ->
                stmt.setString(1, projectKey)
                val rs = stmt.executeQuery()
                if (rs.next()) {
                    AnalysisStatistics(
                        totalTasks = rs.getInt("total_tasks"),
                        completedTasks = rs.getInt("completed_tasks"),
                        pendingTasks = rs.getInt("pending_tasks"),
                        doingTasks = rs.getInt("doing_tasks"),
                        failedTasks = rs.getInt("failed_tasks"),
                        averageCompleteness = rs.getDouble("avg_completeness")
                    )
                } else {
                    AnalysisStatistics()
                }
            }
        }
    }

    /**
     * 关闭数据库连接
     */
    fun close() {
        if (dataSource is HikariDataSource) {
            dataSource.close()
        }
        logger.info("AnalysisStateRepository 数据库连接已关闭")
    }

    // ========== 辅助方法 ==========

    private inline fun <reified T> List<T>.toJsonOrNull(): String? {
        return if (this.isNotEmpty()) json.encodeToString(this) else null
    }

    private fun ResultSet.toLoopState(): AnalysisLoopState {
        return AnalysisLoopState(
            projectKey = getString("project_key"),
            enabled = getBoolean("enabled"),
            currentPhase = parseEnum(getString("current_phase"), AnalysisPhase.IDLE),
            currentAnalysisType = parseAnalysisTypeOrNull(getString("current_analysis_type")),
            currentStep = getInt("current_step"),
            analysisTodos = parseJsonList(getString("analysis_todos")),
            totalAnalyses = getInt("total_analyses"),
            successfulAnalyses = getInt("successful_analyses"),
            lastAnalysisTime = getObject("last_analysis_time") as? Long,
            lastAnalysisTimeReadable = getString("last_analysis_time_readable"),
            lastError = getString("last_error"),
            lastUpdatedAt = getLong("last_updated_at")
        )
    }

    private fun parseAnalysisTypeOrNull(value: String?): AnalysisType? {
        if (value == null) return null
        return try {
            AnalysisType.valueOf(value)
        } catch (e: Exception) {
            null
        }
    }

    private fun ResultSet.toResultEntity(): AnalysisResultEntity {
        return AnalysisResultEntity(
            projectKey = getString("project_key"),
            analysisType = parseEnum(getString("analysis_type"), AnalysisType.PROJECT_STRUCTURE),
            mdFilePath = getString("md_file_path"),
            completeness = getDouble("completeness"),
            missingSections = parseJsonList(getString("missing_sections")),
            analysisTodos = parseJsonList(getString("analysis_todos")),
            taskStatus = parseEnum(getString("task_status"), TaskStatus.PENDING),
            currentStep = getInt("current_step"),
            toolCallHistory = getString("tool_call_history"),
            createdAt = getLong("created_at"),
            createdAtReadable = getString("created_at_readable"),
            updatedAt = getLong("updated_at"),
            updatedAtReadable = getString("updated_at_readable")
        )
    }

    private inline fun <reified T : Enum<T>> parseEnum(value: String?, defaultValue: T): T {
        if (value == null) return defaultValue
        return try {
            enumValueOf<T>(value)
        } catch (e: Exception) {
            defaultValue
        }
    }

    private inline fun <reified T : Enum<T>> parseEnumOrNull(value: String?): T? {
        if (value == null) return null
        return try {
            enumValueOf<T>(value)
        } catch (e: Exception) {
            null
        }
    }

    private inline fun <reified T> parseJsonList(jsonStr: String?): List<T> {
        if (jsonStr.isNullOrBlank()) return emptyList()
        return try {
            json.decodeFromString(jsonStr)
        } catch (e: Exception) {
            logger.warn("Failed to parse JSON list: {}", e.message)
            emptyList()
        }
    }
}
