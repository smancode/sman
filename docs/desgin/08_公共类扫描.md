# 08 - 公共类扫描

## 目标

为 SmanAgent 项目添加公共类扫描能力，自动识别项目中的工具类、公共方法、配置类、异常类等通用组件，分析它们的功能和分类，为后续的代码理解和问题排查提供基础数据，并支持 BGE 召回 + 重排。

## 参考

- knowledge-graph-system 的 `CommonCapabilityDetector.java`
- knowledge-graph-system 的 `ArchitectureAnalyzer.java`
- Java 工具类设计最佳实践

## 核心功能

### 1. 公共类识别

**目标**：识别项目中的公共类

**输出**：
- 工具类（Util/Utils/Helper 结尾）
- 公共服务类（位于 common/shared/public 包）
- 配置类（Config/Configuration 结尾，位于 config 包）
- 异常类（Exception/Error 结尾，位于 exception/errors 包）
- 常量类（Constants 结尾，位于 constants 包）

**识别规则**：
```kotlin
// 1. 基于类名后缀识别
StringUtils        → 字符串工具类
DateUtil           → 日期工具类
JsonHelper         → JSON 处理类
CryptoUtils        → 加密工具类

// 2. 基于包名识别
*.util.*           → 工具包
*.common.*         → 公共包
*.shared.*         → 共享包
*.helper.*         → 辅助包
*.constants.*      → 常量包
*.config.*         → 配置包
*.exception.*      → 异常包
*.errors.*         → 错误包

// 3. PSI 扫描策略
// - 扫描所有 .kt 和 .java 文件
// - 提取类名和包名
// - 匹配识别规则
```

### 2. 公共方法识别

**目标**：识别公共类中的公共方法

**输出**：
- 方法签名
- 方法参数
- 返回值类型
- 方法功能描述
- 被调用次数（可选）

**识别规则**：
```kotlin
// 1. 基于方法名模式识别
fun isValidEmail(email: String): Boolean        → 验证方法
fun formatDate(date: Date): String              → 格式化方法
fun parseJson(json: String): Map<String, Any>   → 解析方法
fun calculateDistance(x1: Double, x2: Double): Double → 计算方法

// 2. 基于注解识别
@JsonIgnore
fun getInternalValue(): String                  → JSON 处理相关
@Deprecated
fun oldMethod(): Unit                           → 已废弃方法
@JvmStatic
fun staticMethod(): Unit                        → 静态方法

// 3. PSI 扫描策略
// - 在公共类中查找所有 public 方法
// - 提取方法签名、参数、返回值
// - 记录方法文档注释
```

### 3. 功能分类

**目标**：对公共类和方法进行功能分类

**输出**：
- 字符串处理类
- 日期时间处理类
- 数值计算类
- 集合处理类
- JSON 处理类
- 加密解密类
- 验证工具类
- 文件 IO 类
- 网络 HTTP 类
- 日志记录类
- 其他工具类

**分类规则**：
```kotlin
// 1. 基于类名推断
StringUtil         → 字符串处理
DateUtil           → 日期时间
MathUtil           → 数值计算
CollectionUtil     → 集合处理
JsonUtil           → JSON 处理
CryptoUtil         → 加密解密
ValidationUtil     → 验证工具
FileUtil           → 文件 IO
HttpUtil           → 网络 HTTP
LogUtil            → 日志记录

// 2. 基于方法名推断
is*() / check*() / valid*()  → 验证方法
format*()                   → 格式化方法
parse*()                    → 解析方法
convert*() / transform*()    → 转换方法
calculate*() / compute*()    → 计算方法
encrypt*() / decrypt*()      → 加密解密
encode*() / decode*()        → 编解码

// 3. 基于方法签名推断
(String) -> Boolean          → 字符串验证
(String) -> Int              → 字符串解析
(Date) -> String             → 日期格式化
(Map<String, Any>) -> String → JSON 处理
```

### 4. 功能描述生成

**目标**：生成公共类的功能描述

**输出**：
- 类的功能概述
- 主要方法列表
- 典型使用场景

**生成规则**：
```kotlin
// 1. 基于类名和包名推断
StringUtils         → "字符串工具类，提供字符串验证、格式化、转换等功能"
DateUtil            → "日期时间工具类，提供日期格式化、解析、计算等功能"
JsonUtil            → "JSON 处理工具类，提供 JSON 序列化、反序列化、转换等功能"

// 2. 基于方法名和签名推断
isValidEmail()      → "验证是否是有效的邮箱地址"
formatDate()        → "格式化日期为指定格式的字符串"
parseJson()         → "解析 JSON 字符串为对象"

// 3. 基于方法文档注释提取
/**
 * 验证邮箱地址格式
 * @param email 邮箱地址
 * @return 是否有效
 */
fun isValidEmail(email: String): Boolean
→ "验证邮箱地址格式，返回布尔值"

// 4. PSI 扫描策略
// - 提取类的 KDoc 注释
// - 提取方法的 KDoc 注释
// - 如果没有注释，基于方法名生成描述
```

### 5. 调用关系分析

**目标**：分析公共方法的调用关系

**输出**：
- 方法被调用次数
- 调用方列表
- 调用图

**分析规则**：
```kotlin
// 1. PSI 扫描策略
// - 查找方法调用表达式
// - 统计每个方法被调用的次数
// - 记录调用方信息

// 2. 识别高频调用的公共方法
// - 被调用次数 >= 10
// - 被调用方数量 >= 3
// → 标记为"核心公共方法"

// 3. 示例
StringUtils.isEmpty()      → 调用 156 次，23 个调用方
DateUtil.formatDate()      → 调用 89 次，15 个调用方
JsonUtil.toJson()          → 调用 67 次，12 个调用方
```

### 6. 配置问题检测

**目标**：检测公共类和方法的潜在问题

**输出**：
- 警告列表
- 问题类型和严重程度

**检测规则**：
```kotlin
// 1. 工具类实例化检测
class StringUtils {
    // ❌ 警告：工具类不应被实例化
    // 建议：添加 private 构造函数
}

// ✅ 正确
class StringUtils {
    private constructor() {
        // 防止实例化
    }

    companion object {
        fun isEmpty(str: String?): Boolean = str == null || str.isEmpty()
    }
}

// 2. 静态方法滥用检测
// ❌ 警告：过度使用静态方法可能影响可测试性
// 建议：考虑使用依赖注入

// 3. 方法重复检测
// ❌ 警告：与 JDK 标准库方法重复
// 示例：自定义的 StringUtils.isEmpty() 可能与 String.isBlank() 重复

// 4. 参数校验缺失检测
// ❌ 警告：公共方法缺少参数校验
// 示例：parseJson(json: String) 应该先检查 json 是否为空

// 5. 异常处理不当检测
// ❌ 警告：吞掉异常
try {
    // ...
} catch (e: Exception) {
    // 静默忽略
}
```

## Kotlin 实现

### 文件位置

```
src/main/kotlin/com/smancode/smanagent/analyzer/
├── CommonClassDetector.kt            # 主检测器
├── classifier/
│   ├── CommonClassClassifier.kt      # 公共类分类器
│   └── MethodClassifier.kt           # 方法分类器
├── model/
│   ├── CommonClassInfo.kt            # 公共类信息
│   ├── MethodInfo.kt                 # 方法信息
│   ├── CommonClassCategory.kt        # 类别枚举
│   └── CallGraph.kt                  # 调用图
└── parser/
    ├── ClassAnnotationParser.kt      # 类注解解析
    └── MethodSignatureParser.kt      # 方法签名解析
```

### 核心接口

```kotlin
interface CommonClassDetector {
    /**
     * 扫描项目中的公共类
     * @param project IntelliJ Project 对象
     * @return 公共类信息列表
     */
    fun detect(project: Project): List<CommonClassInfo>

    /**
     * 分析公共方法
     * @param classInfo 公共类信息
     * @return 方法信息列表
     */
    fun analyzeMethods(classInfo: CommonClassInfo): List<MethodInfo>

    /**
     * 构建调用图
     * @param project IntelliJ Project 对象
     * @return 调用图
     */
    fun buildCallGraph(project: Project): CallGraph
}

data class CommonClassInfo(
    val id: String,                    // 唯一标识
    val className: String,             // 类名
    val qualifiedName: String,         // 全限定名
    val packageName: String,           // 包名
    val category: CommonClassCategory, // 类别
    val location: CodeLocation,        // 定义位置

    // 功能信息
    val description: String?,          // 功能描述
    val methods: List<MethodInfo>,     // 方法列表

    // 调用信息
    val callCount: Int,                // 被调用次数
    val callers: List<String>,         // 调用方列表

    // 问题检测
    val issues: List<ClassIssue>       // 问题列表
)

enum class CommonClassCategory {
    STRING_UTILS,           // 字符串工具类
    DATE_UTILS,             // 日期时间工具类
    MATH_UTILS,             // 数值计算类
    COLLECTION_UTILS,       // 集合处理类
    JSON_UTILS,             // JSON 处理类
    CRYPTO_UTILS,           // 加密解密类
    VALIDATION_UTILS,       // 验证工具类
    FILE_UTILS,             // 文件 IO 类
    HTTP_UTILS,             // 网络 HTTP 类
    LOG_UTILS,              // 日志记录类
    CONFIG_CLASS,           // 配置类
    CONSTANT_CLASS,         // 常量类
    EXCEPTION_CLASS,        // 异常类
    OTHER_UTILS             // 其他工具类
}

data class MethodInfo(
    val methodName: String,           // 方法名
    val signature: String,            // 方法签名
    val returnType: String,           // 返回值类型
    val parameters: List<Parameter>,  // 参数列表
    val isStatic: Boolean,            // 是否静态方法
    val isPublic: Boolean,            // 是否公共方法
    val description: String?,         // 功能描述
    val category: MethodCategory?,    // 方法类别

    // 调用信息
    val callCount: Int,               // 被调用次数
    val callers: List<String>         // 调用方列表
)

data class Parameter(
    val name: String,                 // 参数名
    val type: String                  // 参数类型
)

enum class MethodCategory {
    VALIDATION,              // 验证方法
    FORMAT,                  // 格式化方法
    PARSE,                   // 解析方法
    CONVERT,                 // 转换方法
    CALCULATE,               // 计算方法
    ENCRYPT_DECRYPT,         // 加密解密
    ENCODE_DECODE,           // 编解码
    IO_OPERATION,            // IO 操作
    HTTP_OPERATION,          // HTTP 操作
    LOG_OPERATION,           // 日志操作
    OTHER                    // 其他
}

data class CallGraph(
    val methods: Map<String, MethodInfo>,           // 方法信息
    val callRelations: Map<String, Set<String>>,    // 调用关系：caller -> callees
    val totalMethodCount: Int,                      // 总方法数
    val commonMethodCount: Int                      // 公共方法数
)

data class CodeLocation(
    val filePath: String,
    val lineNumber: Int,
    val className: String
)

data class ClassIssue(
    val severity: IssueSeverity,
    val type: IssueType,
    val message: String,
    val suggestion: String
)

enum class IssueSeverity {
    WARNING,
    ERROR,
    INFO
}

enum class IssueType {
    MISSING_PRIVATE_CONSTRUCTOR,     // 缺少私有构造函数
    STATIC_METHOD_OVERUSE,           // 静态方法滥用
    DUPLICATE_JDK_METHOD,            // 与 JDK 方法重复
    MISSING_PARAMETER_VALIDATION,    // 缺少参数校验
    SILENT_EXCEPTION,                // 静默异常
    MISSING_DOCUMENTATION,           // 缺少文档注释
    THREAD_SAFETY_ISSUE              // 线程安全问题
)
```

### PSI 扫描流程

```kotlin
class CommonClassDetectorImpl : CommonClassDetector {

    override fun detect(project: Project): List<CommonClassInfo> {
        val commonClasses = mutableListOf<CommonClassInfo>()

        // 1. 扫描所有 Kotlin 和 Java 文件
        val allFiles = getAllSourceFiles(project)

        // 2. 识别公共类
        allFiles.forEach { file ->
            val psiClass = getPsiClass(file)
            if (isCommonClass(psiClass)) {
                val classInfo = extractClassInfo(psiClass)
                commonClasses.add(classInfo)
            }
        }

        // 3. 构建调用图
        val callGraph = buildCallGraph(project)

        // 4. 更新调用信息
        updateCallInfo(commonClasses, callGraph)

        // 5. 检测问题
        commonClasses.forEach { detectIssues(it) }

        return commonClasses
    }

    private fun isCommonClass(psiClass: PsiClass): Boolean {
        val className = psiClass.name
        val packageName = getPackageName(psiClass)

        // 规则1：类名后缀
        val utilSuffixes = listOf("Util", "Utils", "Helper", "Helpers")
        if (utilSuffixes.any { className.endsWith(it) }) {
            return true
        }

        // 规则2：包名
        val commonPackages = listOf(".util.", ".common.", ".shared.",
                                     ".helper.", ".constants.",
                                     ".config.", ".exception.", ".errors.")
        if (commonPackages.any { packageName.contains(it) }) {
            return true
        }

        // 规则3：Config/Configuration 后缀
        if (className.endsWith("Config") || className.endsWith("Configuration")) {
            return true
        }

        // 规则4：Constants 后缀
        if (className.endsWith("Constants") || className.endsWith("Constant")) {
            return true
        }

        // 规则5：Exception/Error 后缀
        if (className.endsWith("Exception") || className.endsWith("Error")) {
            return true
        }

        return false
    }

    private fun extractClassInfo(psiClass: PsiClass): CommonClassInfo {
        val className = psiClass.name
        val qualifiedName = psiClass.qualifiedName
        val packageName = getPackageName(psiClass)

        // 分类
        val category = classifyCommonClass(className, packageName)

        // 提取文档注释
        val description = extractClassDescription(psiClass)

        // 分析方法
        val methods = analyzeMethods(psiClass)

        return CommonClassInfo(
            id = generateId(psiClass),
            className = className,
            qualifiedName = qualifiedName,
            packageName = packageName,
            category = category,
            location = extractLocation(psiClass),
            description = description,
            methods = methods,
            callCount = 0,
            callers = emptyList(),
            issues = emptyList()
        )
    }

    private fun classifyCommonClass(className: String, packageName: String): CommonClassCategory {
        val lowerName = className.lowercase()
        val lowerPackage = packageName.lowercase()

        return when {
            // 字符串工具类
            lowerName.contains("string") -> CommonClassCategory.STRING_UTILS

            // 日期时间工具类
            lowerName.contains("date") || lowerName.contains("time") ||
            lowerName.contains("calendar") || lowerName.contains("datetime") ->
                CommonClassCategory.DATE_UTILS

            // 数值计算类
            lowerName.contains("math") || lowerName.contains("number") ||
            lowerName.contains("calculate") || lowerName.contains("compute") ->
                CommonClassCategory.MATH_UTILS

            // 集合处理类
            lowerName.contains("collection") || lowerName.contains("list") ||
            lowerName.contains("map") || lowerName.contains("set") ->
                CommonClassCategory.COLLECTION_UTILS

            // JSON 处理类
            lowerName.contains("json") || lowerName.contains("json") ->
                CommonClassCategory.JSON_UTILS

            // 加密解密类
            lowerName.contains("crypto") || lowerName.contains("encrypt") ||
            lowerName.contains("decrypt") || lowerName.contains("cipher") ->
                CommonClassCategory.CRYPTO_UTILS

            // 验证工具类
            lowerName.contains("valid") || lowerName.contains("check") ->
                CommonClassCategory.VALIDATION_UTILS

            // 文件 IO 类
            lowerName.contains("file") || lowerName.contains("io") ||
            lowerName.contains("stream") || lowerName.contains("path") ->
                CommonClassCategory.FILE_UTILS

            // 网络 HTTP 类
            lowerName.contains("http") || lowerName.contains("request") ||
            lowerName.contains("response") || lowerName.contains("client") ->
                CommonClassCategory.HTTP_UTILS

            // 日志记录类
            lowerName.contains("log") || lowerName.contains("logger") ->
                CommonClassCategory.LOG_UTILS

            // 配置类
            lowerName.endsWith("config") || lowerName.endsWith("configuration") ||
            lowerPackage.contains(".config.") -> CommonClassCategory.CONFIG_CLASS

            // 常量类
            lowerName.endsWith("constants") || lowerName.endsWith("constant") ||
            lowerPackage.contains(".constants.") -> CommonClassCategory.CONSTANT_CLASS

            // 异常类
            lowerName.endsWith("exception") || lowerName.endsWith("error") ||
            lowerPackage.contains(".exception.") || lowerPackage.contains(".errors.") ->
                CommonClassCategory.EXCEPTION_CLASS

            // 其他工具类
            else -> CommonClassCategory.OTHER_UTILS
        }
    }

    override fun analyzeMethods(classInfo: CommonClassInfo): List<MethodInfo> {
        val psiClass = findPsiClass(classInfo.qualifiedName)
        val methods = mutableListOf<MethodInfo>()

        psiClass?.methods?.forEach { method ->
            if (method.isPublic || method.isStatic) {
                val methodInfo = extractMethodInfo(method)
                methods.add(methodInfo)
            }
        }

        return methods
    }

    private fun extractMethodInfo(method: PsiMethod): MethodInfo {
        val methodName = method.name
        val signature = buildMethodSignature(method)
        val returnType = method.returnType?.presentableText ?: "void"
        val parameters = extractParameters(method)
        val isStatic = method.isStatic
        val isPublic = method.isPublic

        // 提取文档注释
        val description = extractMethodDescription(method)

        // 分类
        val category = classifyMethod(methodName, signature)

        return MethodInfo(
            methodName = methodName,
            signature = signature,
            returnType = returnType,
            parameters = parameters,
            isStatic = isStatic,
            isPublic = isPublic,
            description = description,
            category = category,
            callCount = 0,
            callers = emptyList()
        )
    }

    private fun classifyMethod(methodName: String, signature: String): MethodCategory {
        val lowerName = methodName.lowercase()

        return when {
            // 验证方法
            lowerName.startsWith("is") || lowerName.startsWith("has") ||
            lowerName.startsWith("valid") || lowerName.startsWith("check") ->
                MethodCategory.VALIDATION

            // 格式化方法
            lowerName.startsWith("format") -> MethodCategory.FORMAT

            // 解析方法
            lowerName.startsWith("parse") -> MethodCategory.PARSE

            // 转换方法
            lowerName.startsWith("convert") || lowerName.startsWith("transform") ||
            lowerName.startsWith("to") -> MethodCategory.CONVERT

            // 计算方法
            lowerName.startsWith("calculate") || lowerName.startsWith("compute") ->
                MethodCategory.CALCULATE

            // 加密解密
            lowerName.startsWith("encrypt") || lowerName.startsWith("decrypt") ->
                MethodCategory.ENCRYPT_DECRYPT

            // 编解码
            lowerName.startsWith("encode") || lowerName.startsWith("decode") ->
                MethodCategory.ENCODE_DECODE

            // IO 操作
            lowerName.contains("read") || lowerName.contains("write") ||
            lowerName.contains("file") || lowerName.contains("stream") ->
                MethodCategory.IO_OPERATION

            // HTTP 操作
            lowerName.contains("http") || lowerName.contains("request") ||
            lowerName.contains("response") -> MethodCategory.HTTP_OPERATION

            // 日志操作
            lowerName.startsWith("log") || lowerName.contains("debug") ||
            lowerName.contains("info") || lowerName.contains("error") ->
                MethodCategory.LOG_OPERATION

            // 其他
            else -> MethodCategory.OTHER
        }
    }

    override fun buildCallGraph(project: Project): CallGraph {
        val methods = mutableMapOf<String, MethodInfo>()
        val callRelations = mutableMapOf<String, Set<String>>()

        // TODO: 实现调用图构建逻辑
        // 1. 遍历所有方法
        // 2. 分析方法体，查找方法调用
        // 3. 统计调用次数和调用方

        return CallGraph(
            methods = methods,
            callRelations = callRelations,
            totalMethodCount = methods.size,
            commonMethodCount = methods.values.count { it.callCount >= 3 }
        )
    }
}
```

## 与 knowledge-graph-system 的差异

### 可以借鉴的部分

1. **识别规则**
   - 基于类名后缀识别工具类（Util/Utils/Helper）
   - 基于包名识别公共包（util/common/shared/helper）
   - 基于方法名模式识别通用方法

2. **调用图构建**
   - 统计方法被调用次数
   - 记录调用方信息
   - 识别高频调用的公共方法

3. **分类逻辑**
   - 基于类名的功能分类
   - 基于方法名的功能分类

### 需要调整的部分

1. **语言适配**
   - Java → Kotlin
   - 支持 Kotlin 的 object（单例）
   - 支持 Kotlin 的 companion object

2. **IntelliJ PSI 集成**
   - 利用 IntelliJ PSI 获取更准确的语法树信息
   - 无需使用 Spoon 框架
   - 直接访问 PsiClass、PsiMethod

3. **KDoc 注释提取**
   - Java: Javadoc
   - Kotlin: KDoc
   - 提取类和方法的文档注释

4. **存储方式**
   - knowledge-graph-system 可能存入文件
   - SmanAgent 存入向量库，支持语义搜索

## 专家知识库

### 关键问题

1. **如何区分工具类和业务类？**
   - 方法1：基于类名后缀（Util/Utils/Helper）→ 准确率高
   - 方法2：基于包名（util/common/shared）→ 需要项目规范
   - 方法3：基于方法特征（静态方法、无状态）→ 准确率中等
   - 建议：三种方法结合，优先使用类名后缀

2. **如何生成公共类的功能描述？**
   - 方法1：提取类文档注释（KDoc）→ 最准确
   - 方法2：基于类名推断（StringUtils → 字符串工具类）→ 准确率中等
   - 方法3：基于方法名聚合（如果有 isEmpty/isBlank/format 等方法 → 字符串处理）→ 准确率中等
   - 建议：优先提取文档注释，如果没有则基于类名和方法名推断

3. **如何检测工具类的最佳实践违规？**
   - 规则1：工具类应该有私有构造函数，防止实例化
   - 规则2：工具类的所有方法应该是静态的（Kotlin 使用 companion object）
   - 规则3：工具类不应该有可变状态（无 var 属性）
   - 规则4：工具类不应该继承其他类
   - 建议：实现规则引擎，检查这些规则

4. **如何处理 Kotlin 的 object？**
   - Kotlin 的 object 是单例，相当于 Java 的静态类
   - 如果 object 的名称以 Util/Helper 结尾，应该识别为工具类
   - object 的方法类似于静态方法，应该被识别为公共方法
   - 建议：特殊处理 object 类型

5. **如何处理 Kotlin 的扩展函数？**
   - 扩展函数看起来像是类的成员方法，但实际上是静态方法
   - 如果扩展函数位于 util/common 包下，应该识别为公共方法
   - 建议：检查扩展函数的包名，识别公共扩展函数

### 工具类设计最佳实践

1. **工具类的特征**
   ```kotlin
   // ✅ 正确的工具类
   object StringUtils {
       /**
        * 检查字符串是否为空
        * @param str 字符串
        * @return 是否为空
        */
       fun isEmpty(str: String?): Boolean {
           return str == null || str.isEmpty()
       }

       /**
        * 格式化字符串
        * @param template 模板
        * @param args 参数
        * @return 格式化后的字符串
        */
       fun format(template: String, vararg args: Any): String {
           return String.format(template, *args)
       }
   }

   // ❌ 错误的工具类
   class StringUtils {
       // 缺少私有构造函数，可能被实例化
       // 缺少文档注释
       fun isEmpty(str: String?): Boolean {
           return str == null || str.isEmpty()
       }
   }
   ```

2. **工具类的方法命名**
   ```
   验证方法：is*(), has*(), valid*(), check*()
   格式化方法：format*()
   解析方法：parse*()
   转换方法：convert*(), to*()
   计算方法：calculate*(), compute*()
   ```

3. **避免与 JDK 标准库重复**
   ```kotlin
   // ❌ 不推荐：与 String.isBlank() 重复
   fun isEmpty(str: String?): Boolean = str.isNullOrBlank()

   // ❌ 不推荐：与 String.toInt() 重复
   fun toInt(str: String): Int = str.toInt()

   // ✅ 推荐：提供 JDK 没有的功能
   fun isEmail(str: String?): Boolean {
       return EmailValidator.getInstance().isValid(str)
   }
   ```

### Kotlin 特殊处理

1. **Kotlin object（单例）**
   ```kotlin
   // Kotlin 的 object 等价于 Java 的静态类
   object StringUtils {
       fun isEmpty(str: String?): Boolean = str.isNullOrEmpty()
   }

   // PSI 扫描策略：
   // - 检查 PsiClass.isObject()
   // - 如果是 object 且名称以 Util/Helper 结尾，识别为工具类
   // - object 的所有方法都是"静态"的
   ```

2. **Kotlin 扩展函数**
   ```kotlin
   // 扩展函数位于 util 包下
   package com.example.util

   fun String.isEmail(): Boolean {
       return EmailValidator.getInstance().isValid(this)
   }

   // PSI 扫描策略：
   // - 检查 PsiMethod 的返回类型是否有 isExtension 参数
   // - 如果扩展函数位于 util/common 包下，识别为公共方法
   ```

3. **Kotlin companion object**
   ```kotlin
   class StringUtils {
       companion object {
           fun isEmpty(str: String?): Boolean = str.isNullOrEmpty()
       }
   }

   // PSI 扫描策略：
   // - 检查 PsiClass 的 companion object
   // - companion object 中的方法类似于静态方法
   ```

### 常见公共类模式

1. **字符串工具类**
   ```kotlin
   object StringUtils {
       fun isEmpty(str: String?): Boolean
       fun isBlank(str: String?): Boolean
       fun capitalize(str: String): String
       fun truncate(str: String, maxLength: Int): String
       fun isEmail(str: String): Boolean
       fun isPhone(str: String): Boolean
   }
   ```

2. **日期时间工具类**
   ```kotlin
   object DateUtils {
       fun format(date: Date, pattern: String): String
       fun parse(dateStr: String, pattern: String): Date
       fun addDays(date: Date, days: Int): Date
       fun diffDays(date1: Date, date2: Date): Long
       fun isWeekend(date: Date): Boolean
   }
   ```

3. **JSON 工具类**
   ```kotlin
   object JsonUtils {
       fun toJson(obj: Any): String
       fun fromJson(json: String, clazz: Class<T>): T
       fun toMap(json: String): Map<String, Any>
       fun isValid(json: String): Boolean
   }
   ```

4. **加密解密工具类**
   ```kotlin
   object CryptoUtils {
       fun md5(str: String): String
       fun sha256(str: String): String
       fun encryptAES(data: String, key: String): String
       fun decryptAES(data: String, key: String): String
       fun generateUUID(): String
   }
   ```

5. **验证工具类**
   ```kotlin
   object ValidationUtils {
       fun isEmail(email: String?): Boolean
       fun isPhone(phone: String?): Boolean
       fun isIdCard(idCard: String?): Boolean
       fun isUrl(url: String?): Boolean
       fun isIp(ip: String?): Boolean
   }
   ```

## 待解决的问题

1. **增量更新**
   - 当公共类变化时，如何增量更新？
   - 如何检测新增、修改、删除的公共类？
   - 建议：基于文件修改时间或 Git diff

2. **调用图构建的性能**
   - 大型项目的方法数量多，构建调用图可能耗时
   - 是否需要全量分析？
   - 建议：只分析公共类的调用关系

3. **循环依赖检测**
   - 公共类之间可能存在循环依赖
   - 如何检测和报告循环依赖？
   - 建议：在调用图中检测环

4. **BGE 召回 + 重排**
   - 如何将公共类信息向量化？
   - 召回策略：基于类别、方法名相似度
   - 重排策略：基于功能描述相似度
   - 建议：设计专门的特征提取逻辑

5. **跨语言支持**
   - 项目可能同时包含 Java 和 Kotlin 代码
   - 如何处理跨语言调用？
   - 建议：统一使用 PSI，语言差异对 PSI 透明

6. **第三方库的处理**
   - 项目可能使用第三方工具类（如 Apache Commons Lang）
   - 是否需要扫描第三方库？
   - 建议：只扫描项目代码，不扫描依赖库

## 下一步

- [ ] 实现基础的公共类识别
- [ ] 实现方法分类和功能描述生成
- [ ] 实现调用图构建
- [ ] 实现问题检测
- [ ] 设计向量库 Schema
- [ ] 编写单元测试
- [ ] 编写专家知识库文档
