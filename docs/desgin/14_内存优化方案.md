# 14 - 内存优化方案

## 问题

AST 扫描和向量化会占用大量内存（估计 750 MB），可能影响 IntelliJ IDEA 的性能。

## 内存占用分析

### AST 缓存
- 10,000 个文件 × 4 KB = **40 MB**
- 调用图 = **10 MB**
- **总计：50 MB**

### 向量库
- 200,000 个片段 × 1.5 KB = **300 MB**
- JVector 索引 = **200 MB**
- **总计：500 MB**

### 总内存占用：~750 MB

## 优化方案

### 方案 1：内存映射文件（推荐）✅

**核心思想**：使用内存映射文件（MappedByteBuffer），让操作系统管理缓存。

#### 实现

```kotlin
/**
 * 基于内存映射文件的向量库
 */
class MappedVectorStore(
    private val dataDir: Path
) : VectorStore {

    private val indexFile = dataDir.resolve("vector_index.mmap")
    private val metadataFile = dataDir.resolve("vector_metadata.mmap")

    private var indexBuffer: MappedByteBuffer?
    private var metadataBuffer: MappedByteBuffer?

    init {
        // 加载时映射文件，不全部加载到内存
        indexBuffer = mapFile(indexFile)
        metadataBuffer = mapFile(metadataFile)
    }

    private fun mapFile(file: Path): MappedByteBuffer {
        val channel = FileChannel.open(file, StandardOpenOption.READ)
        return channel.map(
            FileChannel.MapMode.READ_ONLY,
            0,
            channel.size()
        )
    }

    override fun search(query: FloatArray, topK: Int): List<VectorFragment> {
        // 只加载需要的部分到内存
        // JVector 支持磁盘索引
        return vectorIndex.searchNearest(query, topK)
    }

    override fun close() {
        // 卸载映射
        indexBuffer = null
        metadataBuffer = null
    }
}
```

#### 优点
- ✅ 内存占用极低（只缓存热点数据）
- ✅ 操作系统自动管理缓存
- ✅ 支持超大向量库（10 GB+）

#### 缺点
- ❌ 实现复杂
- ❌ 依赖 JVector 的磁盘索引支持

---

### 方案 2：分级缓存（推荐）✅

**核心思想**：将数据分为热数据和冷数据，只缓存热数据。

#### 缓存策略

```kotlin
/**
 * 分级缓存策略
 */
enum class CacheLevel {
    HOT,   // 热数据：内存中（LRU，最多 100 MB）
    WARM,  // 温数据：内存映射文件
    COLD   // 冷数据：磁盘文件
}

/**
 * 分级缓存管理器
 */
class TieredCacheManager<K, V>(
    private val hotCacheSize: Long = 100 * 1024 * 1024, // 100 MB
    private val warmCacheSize: Long = 500 * 1024 * 1024 // 500 MB
) {
    // L1: 热数据缓存（内存，LRU）
    private val hotCache = object : LinkedHashMap<K, V>() {
        override fun removeEldestEntry(eldest: MutableMap.MutableEntry<K, V>?): Boolean {
            return size * estimateSize() > hotCacheSize
        }
    }

    // L2: 温数据缓存（内存映射）
    private val warmCache = ConcurrentHashMap<K, MappedByteBuffer>()

    // L3: 冷数据（磁盘）
    private val coldStorage = Path.of("data/cache")

    fun get(key: K): V? {
        // L1: 热数据
        hotCache[key]?.let { return it }

        // L2: 温数据
        warmCache[key]?.let { mapped ->
            val value = deserialize(mapped)
            // 提升到热数据
            hotCache[key] = value
            return value
        }

        // L3: 冷数据
        val file = coldStorage.resolve(key.toString())
        if (Files.exists(file)) {
            val value = Files.readAllBytes(file).let { deserialize(it) }
            // 提升到温数据
            warmCache[key] = mapFile(file)
            // 提升到热数据
            hotCache[key] = value
            return value
        }

        return null
    }

    fun put(key: K, value: V) {
        // 直接放入热数据
        hotCache[key] = value
    }

    private fun estimateSize(): Long {
        // 估算对象大小
        return 1000 // 示例
    }
}
```

#### 应用到向量库

```kotlin
/**
 * 分级向量库
 */
class TieredVectorStore : VectorStore {

    private val hotVectorCache = TieredCacheManager<String, FloatArray>(
        hotCacheSize = 50 * 1024 * 1024 // 50 MB
    )

    private val hotMetadataCache = TieredCacheManager<String, VectorMetadata>(
        hotCacheSize = 50 * 1024 * 1024 // 50 MB
    )

    // JVector 索引（磁盘索引）
    private val vectorIndex = OnDiskJVectorIndex(
        Path.of("data/vector/index.jvector")
    )

    override fun search(query: FloatArray, topK: Int): List<VectorFragment> {
        // 1. 使用 JVector 磁盘索引搜索
        val candidates = vectorIndex.searchNearest(query, topK = topK * 5) // 召回 5 倍

        // 2. 从缓存/磁盘加载元数据
        val results = candidates.map { candidate ->
            val metadata = hotMetadataCache.get(candidate.id)
                ?: loadMetadataFromDisk(candidate.id)
            VectorFragment(metadata, candidate.vector)
        }

        // 3. Reranker 重排
        return reranker.rerank(query, results, topK)
    }

    override fun add(fragment: VectorFragment) {
        // 1. 添加到 JVector 索引（磁盘）
        vectorIndex.add(fragment.id, fragment.vector)

        // 2. 元数据存入温数据缓存
        hotMetadataCache.put(fragment.id, fragment.metadata)
    }
}
```

#### 优点
- ✅ 内存占用可控（100 MB）
- ✅ 性能影响小
- ✅ 实现相对简单

#### 缺点
- ❌ 首次访问较慢（需从磁盘加载）

---

### 方案 3：延迟加载 + 按需计算

**核心思想**：不预先生成所有向量，按需计算。

#### 实现

```kotlin
/**
 * 延迟向量化服务
 */
class LazyVectorizationService : VectorizationService {

    private val vectorizedCache = ConcurrentHashMap<String, FloatArray>()

    suspend fun vectorize(text: String): FloatArray {
        val cacheKey = text.hashCode().toString()

        // 检查缓存
        vectorizedCache[cacheKey]?.let { return it }

        // 检查磁盘
        val diskCache = loadFromDisk(cacheKey)
        if (diskCache != null) {
            vectorizedCache[cacheKey] = diskCache
            return diskCache
        }

        // 计算 embedding
        val embedding = bgeService.embed(text)

        // 缓存（LRU，最多 50 MB）
        vectorizedCache[cacheKey] = embedding
        saveToDisk(cacheKey, embedding)

        return embedding
    }

    override fun search(query: String, topK: Int): List<SearchResult> {
        // 1. 向量化查询
        val queryVector = vectorize(query)

        // 2. 从磁盘加载候选向量（只加载 ID）
        val candidates = loadCandidatesFromDisk()

        // 3. 按需计算候选向量
        val scoredCandidates = candidates.map { candidate ->
            val vector = vectorize(candidate.text)
            val score = cosineSimilarity(queryVector, vector)
            candidate to score
        }

        // 4. 排序取 Top-K
        return scoredCandidates
            .sortedByDescending { it.second }
            .take(topK)
            .map { (candidate, score) ->
                SearchResult(candidate, score)
            }
    }
}
```

#### 优点
- ✅ 内存占用最小（~50 MB）
- ✅ 只向量化需要的内容

#### 缺点
- ❌ 搜索速度慢（需实时计算）

---

### 方案 4：外部向量数据库（推荐）✅

**核心思想**：使用独立的向量数据库服务，插件只负责调用 API。

#### 架构

```
IntelliJ IDEA 插件
    ↓ HTTP/gRPC
向量数据库服务（独立进程）
    ↓
JVector/Qdrant/Milvus
```

#### 实现

```kotlin
/**
 * 向量数据库客户端
 */
class VectorDatabaseClient(
    private val endpoint: String = "http://localhost:8080"
) : VectorStore {

    private val httpClient = HttpClient()

    override fun search(query: FloatArray, topK: Int): List<VectorFragment> {
        // 调用外部服务
        val response = httpClient.post("$endpoint/search") {
            setBody(Json.encodeToString(SearchRequest(query, topK)))
        }

        return Json.decodeFromString<List<VectorFragment>>(response.bodyAsText())
    }

    override fun add(fragment: VectorFragment) {
        // 异步添加到外部服务
        GlobalScope.launch {
            httpClient.post("$endpoint/add") {
                setBody(Json.encodeToString(fragment))
            }
        }
    }
}

/**
 * 向量数据库服务（独立进程）
 */
class VectorDatabaseService(
    private port: Int = 8080
) {
    private val vectorStore = JVectorOnDiskStore()

    fun start() {
        embeddedServer(Netty, port) {
            routing {
                post("/search") {
                    val request = call.receive<SearchRequest>()
                    val results = vectorStore.search(request.query, request.topK)
                    call.respond(results)
                }

                post("/add") {
                    val fragment = call.receive<VectorFragment>()
                    vectorStore.add(fragment)
                    call.respond(HttpStatusCode.OK)
                }
            }
        }.start(wait = true)
    }
}
```

#### 优点
- ✅ 插件内存占用极低（~10 MB）
- ✅ 不影响 IDEA 性能
- ✅ 可以复用向量数据库（多个项目共享）

#### 缺点
- ❌ 需要额外部署服务
- ❌ 依赖网络/本地通信

---

## 推荐方案组合

### 对于小型项目（< 1000 个文件）

**方案 2：分级缓存**
- 热数据缓存：50 MB
- 温数据缓存：200 MB
- 总内存占用：~250 MB

### 对于中型项目（1000-10000 个文件）

**方案 2 + 方案 3：分级缓存 + 延迟加载**
- 热数据缓存：50 MB
- 按需向量化
- 总内存占用：~150 MB

### 对于大型项目（> 10000 个文件）

**方案 4：外部向量数据库服务**
- 插件内存占用：~10 MB
- 独立服务内存：1-2 GB

---

## AST 缓存优化

### 优化 1：只缓存必要信息

```kotlin
/**
 * 精简的 AST 信息
 */
data class CompactAstInfo(
    val className: String,
    val simpleName: String,
    val packageName: String,
    val methods: List<CompactMethodInfo>, // 只保留方法签名
    val fields: List<CompactFieldInfo>,   // 只保留字段签名
    // 移除：完整的 PSI 树、注释、文档
)
```

### 优化 2：按需加载 PSI

```kotlin
/**
 * 懒加载 PSI
 */
class LazyPsiClass(
    private val project: Project,
    private val qualifiedName: String
) {
    private var psiClass: PsiClass? = null

    fun get(): PsiClass {
        if (psiClass == null) {
            psiClass = PsiNameHelper.resolveClass(qualifiedName, project)
        }
        return psiClass!!
    }
}
```

### 优化 3：增量加载

```kotlin
/**
 * 增量加载 AST
 */
class IncrementalAstLoader {

    private val loadedClasses = ConcurrentHashMap<String, ClassAstInfo>()

    fun loadClass(qualifiedName: String): ClassAstInfo {
        // 检查缓存
        loadedClasses[qualifiedName]?.let { return it }

        // 从磁盘加载
        val file = astDir.resolve("${qualifiedName.replace('.', '/')}.json")
        if (Files.exists(file)) {
            val ast = Json.decodeFromFile<ClassAstInfo>(file)
            loadedClasses[qualifiedName] = ast
            return ast
        }

        // 解析 PSI
        val psiClass = findPsiClass(qualifiedName)
        val ast = parseAst(psiClass)
        loadedClasses[qualifiedName] = ast
        saveToDisk(qualifiedName, ast)
        return ast
    }
}
```

---

## 性能对比

| 方案 | 内存占用 | 搜索速度 | 实现复杂度 |
|------|---------|---------|-----------|
| 原方案（全内存） | 750 MB | 最快（~10ms） | 简单 |
| 方案 1（内存映射） | 100 MB | 快（~50ms） | 复杂 |
| 方案 2（分级缓存） | 250 MB | 快（~30ms） | 中等 |
| 方案 3（延迟加载） | 150 MB | 慢（~500ms） | 中等 |
| 方案 4（外部服务） | 10 MB | 中（~100ms） | 复杂 |

---

## 最终推荐

### 阶段 1：MVP（方案 2）
- 实现分级缓存
- 热数据：50 MB
- 温数据：200 MB
- 总内存：~250 MB

### 阶段 2：优化（方案 2 + 3）
- 分级缓存 + 延迟加载
- 总内存：~150 MB

### 阶段 3：企业版（方案 4）
- 外部向量数据库服务
- 插件内存：~10 MB
- 支持超大规模项目

---

## 配置化

允许用户在设置中调整内存限制：

```kotlin
data class MemoryConfig(
    val hotCacheSize: Long = 50 * 1024 * 1024,     // 50 MB
    val warmCacheSize: Long = 200 * 1024 * 1024,   // 200 MB
    val astCacheSize: Long = 50 * 1024 * 1024,     // 50 MB
    val enableLazyLoading: Boolean = true,
    val enableExternalService: Boolean = false
)
```

---

## 监控和告警

```kotlin
/**
 * 内存监控器
 */
class MemoryMonitor {

    fun checkMemoryUsage(): MemoryStatus {
        val runtime = Runtime.getRuntime()
        val usedMemory = runtime.totalMemory() - runtime.freeMemory()
        val maxMemory = runtime.maxMemory()
        val usage = usedMemory.toDouble() / maxMemory

        return when {
            usage > 0.9 -> MemoryStatus.CRITICAL
            usage > 0.7 -> MemoryStatus.WARNING
            else -> MemoryStatus.NORMAL
        }
    }

    fun cleanup() {
        // 触发缓存清理
        System.gc()
    }
}
```

---

## 下一步

- [ ] 实现方案 2（分级缓存）
- [ ] 实现 AST 优化（精简信息）
- [ ] 实现内存监控
- [ ] 添加配置界面
- [ ] 性能测试和调优
