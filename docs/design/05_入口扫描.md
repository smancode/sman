# 05 - 入口扫描

## 目标

为 SmanAgent 项目添加入口扫描能力，自动识别项目中的各种入口点（HTTP、MQ、RPC、定时任务等），提取入口元数据，并分析入口的业务功能。最终将分析结果存入向量库，支持 BGE 召回 + 重排。

**核心价值**：
- 为代码走读提供起点
- 支持业务能力分析
- 建立"业务 → 入口 → 代码"的映射关系

## 参考

- knowledge-graph-system 的 `AUTO_ENTRANCE_DETECTION.md`
- knowledge-graph-system 的 `EntranceDetector.java`
- knowledge-graph-system 的 `EntranceDetectionService.java`
- knowledge-graph-system 的 `Entrance.java`

## 核心功能

### 1. HTTP 入口识别

**目标**：识别所有 HTTP 接口入口

**识别规则**：

| 类型 | 注解 | 置信度 | 说明 |
|------|------|--------|------|
| HTTP | `@RestController` | 0.95 | Spring MVC REST 接口 |
| HTTP | `@Controller` | 0.95 | Spring MVC 控制器 |
| HTTP | `@RequestMapping` | 0.95 | Spring MVC 请求映射 |
| HTTP | `@GetMapping` | 0.95 | Spring MVC GET 请求 |
| HTTP | `@PostMapping` | 0.95 | Spring MVC POST 请求 |
| HTTP | `@PutMapping` | 0.95 | Spring MVC PUT 请求 |
| HTTP | `@DeleteMapping` | 0.95 | Spring MVC DELETE 请求 |
| HTTP | `@PatchMapping` | 0.95 | Spring MVC PATCH 请求 |

**提取元数据**：
- URL 路径：从 `@RequestMapping("/api/loan")` 提取 `/api/loan`
- HTTP 方法：GET、POST、PUT、DELETE、PATCH
- 请求参数类型：方法第一个参数类型（通常是 DTO）
- 返回类型：方法返回值类型
- 行号：方法定义位置

**检测流程**：
```kotlin
// 1. 扫描所有类，检查是否有 @RestController 或 @Controller 注解
// 2. 对每个 Controller 类，扫描所有 public 方法
// 3. 检查方法是否有 @RequestMapping 系列注解
// 4. 提取注解中的 URL 路径和 HTTP 方法
// 5. 提取方法参数类型和返回值类型
```

**检测示例**：
```kotlin
@RestController
@RequestMapping("/api/loan")
class LoanController {

    @PostMapping("/create")
    fun createLoan(@RequestBody request: LoanRequest): LoanResponse {
        // ...
    }
}
```

**检测结果**：
```json
{
  "className": "com.example.controller.LoanController",
  "methodName": "createLoan",
  "methodId": "com.example.controller.LoanController.createLoan(com.example.dto.LoanRequest)",
  "entranceType": "HTTP",
  "annotation": "PostMapping",
  "urlPath": "/api/loan/create",
  "httpMethod": "POST",
  "reqDto": "com.example.dto.LoanRequest",
  "rspDto": "com.example.dto.LoanResponse",
  "lineNumber": 42
}
```

### 2. MQ 入口识别

**目标**：识别所有消息队列监听器入口

**识别规则**：

| 类型 | 注解 | 置信度 | 说明 |
|------|------|--------|------|
| MQ | `@KafkaListener` | 0.95 | Kafka 消息监听 |
| MQ | `@RocketMQMessageListener` | 0.95 | RocketMQ 消息监听 |
| MQ | `@RabbitListener` | 0.95 | RabbitMQ 消息监听 |
| MQ | `@JmsListener` | 0.95 | JMS 消息监听 |

**提取元数据**：
- Topic/Queue 名称：从注解属性提取
- 消费者组：从注解属性提取
- 消息类型：方法第一个参数类型
- 行号：方法定义位置

**检测示例**：
```kotlin
@Component
class OrderMessageHandler {

    @KafkaListener(topics = ["order.created"], groupId = "order-group")
    fun handleOrderCreated(@Payload message: OrderMessage) {
        // ...
    }
}
```

**检测结果**：
```json
{
  "className": "com.example.handler.OrderMessageHandler",
  "methodName": "handleOrderCreated",
  "methodId": "com.example.handler.OrderMessageHandler.handleOrderCreated(com.example.dto.OrderMessage)",
  "entranceType": "MIDDLEWARE",
  "annotation": "KafkaListener",
  "metadata": {
    "topics": ["order.created"],
    "groupId": "order-group"
  },
  "reqDto": "com.example.dto.OrderMessage",
  "lineNumber": 28
}
```

### 3. RPC 入口识别

**目标**：识别所有 RPC 服务入口

**识别规则**：

| 类型 | 注解 | 置信度 | 说明 |
|------|------|--------|------|
| RPC | `@DubboService` | 0.95 | Dubbo 服务提供者 |
| RPC | `@Service` (Dubbo) | 0.90 | 可能是 Dubbo 服务（需验证） |

**验证逻辑**：
- 如果类同时有 `@Service` 和 `@DubboService`，则是 Dubbo 服务
- 如果只有 `@Service`，检查包名是否在 `service`、`api` 包下

**提取元数据**：
- 服务接口：类实现的接口
- 服务版本：从 `@DubboService` 的 version 属性提取
- 方法签名：所有 public 方法
- 参数类型：方法参数类型
- 返回类型：方法返回值类型

**检测示例**：
```kotlin
@DubboService(version = "1.0.0")
interface LoanService {

    fun createLoan(request: LoanRequest): LoanResponse
}
```

**检测结果**：
```json
{
  "className": "com.example.service.LoanService",
  "methodName": "createLoan",
  "methodId": "com.example.service.LoanService.createLoan(com.example.dto.LoanRequest)",
  "entranceType": "MIDDLEWARE",
  "annotation": "DubboService",
  "metadata": {
    "version": "1.0.0",
    "interface": "com.example.service.LoanService"
  },
  "reqDto": "com.example.dto.LoanRequest",
  "rspDto": "com.example.dto.LoanResponse",
  "lineNumber": 15
}
```

### 4. 定时任务识别

**目标**：识别所有定时任务入口

**识别规则**：

| 类型 | 注解 | 置信度 | 说明 |
|------|------|--------|------|
| SCHEDULED | `@XxlJob` | 0.95 | XXL-Job 定时任务 |
| SCHEDULED | `@Scheduled` | 0.95 | Spring 定时任务 |
| SCHEDULED | `@EnableScheduling` | 0.90 | 启用定时任务（类级别） |

**提取元数据**：
- 任务名称：从 `@XxlJob` 的 value 属性提取
- Cron 表达式：从 `@Scheduled` 的 cron 属性提取
- 固定延迟：从 `@Scheduled` 的 fixedDelay 属性提取
- 固定频率：从 `@Scheduled` 的 fixedRate 属性提取
- 行号：方法定义位置

**检测示例**：
```kotlin
@Component
class DailyInterestJob {

    @XxlJob("dailyInterestJob")
    fun execute() {
        // 计提日利息
    }
}
```

**检测结果**：
```json
{
  "className": "com.example.job.DailyInterestJob",
  "methodName": "execute",
  "methodId": "com.example.job.DailyInterestJob.execute()",
  "entranceType": "CLASS_BATCH",
  "annotation": "XxlJob",
  "metadata": {
    "jobName": "dailyInterestJob",
    "description": "日利息计提任务"
  },
  "lineNumber": 15
}
```

### 5. 事件监听器识别

**目标**：识别所有事件监听器入口

**识别规则**：

| 类型 | 注解 | 置信度 | 说明 |
|------|------|--------|------|
| EVENT | `@EventListener` | 0.95 | Spring 事件监听器 |

**提取元数据**：
- 事件类型：方法第一个参数类型
- 条件：从 `@EventListener` 的 condition 属性提取
- 行号：方法定义位置

**检测示例**：
```kotlin
@Component
class LoanEventListener {

    @EventListener
    fun handleLoanCreated(event: LoanCreatedEvent) {
        // 处理贷款创建事件
    }
}
```

**检测结果**：
```json
{
  "className": "com.example.listener.LoanEventListener",
  "methodName": "handleLoanCreated",
  "methodId": "com.example.listener.LoanEventListener.handleLoanCreated(com.example.event.LoanCreatedEvent)",
  "entranceType": "MIDDLEWARE",
  "annotation": "EventListener",
  "reqDto": "com.example.event.LoanCreatedEvent",
  "lineNumber": 22
}
```

### 6. 启发式类名匹配

**目标**：通过类名模式识别可能的入口（补充检测）

**识别规则**：

| 类名后缀 | 入口类型 | 置信度 | 示例 |
|----------|----------|--------|------|
| `*Controller` | HTTP | 0.60 | `LoanController` |
| `*Handler` | MIDDLEWARE | 0.60 | `DisburseHandler` |
| `*Processor` | MIDDLEWARE | 0.60 | `OrderProcessor` |
| `*Endpoint` | HTTP | 0.60 | `PaymentEndpoint` |
| `*Listener` | MIDDLEWARE | 0.60 | `OrderListener` |
| `*Job` | CLASS_BATCH | 0.50 | `DailyInterestJob` |
| `*Task` | CLASS_BATCH | 0.50 | `ReconciliationTask` |

**二次验证**：
- 如果类在 `controller`、`handler`、`endpoint` 包下 → 置信度 +0.2
- 如果类在 `job`、`task`、`batch` 包下 → 置信度 +0.2
- 如果类是 `abstract` → 排除
- 如果类有 `@Component`、`@Service` 注解 → 置信度 +0.1

### 7. 入口业务功能分析

**目标**：使用 LLM 分析入口的业务功能

**触发条件**：
- 入口检测完成
- 用户手动触发"重新分析"

**分析输入**：
```yaml
类名: com.example.controller.LoanController
方法名: createLoan
入口类型: HTTP
URL路径: /api/loan/create
HTTP方法: POST
请求参数: LoanRequest(amount, term, customerId)
返回类型: LoanResponse(loanId, status)
所在包: com.example.controller
技术栈: spring-boot, jpa
```

**LLM Prompt 模板**：
```yaml
你是代码分析专家。请分析以下系统入口的业务功能。

## 入口信息
类名: ${className}
方法名: ${methodName}
入口类型: ${entranceType}
URL路径: ${urlPath}
HTTP方法: ${httpMethod}

## 参数信息
请求参数类型: ${reqDto}
返回类型: ${rspDto}

## 上下文信息
所在包: ${packageName}
技术栈: ${techStack}

## 任务
请分析该入口的业务功能，输出以下内容：
1. 业务功能描述（一句话，不超过50字）
2. 业务领域（如：贷款、支付、风控）
3. 关键业务概念（3-5个关键词）

## 输出格式（JSON）
{
  "description": "创建贷款申请，接收贷款金额、期限等参数，返回贷款ID",
  "domain": "贷款",
  "keywords": ["贷款申请", "贷款创建", "贷款ID"],
  "confidence": 0.95
}
```

**分析结果存储**：
- `description`: 业务功能描述
- `domain`: 业务领域
- `keywords`: 关键词
- `confidence`: 分析置信度

### 8. 线程池配置分析

**目标**：分析入口方法使用的线程池配置，帮助理解入口的并发处理能力。

**识别规则**：

| 类型 | 注解/配置 | 置信度 | 说明 |
|------|----------|--------|------|
| @Async | `@Async("taskExecutor")` | 0.95 | 异步方法，指定线程池 |
| @Async | `@Async` | 0.90 | 异步方法，使用默认线程池 |
| ThreadPoolTaskExecutor | Spring Bean 配置 | 0.95 | Spring 线程池 |
| ExecutorService | 字段注入 | 0.90 | Java 原生线程池 |
| ForkJoinPool | 字段注入 | 0.90 | Fork/Join 线程池 |

**提取元数据**：
- 核心线程数
- 最大线程数
- 队列类型和容量
- 拒绝策略
- 线程名称前缀

**分析用途**：
- 评估入口的并发处理能力
- 识别可能的性能瓶颈
- 检测线程池配置问题（无界队列、缺少线程名前缀等）

**检测示例**：
```kotlin
@Service
class LoanService {

    @Autowired
    private lateinit var taskExecutor: ThreadPoolTaskExecutor

    @Async("loanProcessingExecutor")
    fun processLoanAsync(loanId: String) {
        // 异步处理贷款
    }
}
```

**检测结果**：
```json
{
  "className": "com.example.service.LoanService",
  "methodName": "processLoanAsync",
  "methodId": "...",
  "threadPool": {
    "type": "ThreadPoolTaskExecutor",
    "beanName": "loanProcessingExecutor",
    "coreSize": 10,
    "maxSize": 20,
    "queueCapacity": 100,
    "rejectionPolicy": "CallerRunsPolicy",
    "threadNamePrefix": "loan-async-"
  },
  "issues": [
    "队列容量较大(100)，可能导致内存积压"
  ]
}
```

## Kotlin 实现

### 文件位置

```
src/main/kotlin/com/smancode/smanagent/analyzer/
├── entrance/
│   ├── EntranceDetector.kt               # 主检测器
│   ├── HttpEntranceDetector.kt           # HTTP 入口检测
│   ├── MqEntranceDetector.kt             # MQ 入口检测
│   ├── RpcEntranceDetector.kt            # RPC 入口检测
│   ├── ScheduledEntranceDetector.kt      # 定时任务检测
│   ├── EventListenerDetector.kt          # 事件监听器检测
│   ├── HeuristicEntranceDetector.kt      # 启发式检测
│   └── model/
│       ├── Entrance.kt                   # 入口数据模型
│       ├── EntranceType.kt               # 入口类型枚举
│       ├── HttpEntranceMetadata.kt       # HTTP 元数据
│       ├── MqEntranceMetadata.kt         # MQ 元数据
│       ├── RpcEntranceMetadata.kt        # RPC 元数据
│       └── ScheduledEntranceMetadata.kt  # 定时任务元数据
```

### 核心接口

```kotlin
/**
 * 入口检测器接口
 */
interface EntranceDetector {
    /**
     * 检测所有入口
     * @param projectKey 项目标识
     * @param psiClasses 所有类
     * @return 检测结果
     */
    suspend fun detectAll(
        projectKey: String,
        psiClasses: Collection<PsiClass>
    ): EntranceDetectionResult
}

/**
 * 入口检测结果
 */
data class EntranceDetectionResult(
    val projectKey: String,
    val scanTime: Instant,
    val httpEntrances: List<HttpEntrance>,
    val mqEntrances: List<MqEntrance>,
    val rpcEntrances: List<RpcEntrance>,
    val scheduledEntrances: List<ScheduledEntrance>,
    val eventListenerEntrances: List<EventListenerEntrance>,
    val statistics: EntranceStatistics
)

/**
 * 入口统计信息
 */
data class EntranceStatistics(
    val totalCount: Int,
    val httpCount: Int,
    val mqCount: Int,
    val rpcCount: Int,
    val scheduledCount: Int,
    val eventListenerCount: Int
)

/**
 * HTTP 入口
 */
data class HttpEntrance(
    override val className: String,
    override val methodName: String,
    override val methodId: String,
    override val lineNumber: Int,
    val urlPath: String,
    val httpMethod: String,
    override val reqDto: String?,
    override val rspDto: String?,
    val description: String? = null,
    val domain: String? = null,
    val keywords: List<String> = emptyList()
) : Entrance()

/**
 * MQ 入口
 */
data class MqEntrance(
    override val className: String,
    override val methodName: String,
    override val methodId: String,
    override val lineNumber: Int,
    val mqType: MqType, // KAFKA, ROCKETMQ, RABBITMQ, JMS
    val topics: List<String>,
    val groupId: String?,
    override val reqDto: String?,
    val description: String? = null,
    val domain: String? = null
) : Entrance()

/**
 * RPC 入口
 */
data class RpcEntrance(
    override val className: String,
    override val methodName: String,
    override val methodId: String,
    override val lineNumber: Int,
    val rpcType: RpcType, // DUBBO
    val serviceInterface: String,
    val version: String?,
    override val reqDto: String?,
    override val rspDto: String?,
    val description: String? = null,
    val domain: String? = null
) : Entrance()

/**
 * 定时任务入口
 */
data class ScheduledEntrance(
    override val className: String,
    override val methodName: String,
    override val methodId: String,
    override val lineNumber: Int,
    val jobType: JobType, // XXL_JOB, SPRING_SCHEDULED
    val jobName: String?,
    val cron: String?,
    val description: String? = null,
    val domain: String? = null
) : Entrance()

/**
 * 事件监听器入口
 */
data class EventListenerEntrance(
    override val className: String,
    override val methodName: String,
    override val methodId: String,
    override val lineNumber: Int,
    override val reqDto: String?, // 事件类型
    val condition: String?,
    val description: String? = null,
    val domain: String? = null
) : Entrance()

/**
 * 入口基类
 */
sealed class Entrance {
    abstract val className: String
    abstract val methodName: String
    abstract val methodId: String
    abstract val lineNumber: Int
    abstract val reqDto: String?
    abstract val rspDto?

    // 线程池配置
    val threadPoolConfig: ThreadPoolConfig? = null
    // 配置问题
    val threadPoolIssues: List<ThreadPoolIssue> = emptyList()
}

/**
 * 线程池配置信息
 */
data class ThreadPoolConfig(
    val type: ThreadPoolType,
    val beanName: String?,
    val coreSize: Int?,
    val maxSize: Int?,
    val queueCapacity: Int?,
    val queueType: String?,
    val rejectionPolicy: String?,
    val threadNamePrefix: String?,
    val keepAliveSeconds: Int?,
    val allowCoreThreadTimeOut: Boolean?
)

enum class ThreadPoolType {
    THREAD_POOL_TASK_EXECUTOR,  // Spring ThreadPoolTaskExecutor
    EXECUTOR_SERVICE,           // Java ExecutorService
    FORK_JOIN_POOL,            // ForkJoinPool
    SCHEDULED_EXECUTOR_SERVICE, // ScheduledExecutorService
    UNKNOWN
}

/**
 * 线程池配置问题
 */
data class ThreadPoolIssue(
    val severity: IssueSeverity,
    val message: String,
    val suggestion: String?
)

enum class IssueSeverity {
    WARNING, ERROR, INFO
}

/**
 * 入口类型枚举
 */
enum class EntranceType {
    HTTP,           // HTTP 接口
    MIDDLEWARE,     // 中间件入口（MQ、RPC）
    CLASS_BATCH,    // 类级别批量任务
    FILE_BATCH,     // 文件级别批量任务
    EVENT_LISTENER, // 事件监听器
    UNKNOWN         // 未知类型
}

/**
 * MQ 类型枚举
 */
enum class MqType {
    KAFKA, ROCKETMQ, RABBITMQ, JMS, UNKNOWN
}

/**
 * RPC 类型枚举
 */
enum class RpcType {
    DUBBO, GRPC, UNKNOWN
}

/**
 * 任务类型枚举
 */
enum class JobType {
    XXL_JOB, SPRING_SCHEDULED, QUARTZ, UNKNOWN
}
```

### 核心实现

```kotlin
/**
 * HTTP 入口检测器
 */
class HttpEntranceDetector(
    private val llmService: LlmService
) {

    companion object {
        // HTTP 映射注解
        private val HTTP_MAPPING_ANNOTATIONS = setOf(
            "RequestMapping",
            "GetMapping",
            "PostMapping",
            "PutMapping",
            "DeleteMapping",
            "PatchMapping"
        )

        // Controller 注解
        private val CONTROLLER_ANNOTATIONS = setOf(
            "RestController",
            "Controller"
        )
    }

    /**
     * 检测 HTTP 入口
     */
    suspend fun detect(psiClass: PsiClass): List<HttpEntrance> {
        val entrances = mutableListOf<HttpEntrance>()

        // 1. 检查类是否有 @RestController 或 @Controller
        if (!isControllerClass(psiClass)) {
            return entrances
        }

        // 2. 提取类级别的 URL 路径
        val classLevelPath = extractClassLevelPath(psiClass)

        // 3. 扫描所有 public 方法
        psiClass.methods.forEach { method ->
            if (!method.hasModifierProperty(PsiModifier.PUBLIC)) {
                return@forEach
            }

            // 4. 检查方法是否有 HTTP 映射注解
            val mappingInfo = extractHttpMapping(method)
            if (mappingInfo != null) {
                val entrance = HttpEntrance(
                    className = psiClass.qualifiedName ?: "",
                    methodName = method.name,
                    methodId = generateMethodId(psiClass, method),
                    lineNumber = method.navigationElement?.textOffset ?: 0,
                    urlPath = combinePath(classLevelPath, mappingInfo.path),
                    httpMethod = mappingInfo.method,
                    reqDto = extractRequestDto(method),
                    rspDto = extractResponseDto(method)
                )
                entrances.add(entrance)
            }
        }

        return entrances
    }

    /**
     * 检查是否是 Controller 类
     */
    private fun isControllerClass(psiClass: PsiClass): Boolean {
        return psiClass.annotations.any { annotation ->
            val annotationName = annotation.qualifiedReferenceName
            CONTROLLER_ANNOTATIONS.any { annotationName?.endsWith(it) == true }
        }
    }

    /**
     * 提取类级别的 URL 路径
     */
    private fun extractClassLevelPath(psiClass: PsiClass): String? {
        val requestMapping = psiClass.annotations.find {
            it.qualifiedReferenceName?.endsWith("RequestMapping") == true
        } ?: return null

        return requestMapping.findAttributeValue("value")?.text?.removeSurrounding("\"")
    }

    /**
     * 提取 HTTP 映射信息
     */
    private fun extractHttpMapping(method: PsiMethod): HttpMappingInfo? {
        // 优先检查细粒度映射注解
        val fineGrainedMappings = listOf(
            "GetMapping" to "GET",
            "PostMapping" to "POST",
            "PutMapping" to "PUT",
            "DeleteMapping" to "DELETE",
            "PatchMapping" to "PATCH"
        )

        for ((annotationName, httpMethod) in fineGrainedMappings) {
            val annotation = method.annotations.find {
                it.qualifiedReferenceName?.endsWith(annotationName) == true
            }
            if (annotation != null) {
                val path = annotation.findAttributeValue("value")?.text?.removeSurrounding("\"")
                return HttpMappingInfo(httpMethod, path ?: "")
            }
        }

        // 检查 @RequestMapping
        val requestMapping = method.annotations.find {
            it.qualifiedReferenceName?.endsWith("RequestMapping") == true
        }
        if (requestMapping != null) {
            val path = requestMapping.findAttributeValue("value")?.text?.removeSurrounding("\"")
            val method = requestMapping.findAttributeValue("method")?.text ?: "GET"
            return HttpMappingInfo(method, path ?: "")
        }

        return null
    }

    /**
     * 提取请求 DTO
     */
    private fun extractRequestDto(method: PsiMethod): String? {
        val parameters = method.parameterList.parameters
        if (parameters.isEmpty()) {
            return null
        }

        // 检查第一个参数是否有 @RequestBody 或 @ModelAttribute
        val firstParam = parameters[0]
        val hasRequestBody = firstParam.annotations.any {
            it.qualifiedReferenceName?.endsWith("RequestBody") == true
        }
        val hasModelAttribute = firstParam.annotations.any {
            it.qualifiedReferenceName?.endsWith("ModelAttribute") == true
        }

        return if (hasRequestBody || hasModelAttribute) {
            firstParam.type.canonicalText
        } else {
            null
        }
    }

    /**
     * 提取响应 DTO
     */
    private fun extractResponseDto(method: PsiMethod): String? {
        val returnType = method.returnType
        if (returnType == PsiType.VOID) {
            return null
        }

        // 去除泛型参数
        val rawType = returnType.canonicalText
        val startIndex = rawType.indexOf('<')
        return if (startIndex > 0) {
            rawType.substring(0, startIndex)
        } else {
            rawType
        }
    }

    /**
     * 生成方法唯一标识
     */
    private fun generateMethodId(psiClass: PsiClass, method: PsiMethod): String {
        val className = psiClass.qualifiedName ?: ""
        val methodName = method.name
        val params = method.parameterList.parameters.joinToString(",") {
            it.type.canonicalText
        }
        return "$className.$methodName($params)"
    }

    /**
     * 组合路径
     */
    private fun combinePath(classPath: String?, methodPath: String): String {
        val base = classPath?.removeSuffix("/") ?: ""
        val path = methodPath.removePrefix("/")
        return "/$base/$path".replace("//", "/")
    }

    /**
     * HTTP 映射信息
     */
    private data class HttpMappingInfo(
        val method: String,
        val path: String
    )
}
```

### 入口业务功能分析

```kotlin
/**
 * 入口业务功能分析器
 */
class EntranceBusinessAnalyzer(
    private val llmService: LlmService
) {

    /**
     * 分析入口的业务功能
     */
    suspend fun analyze(entrance: Entrance): BusinessAnalysis {
        val prompt = buildPrompt(entrance)
        val response = llmService.chat(prompt)

        return parseResponse(response)
    }

    /**
     * 构建 Prompt
     */
    private fun buildPrompt(entrance: Entrance): String {
        return """
            你是代码分析专家。请分析以下系统入口的业务功能。

            ## 入口信息
            类名: ${entrance.className}
            方法名: ${entrance.methodName}
            入口类型: ${entrance::class.simpleName}

            ${buildEntranceSpecificInfo(entrance)}

            ## 分析要求
            请分析该入口的业务功能，输出以下内容：
            1. 业务功能描述（一句话，不超过50字）
            2. 业务领域（如：贷款、支付、风控）
            3. 关键业务概念（3-5个关键词）

            ## 输出格式（JSON）
            {
              "description": "业务功能描述",
              "domain": "业务领域",
              "keywords": ["关键词1", "关键词2", "关键词3"]
            }
        """.trimIndent()
    }

    /**
     * 构建入口特定信息
     */
    private fun buildEntranceSpecificInfo(entrance: Entrance): String {
        return when (entrance) {
            is HttpEntrance -> """
                URL路径: ${entrance.urlPath}
                HTTP方法: ${entrance.httpMethod}
                请求参数: ${entrance.reqDto ?: "无"}
                返回类型: ${entrance.rspDto ?: "void"}
            """.trimIndent()

            is MqEntrance -> """
                MQ类型: ${entrance.mqType}
                Topics: ${entrance.topics.joinToString(", ")}
                消费者组: ${entrance.groupId ?: "无"}
                消息类型: ${entrance.reqDto ?: "无"}
            """.trimIndent()

            else -> ""
        }
    }

    /**
     * 解析 LLM 响应
     */
    private fun parseResponse(response: String): BusinessAnalysis {
        // 提取 JSON 部分
        val jsonStart = response.indexOf("{")
        val jsonEnd = response.lastIndexOf("}") + 1
        val jsonStr = if (jsonStart >= 0 && jsonEnd > jsonStart) {
            response.substring(jsonStart, jsonEnd)
        } else {
            response
        }

        // 解析 JSON
        val json = Json.parseToJsonElement(jsonStr)
        return BusinessAnalysis(
            description = json.jsonObject["description"]?.jsonPrimitive?.content ?: "",
            domain = json.jsonObject["domain"]?.jsonPrimitive?.content ?: "",
            keywords = json.jsonObject["keywords"]?.jsonArray?.map { it.jsonPrimitive.content } ?: emptyList()
        )
    }
}

/**
 * 业务功能分析结果
 */
data class BusinessAnalysis(
    val description: String,
    val domain: String,
    val keywords: List<String>
)
```

## 与 knowledge-graph-system 的差异

### 可以借鉴的部分

1. **多策略检测**
   - 注解扫描（高置信度）
   - 启发式类名匹配（补充检测）
   - LLM 智能分析（业务功能分析）

2. **入口类型分类**
   - HTTP 入口
   - MIDDLEWARE 入口（MQ、RPC）
   - CLASS_BATCH 入口（定时任务）
   - EVENT_LISTENER 入口

3. **元数据提取**
   - URL 路径、HTTP 方法
   - Topic、Queue、Group
   - 请求/响应 DTO
   - Cron 表达式

### 需要调整的部分

1. **AST 解析方式**
   - knowledge-graph-system 使用 Spoon（外部库）
   - SmanAgent 使用 IntelliJ PSI（内置）

2. **检测策略**
   - knowledge-graph-system 支持配置驱动（父类名配置）
   - SmanAgent 采用零配置，全自动化

3. **存储方式**
   - knowledge-graph-system 存入文件系统
   - SmanAgent 存入向量库（待第 11 节设计）

4. **后台扫描**
   - knowledge-graph-system 使用守护线程
   - SmanAgent 使用 IntelliJ 的 BackgroundTask

## 专家知识库

### 关键问题

1. **如何区分普通的 @Service 和 Dubbo 服务？**
   - 检查是否有 `@DubboService` 注解
   - 检查是否在 `api`、`service` 包下
   - 检查是否实现了 interface
   - 检查是否被其他类注入使用（Dubbo 特性）

2. **如何提取 @RequestMapping 的路径？**
   - 类级别的 `@RequestMapping("/api")` + 方法级别的 `@GetMapping("/loan")`
   - 组合路径：`/api/loan`
   - 处理斜杠：去重、补全

3. **如何处理泛型返回类型？**
   - `ResponseEntity<LoanResponse>` → 提取 `LoanResponse`
   - `Result<LoanData>` → 提取 `LoanData`
   - 使用 `PsiType.getCanonicalText()` 并解析泛型参数

4. **如何提高 LLM 分析准确率？**
   - 提供完整上下文：类名、方法名、参数、返回值、所在包
   - 提供技术栈信息
   - 使用结构化 Prompt（JSON 格式输出）

5. **如何处理异步入口？**
   - `@Async` 注解的方法
   - `CompletableFuture` 返回类型
   - 线程池提交的代码（难以检测，需要调用链分析）

6. **如何检测入口方法使用的线程池？**
   - 检查 @Async 注解的 value 属性
   - 检查方法内部调用的 ExecutorService
   - 检查类注入的 ThreadPoolTaskExecutor

### 最佳实践

1. **检测顺序**
   - 先检测高置信度入口（注解扫描）
   - 再检测低置信度入口（启发式匹配）
   - 最后使用 LLM 分析业务功能

2. **性能优化**
   - 使用 PSI 缓存
   - 并发扫描多个类
   - 增量扫描（只扫描变更的文件）

3. **错误处理**
   - PSI 解析失败：记录日志，跳过该类
   - LLM 调用失败：使用默认分析结果
   - 元数据提取失败：使用 null 值

## 待解决的问题

1. **增量扫描**
   - 如何识别变更的文件？
   - 如何更新已存储的入口数据？

2. **批量任务检测**
   - 如何检测 XML 配置的批量任务？
   - 如何解析 Spring Batch、Quartz 配置文件？

3. **入口去重**
   - 同一个方法可能被多个注解标记（如 @RestController + @RequestMapping）
   - 如何合并重复的入口？

4. **业务功能分析**
   - 如何提高 LLM 分析的准确率？
   - 如何处理 LLM 分析失败的情况？
   - 如何缓存分析结果？

5. **向量库存储**
   - 如何设计入口的向量 Schema？
   - 如何生成入口的 embedding？
   - 如何支持 BGE 召回 + 重排？

## 下一步

- [ ] 实现基础的 HTTP 入口检测
- [ ] 实现 MQ、RPC、定时任务入口检测
- [ ] 实现启发式类名匹配
- [ ] 集成 LLM 业务功能分析
- [ ] 实现线程池配置检测
- [ ] 实现线程池配置问题分析
- [x] 设计向量库存储格式（第 11 节）
- [x] 编写单元测试
- [ ] 性能优化和增量扫描

---

## ✅ 实现完成 (2026-01-30)

### 实现文件

- **位置**: `src/main/kotlin/com/smancode/smanagent/analysis/entry/ApiEntryScanner.kt`
- **测试**: 所有测试通过 (196 tests passed)

### 实现功能

1. ✅ **HTTP 入口扫描** - 识别 @RestController、@RequestMapping
2. ✅ **方法提取** - 提取 HTTP 方法和路径
3. ✅ **参数解析** - 解析 @PathVariable、@RequestParam 等参数
4. ✅ **返回类型** - 提取方法返回类型

### 验证状态

```bash
./gradlew test
# BUILD SUCCESSFUL - 196 tests completed
```
