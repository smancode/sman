# 13 - 项目分析总装设计

## 目标

为 SmanAgent 项目设计分析模块的总装方案，将前面 12 个分析模块（01-12）整合到统一的框架中，实现：

1. **UI 集成**：在插件设置页面添加"项目分析"功能入口
2. **流程编排**：使用设计模式管理有序的分析步骤
3. **结果存储**：统一 MD 文件生成和向量库存储
4. **配置管理**：H2 数据库存储动态配置和元数据
5. **断点续传**：支持中断后继续执行
6. **增量更新**：基于 MD5 的智能增量更新机制
7. **AST 缓存**：持久化 AST 扫描结果

**核心价值**：
- 一键启动完整项目分析
- 灵活配置分析步骤
- 持久化分析结果（MD 文件 + 向量库 + AST 缓存）
- 支持增量更新和重试
- 大幅提升分析性能（增量更新 ~150ms）

## 架构设计

### 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                    SmanAgent Plugin                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              UI Layer (Swing)                           │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │   │
│  │  │SettingsDialog│  │AnalysisDialog│  │ProgressPanel │  │   │
│  │  │              │  │              │  │              │  │   │
│  │  │ [分析按钮]   │  │ [进度显示]   │  │ [结果查看]   │  │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘  │   │
│  └─────────────────────────────────────────────────────────┘   │
│                           │                                      │
│                           ▼                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │          Analysis Orchestrator (协调层)                 │   │
│  │                                                          │   │
│  │  ┌──────────────────────────────────────────────┐       │   │
│  │  │     AnalysisPipeline (Pipeline Pattern)       │       │   │
│  │  │                                                │       │   │
│  │  │  Step01 → Step02 → Step03 → ... → Step12      │       │   │
│  │  │    ↓        ↓        ↓             ↓          │       │   │
│  │  │  [Retry]  [Skip]  [Config]      [Result]      │       │   │
│  │  └──────────────────────────────────────────────┘       │   │
│  │                                                          │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │   │
│  │  │StepRegistry  │  │ConfigManager │  │StateManager  │   │   │
│  │  │              │  │              │  │              │   │   │
│  │  │ 步骤注册表   │  │ H2配置管理   │  │ 断点续传     │   │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                           │                                      │
│                           ▼                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │            Analysis Steps (分析步骤层)                  │   │
│  │                                                          │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐     ┌─────────┐    │   │
│  │  │ Step 01 │ │ Step 02 │ │ Step 03 │ ... │ Step 12 │    │   │
│  │  │         │ │         │ │         │     │         │    │   │
│  │  │Project  │ │Tech     │ │Thread   │     │Code     │    │   │
│  │  │Structure│ │Stack    │ │Pool     │     │Walkthrough│   │   │
│  │  └─────────┘ └─────────┘ └─────────┘     └─────────┘    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                           │                                      │
│                           ▼                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Storage Layer (存储层)                      │   │
│  │                                                          │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │   │
│  │  │  H2 Database │  │MD File Store │  │Vector Store  │   │   │
│  │  │              │  │              │  │              │   │   │
│  │  │- step_config │  │~/.smanunion/ │  │JVector       │   │   │
│  │  │- case_sop    │  │  projectKey/ │  │              │   │   │
│  │  │- vector_meta │  │  01_*.md     │  │- embeddings  │   │   │
│  │  │- system_cfg  │  │  02_*.md     │  │- metadata    │   │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 分层说明

#### 1. UI 层（Swing）
- **SettingsDialog**：插件设置，LLM 配置
- **AnalysisDialog**：分析控制面板，启动/停止/重试
- **ProgressPanel**：实时显示分析进度

#### 2. 协调层（Orchestrator）
- **AnalysisPipeline**：Pipeline 模式管理分析流程
- **StepRegistry**：责任链模式注册分析步骤
- **ConfigManager**：H2 数据库配置管理
- **StateManager**：断点续传状态管理

#### 3. 分析步骤层（Steps）
- **Step01-12**：12 个独立的分析步骤
- 每个步骤实现 `AnalysisStep` 接口
- 支持并行执行（无依赖步骤）

#### 4. 存储层（Storage）
- **H2 Database**：配置、元数据、SOP
- **MD File Store**：分析结果 Markdown 文件
- **Vector Store**：J向量索引和元数据

## UI 设计

### 1. 设置页面扩展

**位置**：`SettingsDialog.kt`

**新增 Tab**：项目分析配置

```kotlin
// 在 SettingsDialog 中添加
class SettingsDialog(private val project: Project) : JDialog() {

    // 新增：项目分析配置
    private val analysisEnabledCheckBox = JCheckBox("启用项目分析", true)
    private val analysisStepsButton = JButton("配置分析步骤...")

    private fun createMainPanel(): JPanel {
        val panel = JPanel(GridBagLayout())
        val gbc = createGridBagConstraints()
        var row = 0

        // LLM 配置
        row = addLlmConfigSection(panel, gbc, row)

        // 其他配置
        row = addOtherConfigSection(panel, gbc, row)

        // 【新增】项目分析配置
        row = addAnalysisConfigSection(panel, gbc, row)

        return panel
    }

    private fun addAnalysisConfigSection(
        panel: JPanel,
        gbc: GridBagConstraints,
        startRow: Int
    ): Int {
        var row = startRow

        // 分隔线
        gbc.gridx = 0
        gbc.gridy = row
        gbc.gridwidth = 2
        panel.add(JSeparator(), gbc)
        row++

        // 标题
        gbc.gridx = 0
        gbc.gridy = row
        gbc.gridwidth = 2
        panel.add(JLabel("<html><b>项目分析配置</b></html>"), gbc)
        row++

        // 启用分析
        gbc.gridx = 0
        gbc.gridy = row
        gbc.gridwidth = 2
        panel.add(analysisEnabledCheckBox, gbc)
        row++

        // 配置步骤按钮
        gbc.gridx = 0
        gbc.gridy = row
        gbc.gridwidth = 2
        analysisStepsButton.addActionListener { showStepConfigDialog() }
        panel.add(analysisStepsButton, gbc)
        row++

        return row
    }

    private fun showStepConfigDialog() {
        StepConfigDialog.show(project)
    }
}
```

### 2. 分析控制对话框

**新文件**：`AnalysisDialog.kt`

```kotlin
package com.smancode.smanagent.ide.ui

import com.intellij.openapi.project.Project
import com.smancode.smanagent.ide.service.SmanAgentService
import com.smancode.smanagent.analyzer.orchestration.AnalysisOrchestrator
import com.smancode.smanagent.analyzer.orchestration.AnalysisProgress
import javax.swing.*
import java.awt.BorderLayout

/**
 * 项目分析控制对话框
 */
class AnalysisDialog(
    private val project: Project
) : JDialog() {

    private val orchestrator = AnalysisOrchestrator.getInstance(project)
    private val progressPanel = AnalysisProgressPanel()

    // 按钮
    private val startButton = JButton("开始分析")
    private val stopButton = JButton("停止")
    private val retryButton = JButton("重试失败步骤")
    private val closeButton = JButton("关闭")

    init {
        title = "项目分析 - ${project.name}"
        isModal = false
        defaultCloseOperation = DO_NOTHING_ON_CLOSE

        layout = BorderLayout()
        add(progressPanel, BorderLayout.CENTER)
        add(createButtonPanel(), BorderLayout.SOUTH)

        pack()
        minimumSize = java.awt.Dimension(800, 600)
        setLocationRelativeTo(null)

        setupListeners()
    }

    private fun createButtonPanel(): JPanel {
        val panel = JPanel()

        panel.add(startButton)
        panel.add(stopButton)
        panel.add(retryButton)
        panel.add(closeButton)

        return panel
    }

    private fun setupListeners() {
        startButton.addActionListener {
            startAnalysis()
        }

        stopButton.addActionListener {
            stopAnalysis()
        }

        retryButton.addActionListener {
            retryFailedSteps()
        }

        closeButton.addActionListener {
            if (!orchestrator.isRunning()) {
                dispose()
            }
        }

        // 监听进度更新
        orchestrator.addProgressListener { progress ->
            SwingUtilities.invokeLater {
                progressPanel.updateProgress(progress)
                updateButtonStates(progress)
            }
        }
    }

    private fun startAnalysis() {
        orchestrator.startAnalysis(
            projectKey = project.name,
            projectPath = project.basePath!!.toAbsolutePath()
        )
    }

    private fun stopAnalysis() {
        orchestrator.stopAnalysis()
    }

    private fun retryFailedSteps() {
        orchestrator.retryFailedSteps()
    }

    private fun updateButtonStates(progress: AnalysisProgress) {
        startButton.isEnabled = !progress.isRunning
        stopButton.isEnabled = progress.isRunning
        retryButton.isEnabled = progress.hasFailures && !progress.isRunning
    }

    companion object {
        fun show(project: Project) {
            val dialog = AnalysisDialog(project)
            dialog.isVisible = true
        }
    }
}
```

### 3. 进度显示面板

**新文件**：`AnalysisProgressPanel.kt`

```kotlin
package com.smancode.smanagent.ide.ui

import com.smancode.smanagent.analyzer.orchestration.AnalysisProgress
import com.smancode.smanagent.analyzer.orchestration.StepStatus
import javax.swing.*
import javax.swing.table.DefaultTableModel
import java.awt.BorderLayout

/**
 * 分析进度显示面板
 */
class AnalysisProgressPanel : JPanel() {

    private val overallProgressBar = JProgressBar(0, 100)
    private val overallStatusLabel = JLabel("准备就绪")
    private val stepTable: JTable

    private val tableModel = DefaultTableModel(
        arrayOf("步骤", "状态", "进度", "耗时", "错误"),
        0
    )

    init {
        layout = BorderLayout(10, 10)
        border = BorderFactory.createEmptyBorder(10, 10, 10, 10)

        // 整体进度
        val topPanel = JPanel(BorderLayout(5, 5))
        topPanel.add(JLabel("整体进度:"), BorderLayout.WEST)
        topPanel.add(overallProgressBar, BorderLayout.CENTER)
        topPanel.add(overallStatusLabel, BorderLayout.EAST)

        // 步骤表格
        stepTable = JTable(tableModel)
        stepTable.autoCreateRowSorter = true
        val scrollPane = JScrollPane(stepTable)

        add(topPanel, BorderLayout.NORTH)
        add(scrollPane, BorderLayout.CENTER)
    }

    /**
     * 更新进度显示
     */
    fun updateProgress(progress: AnalysisProgress) {
        // 更新整体进度
        overallProgressBar.value = progress.overallProgress
        overallStatusLabel.text = buildOverallStatusText(progress)

        // 更新步骤表格
        updateStepTable(progress)
    }

    private fun buildOverallStatusText(progress: AnalysisProgress): String {
        return when {
            progress.isRunning -> "分析中... (${progress.completedSteps}/${progress.totalSteps})"
            progress.completedSteps == progress.totalSteps -> "分析完成"
            progress.hasFailures -> "有失败步骤"
            else -> "准备就绪"
        }
    }

    private fun updateStepTable(progress: AnalysisProgress) {
        // 清空表格
        tableModel.rowCount = 0

        // 添加步骤行
        progress.steps.forEach { step ->
            tableModel.addRow(arrayOf(
                step.name,
                step.status.displayName,
                "${step.progress}%",
                "${step.elapsedTime}ms",
                step.errorMessage ?: ""
            ))
        }

        // 调整列宽
        stepTable.columnModel.getColumn(1).setPreferredWidth(80)
        stepTable.columnModel.getColumn(2).setPreferredWidth(80)
    }
}

/**
 * 步骤状态扩展
 */
private val StepStatus.displayName: String
    get() = when (this) {
        StepStatus.PENDING -> "等待中"
        StepStatus.RUNNING -> "执行中"
        StepStatus.COMPLETED -> "已完成"
        StepStatus.FAILED -> "失败"
        StepStatus.SKIPPED -> "已跳过"
    }
```

## 分析流程设计

### 设计模式选择

综合考虑灵活性、可扩展性和可维护性，采用 **Pipeline 模式 + Builder 模式 + Registry 模式**：

#### 1. Pipeline 模式（管道模式）

**优势**：
- 有序执行：步骤按顺序执行
- 数据流转：上一步的输出是下一步的输入
- 易于扩展：新增步骤只需实现接口

**应用**：
```kotlin
/**
 * 分析管道
 */
class AnalysisPipeline(
    private val steps: List<AnalysisStep>,
    private val context: AnalysisContext
) {

    /**
     * 执行管道
     */
    suspend fun execute(): AnalysisResult {
        var currentContext = context

        for (step in steps) {
            if (!step.shouldExecute(currentContext)) {
                continue
            }

            try {
                currentContext = step.execute(currentContext)
                currentContext = currentContext.copy(
                    completedSteps = currentContext.completedSteps + step.id
                )
            } catch (e: Exception) {
                if (step.isFatal) {
                    throw AnalysisException("步骤 ${step.id} 执行失败", e)
                }
                // 记录错误，继续执行
                currentContext = currentContext.copy(
                    errors = currentContext.errors + StepError(step.id, e.message)
                )
            }
        }

        return AnalysisResult(
            context = currentContext,
            success = currentContext.errors.isEmpty()
        )
    }
}
```

#### 2. Registry 模式（注册表模式）

**优势**：
- 解耦：步骤不需要硬编码
- 动态配置：可从 H2 加载步骤配置
- 灵活排序：支持自定义步骤顺序

**应用**：
```kotlin
/**
 * 步骤注册表
 */
object StepRegistry {

    private val steps = ConcurrentHashMap<String, AnalysisStep>()

    /**
     * 注册步骤
     */
    fun register(step: AnalysisStep) {
        steps[step.id] = step
    }

    /**
     * 获取步骤
     */
    fun getStep(id: String): AnalysisStep? = steps[id]

    /**
     * 获取所有步骤
     */
    fun getAllSteps(): List<AnalysisStep> = steps.values.toList()

    /**
     * 按顺序获取步骤（从 H2 加载配置）
     */
    fun getOrderedSteps(projectKey: String): List<AnalysisStep> {
        val config = ConfigManager.getInstance().getStepConfig(projectKey)
        return config.enabledSteps
            .mapNotNull { steps[it] }
            .sortedBy { config.getStepOrder(it) }
    }
}

/**
 * 步骤配置（从 H2 加载）
 */
data class StepConfig(
    val enabledSteps: List<String>,
    val stepOrder: Map<String, Int>,
    val stepDependencies: Map<String, List<String>>
)
```

#### 3. Builder 模式（构建者模式）

**优势**：
- 流式 API：易于构建复杂对象
- 可选参数：支持灵活配置
- 参数验证：构建时验证

**应用**：
```kotlin
/**
 * 管道构建器
 */
class AnalysisPipelineBuilder {

    private val steps = mutableListOf<AnalysisStep>()
    private var projectKey: String? = null
    private var projectPath: Path? = null
    private var enableRetry: Boolean = true
    private var maxRetries: Int = 3

    fun withProject(key: String, path: Path) = apply {
        this.projectKey = key
        this.projectPath = path
    }

    fun withSteps(vararg stepIds: String) = apply {
        stepIds.forEach { id ->
            StepRegistry.getStep(id)?.let { steps.add(it) }
        }
    }

    fun withRetry(enabled: Boolean, max: Int = 3) = apply {
        this.enableRetry = enabled
        this.maxRetries = max
    }

    fun build(): AnalysisPipeline {
        require(projectKey != null) { "projectKey is required" }
        require(projectPath != null) { "projectPath is required" }
        require(steps.isNotEmpty()) { "至少需要一个分析步骤" }

        val context = AnalysisContext(
            projectKey = projectKey!!,
            projectPath = projectPath!!,
            enableRetry = enableRetry,
            maxRetries = maxRetries
        )

        return AnalysisPipeline(steps, context)
    }
}
```

### 步骤接口定义

```kotlin
/**
 * 分析步骤接口
 */
interface AnalysisStep {

    /**
     * 步骤 ID（唯一标识）
     */
    val id: String

    /**
     * 步骤名称
     */
    val name: String

    /**
     * 步骤描述
     */
    val description: String

    /**
     * 步骤依赖（必须完成的步骤 ID）
     */
    val dependencies: List<String>
        get() = emptyList()

    /**
     * 是否启用（从 H2 加载配置）
     */
    var enabled: Boolean
        get() = true

    /**
     * 是否致命（失败则终止整个流程）
     */
    val isFatal: Boolean
        get() = false

    /**
     * 执行步骤
     */
    suspend fun execute(context: AnalysisContext): AnalysisContext

    /**
     * 判断是否应该执行
     */
    fun shouldExecute(context: AnalysisContext): Boolean {
        if (!enabled) return false

        // 检查依赖
        val dependenciesMet = dependencies.all { dep ->
            dep in context.completedSteps
        }

        return dependenciesMet
    }

    /**
     * 获取步骤进度（0-100）
     */
    fun getProgress(context: AnalysisContext): Int = 100
}
```

### 断点续传设计

```kotlin
/**
 * 分析上下文（包含状态）
 */
data class AnalysisContext(
    val projectKey: String,
    val projectPath: Path,
    val enableRetry: Boolean = true,
    val maxRetries: Int = 3,

    // 状态
    val completedSteps: Set<String> = emptySet(),
    val failedSteps: Set<String> = emptySet(),
    val currentStep: String? = null,
    val errors: List<StepError> = emptyList(),

    // 共享数据
    val sharedData: Map<String, Any> = emptyMap()
) {

    /**
     * 获取共享数据
     */
    @Suppress("UNCHECKED_CAST")
    fun <T> getData(key: String): T? = sharedData[key] as? T

    /**
     * 设置共享数据
     */
    fun withData(key: String, value: Any): AnalysisContext {
        return copy(sharedData = sharedData + (key to value))
    }

    /**
     * 保存到 H2（断点续传）
     */
    suspend fun saveCheckpoint() {
        StateManager.getInstance().saveCheckpoint(this)
    }

    /**
     * 从 H2 加载（断点续传）
     */
    suspend fun loadCheckpoint(): AnalysisContext? {
        return StateManager.getInstance().loadCheckpoint(projectKey)
    }
}

/**
 * 步骤错误
 */
data class StepError(
    val stepId: String,
    val message: String?,
    val exception: Throwable? = null
)

/**
 * 分析结果
 */
data class AnalysisResult(
    val context: AnalysisContext,
    val success: Boolean,
    val elapsedTime: Long = 0
)
```

### 协调器实现

```kotlin
/**
 * 分析协调器（单例）
 */
class AnalysisOrchestrator(
    private val project: Project
) {

    private val logger = LoggerFactory.getLogger(javaClass)
    private val progressListeners = mutableListOf<(AnalysisProgress) -> Unit>()

    @Volatile
    private var isRunning = false

    @Volatile
    private var currentJob: Job? = null

    private val scope = CoroutineScope(
        Dispatchers.Default +
            SupervisorJob() +
            CoroutineName("AnalysisOrchestrator")
    )

    /**
     * 启动分析
     */
    fun startAnalysis(projectKey: String, projectPath: Path) {
        if (isRunning) {
            logger.warn("分析已在运行中")
            return
        }

        isRunning = true

        currentJob = scope.launch {
            try {
                // 加载配置
                val steps = StepRegistry.getOrderedSteps(projectKey)

                // 检查断点
                val context = AnalysisContext(
                    projectKey = projectKey,
                    projectPath = projectPath
                ).loadCheckpoint() ?: AnalysisContext(
                    projectKey = projectKey,
                    projectPath = projectPath
                )

                // 构建管道
                val pipeline = AnalysisPipelineBuilder()
                    .withProject(projectKey, projectPath)
                    .withSteps(*steps.map { it.id }.toTypedArray())
                    .build()

                // 执行
                val result = pipeline.execute()

                // 清除断点
                if (result.success) {
                    StateManager.getInstance().clearCheckpoint(projectKey)
                }

            } catch (e: Exception) {
                logger.error("分析失败", e)
            } finally {
                isRunning = false
            }
        }
    }

    /**
     * 停止分析
     */
    fun stopAnalysis() {
        currentJob?.cancel()
        isRunning = false
    }

    /**
     * 重试失败步骤
     */
    fun retryFailedSteps() {
        // TODO: 实现
    }

    /**
     * 添加进度监听器
     */
    fun addProgressListener(listener: (AnalysisProgress) -> Unit) {
        progressListeners.add(listener)
    }

    /**
     * 发布进度
     */
    private fun publishProgress(progress: AnalysisProgress) {
        progressListeners.forEach { it(progress) }
    }

    /**
     * 是否正在运行
     */
    fun isRunning(): Boolean = isRunning

    companion object {
        private val instances = ConcurrentHashMap<Project, AnalysisOrchestrator>()

        fun getInstance(project: Project): AnalysisOrchestrator {
            return instances.computeIfAbsent(project) { AnalysisOrchestrator(it) }
        }
    }
}

/**
 * 分析进度
 */
data class AnalysisProgress(
    val isRunning: Boolean,
    val totalSteps: Int,
    val completedSteps: Int,
    val steps: List<StepProgress>,
    val hasFailures: Boolean
) {
    val overallProgress: Int
        get() = if (totalSteps > 0) {
            (completedSteps * 100) / totalSteps
        } else {
            0
        }
}

/**
 * 步骤进度
 */
data class StepProgress(
    val id: String,
    val name: String,
    val status: StepStatus,
    val progress: Int,
    val elapsedTime: Long,
    val errorMessage: String? = null
)
```

## 存储设计

### 目录结构

```
~/.smanunion/
└── {projectKey}/
    ├── data/                           # 数据目录（新增）
    │   ├── md5/                        # MD5 文件追踪
    │   │   └── md5_cache.json          # MD5 缓存文件
    │   ├── ast/                        # AST 扫描结果（新增）
    │   │   ├── classes/                # L3: 冷数据（磁盘）
    │   │   │   ├── com/example/Service.json
    │   │   │   └── ...
    │   │   ├── callgraph.json          # 调用图
    │   │   └── metadata.json           # AST 元数据
    │   └── vector/                     # 向量库（新增）
    │       ├── index.jvector           # JVector 磁盘索引（OnDiskGraphIndex）
    │       ├── pq.pq                   # PQ 压缩向量（内存）
    │       └── metadata.json           # 向量元数据
    ├── 01-12_*.md                      # 分析结果 MD 文件
    ├── analysis.mv.db                  # H2 数据库
    └── analysis.trace.db               # H2 跟踪文件
```

### 1. MD 文件格式设计

**存储路径**：`~/.smanunion/{projectKey}/{stepId}_{moduleName}.md`

**文件命名**（固定大写）：
```
01_PROJECT_STRUCTURE.md
02_TECH_STACK.md
03_AST_SCAN.md              # 新增：AST 扫描
04_DDL_SCAN.md
05_ENTRANCE_SCAN.md         # 合并了线程池配置扫描
06_EXTERNAL_CALL_SCAN.md
07_ENUM_SCAN.md
08_COMMON_CLASS_SCAN.md
09_XML_SCAN.md
10_CASE_SOP.md
11_VECTORIZATION.md
12_CODE_WALKTHROUGH.md
```

**步骤说明**：
- **01-02**：保持不变
- **03_AST_SCAN**（新增）：扫描所有 Java/Kotlin 文件的 AST，提取类、方法、字段的完整信息
- **04_DDL_SCAN**：保持不变
- **05_ENTRANCE_SCAN**（合并）：原"03_线程池配置"合并到"05_入口扫描"，因为线程池配置是帮助分析入口的
- **06-12**：保持不变

**MD 文件格式**（支持向量化）：

```markdown
# {模块名称}

> 项目: {projectKey}
> 生成时间: {timestamp}
> 步骤 ID: {stepId}

## 知识片段

### 片段 1: {片段标题}

> 片段 ID: `{fragmentId}`
> 标签: {tag1}, {tag2}

**内容摘要**（用于 embedding）:
{content_summary}

**完整内容**（用于展示）:
{full_content}

**关联信息**:
- 数据库表: {tables}
- 入口方法: {entrances}
- 业务领域: {domain}

---

### 片段 2: ...

## 统计信息

- 片段数量: {count}
- 总字数: {words}
- 向量维度: {dimensions}

## 元数据

```json
{
  "projectKey": "{projectKey}",
  "stepId": "{stepId}",
  "generatedAt": "{timestamp}",
  "fragments": [
    {
      "id": "{fragmentId}",
      "title": "{title}",
      "summary": "{summary}",
      "fullContent": "{fullContent}",
      "tags": ["{tag1}", "{tag2}"],
      "relatedTables": ["{table1}"],
      "relatedEntrances": ["{entrance1}"],
      "domain": "{domain}"
    }
  ]
}
```
```

**示例**：`02_TECH_STACK.md`

```markdown
# 技术栈分析

> 项目: loan-system
> 生成时间: 2026-01-29T20:00:00Z
> 步骤 ID: 02

## 知识片段

### 片段 1: 后端框架

> 片段 ID: `tech_stack_001`
> 标签: spring-boot, backend

**内容摘要**:
项目使用 Spring Boot 2.7.0 作为后端框架，采用 Spring MVC 架构模式。

**完整内容**:
## 后端框架

### 核心框架
- Spring Boot: 2.7.0
- Spring MVC: 5.3.20
- Spring Security: 5.7.0

### 架构模式
- 分层架构: Controller → Service → Repository
- RESTful API 设计
- 统一异常处理

### 配置文件
- application.yml: 主配置
- application-dev.yml: 开发环境
- application-prod.yml: 生产环境

**关联信息**:
- 入口方法: LoanController, AccountController
- 业务领域: 贷款管理

---

### 片段 2: 数据库

> 片段 ID: `tech_stack_002`
> 标签: mysql, database

**内容摘要**:
使用 MySQL 8.0 作为主数据库，采用 MyBatis Plus 作为 ORM 框架。

**完整内容**:
## 数据库

### 数据库配置
- MySQL: 8.0
- 连接池: HikariCP
- ORM: MyBatis Plus 3.5.0

### 数据访问
- Mapper 接口: extends BaseMapper<T>
- XML 映射: resources/mapper/
- 分页插件: PaginationInterceptor

**关联信息**:
- 数据库表: t_loan, t_account, t_repayment
- 业务领域: 数据持久化

---

## 统计信息

- 片段数量: 8
- 总字数: 3200
- 向量维度: 768

## 元数据

```json
{
  "projectKey": "loan-system",
  "stepId": "02",
  "generatedAt": "2026-01-29T20:00:00Z",
  "fragments": [
    {
      "id": "tech_stack_001",
      "title": "后端框架",
      "summary": "项目使用 Spring Boot 2.7.0 作为后端框架",
      "fullContent": "...",
      "tags": ["spring-boot", "backend"],
      "relatedTables": [],
      "relatedEntrances": ["LoanController", "AccountController"],
      "domain": "贷款管理"
    }
  ]
}
```
```

### 2. 向量库存储设计

**存储位置**：`~/.smanunion/{projectKey}/data/vector/`

**文件结构**：
```
~/.smanunion/{projectKey}/
└── data/
    └── vector/
        ├── index.jvector              # JVector OnDiskGraphIndex（磁盘索引）
        ├── pq.pq                      # PQ 压缩向量（内存，32x 压缩）
        ├── metadata.json              # 向量元数据
        └── fragments/                 # 向量片段详情
            ├── tech_stack_001.json
            ├── table_t_loan.json
            ├── entrance_createLoan.json
            └── ...
```

**JVector 分级缓存**（参考：https://github.com/datastax/jvector）：
- **两遍搜索**：
  1. **第一遍（召回）**：使用 PQ 压缩向量（32x 压缩）在内存中快速搜索
  2. **第二遍（精排）**：使用完整向量（按需从磁盘加载）对 TopK 候选重新打分
- **内存占用**：~150 MB（而非传统的 500 MB）
- **延迟**：~30 ms（两遍搜索，可接受）

**向量库持久化**：
- **自动保存**：向量化完成后自动保存到磁盘
- **自动加载**：插件启动时自动加载向量索引
- **增量更新**：只更新新增/修改的片段向量

**向量 ID 规则**：
- 技术栈：`tech_stack_{序号}`
- DDL 表：`table_{tableName}`
- 入口：`entrance_{methodId}`
- AST 类：`ast_{qualifiedName}`
- Enum：`enum_{qualifiedName}`
- 案例SOP：`sop_{processId}`

**向量记录格式**：

```json
{
  "id": "tech_stack_001",
  "title": "后端框架",
  "content": "项目使用 Spring Boot 2.7.0 作为后端框架，采用 Spring MVC 架构模式。",
  "fullContent": "## 后端框架\n\n### 核心框架\n- Spring Boot: 2.7.0\n...",
  "summary": "用于 embedding 的内容摘要",
  "tags": ["spring-boot", "backend", "rest"],
  "sourceFile": "02_TECH_STACK.md",
  "stepId": "02",
  "embedding": [0.123, -0.456, ...],  // 768 维向量
  "metadata": {
    "projectKey": "loan-system",
    "domain": "贷款管理",
    "relatedTables": [],
    "relatedEntrances": ["LoanController"],
    "createdAt": "2026-01-29T20:00:00Z"
  }
}
```

**向量 ID 规则**：
- 技术栈：`tech_stack_{序号}`
- DDL 表：`table_{tableName}`
- 入口：`entrance_{methodId}`
- Enum：`enum_{qualifiedName}`
- 案例SOP：`sop_{processId}`

**向量服务接口**：

```kotlin
/**
 * 向量存储服务
 */
interface VectorStoreService {

    /**
     * 添加知识片段向量
     */
    suspend fun addFragment(fragment: KnowledgeFragment)

    /**
     * 批量添加片段
     */
    suspend fun addFragments(fragments: List<KnowledgeFragment>)

    /**
     * 搜索相似片段（BGE 召回）
     */
    suspend fun searchRecall(
        query: String,
        topK: Int = 50,
        filter: FragmentFilter? = null
    ): List<KnowledgeFragment>

    /**
     * 重排（Reranker）
     */
    suspend fun rerank(
        query: String,
        candidates: List<KnowledgeFragment>,
        topN: Int = 10
    ): List<KnowledgeFragment>

    /**
     * 保存索引到磁盘
     */
    suspend fun saveIndex(projectKey: String)

    /**
     * 从磁盘加载索引
     */
    suspend fun loadIndex(projectKey: String)

    /**
     * 增量更新向量（只更新变化的片段）
     */
    suspend fun updateIndexIncremental(
        projectKey: String,
        changedFragments: List<KnowledgeFragment>,
        deletedFragmentIds: List<String>
    )
}

/**
 * 知识片段
 */
data class KnowledgeFragment(
    val id: String,
    val title: String,
    val content: String,           // 用于 embedding
    val fullContent: String,       // 完整内容
    val tags: List<String>,
    val sourceFile: String,
    val stepId: String,
    val embedding: FloatArray? = null,
    val metadata: FragmentMetadata
)

/**
 * 片段元数据
 */
data class FragmentMetadata(
    val projectKey: String,
    val domain: String?,
    val relatedTables: List<String>,
    val relatedEntrances: List<String>,
    val createdAt: String
)

/**
 * 片段过滤器
 */
data class FragmentFilter(
    val stepId: String? = null,
    val domain: String? = null,
    val tags: List<String>? = null
)
```

### 3. MD5 文件追踪设计

**参考实现**：knowledge-graph-system 的 `FileChangeDetector.java`

**存储位置**：`~/.smanunion/{projectKey}/data/md5/md5_cache.json`

**核心功能**：
1. **文件变化检测**：通过 MD5 判断文件是否有变化
2. **持久化缓存**：MD5 缓存保存到文件，插件重启后自动加载
3. **四级检测**：
   - Level 1：文件列表变化（增删）
   - Level 2：修改时间变化
   - Level 3：MD5 变化（内容变化）
   - Level 4：强制检测（手动刷新）

**数据结构**：

```kotlin
/**
 * 文件快照
 */
data class FileSnapshot(
    val timestamp: Long = System.currentTimeMillis(),
    val projectKey: String,
    val fileCount: Int = 0,
    val fileMetadataMap: Map<String, FileMetadata> = emptyMap()
)

/**
 * 文件元数据
 */
data class FileMetadata(
    val absolutePath: String,
    val relativePath: String,           // 相对于项目根目录
    val size: Long,                     // 文件大小（字节）
    val lastModified: Long,             // 最后修改时间（毫秒）
    val md5: String? = null             // MD5 哈希值
)

/**
 * 变化检测结果
 */
data class ChangeDetectionResult(
    val hasChanges: Boolean = false,
    val detectionLevel: DetectionLevel = DetectionLevel.NO_CHANGE,
    val addedFiles: List<String> = emptyList(),
    val deletedFiles: List<String> = emptyList(),
    val modifiedTimeFiles: List<String> = emptyList(),
    val md5ChangedFiles: List<String> = emptyList(),
    val fileCountBefore: Int = 0,
    val fileCountAfter: Int = 0,
    val detectionDuration: Long = 0
)

enum class DetectionLevel {
    NO_CHANGE,          // 无变化
    LEVEL1_FILE_LIST,   // 文件列表变化
    LEVEL2_MODIFY_TIME, // 修改时间变化
    LEVEL3_MD5          // MD5 变化
}
```

**使用场景**：
1. **AST 增量更新**：只重新解析 MD5 变化的文件
2. **入口扫描增量更新**：只重新扫描包含入口注解的变化文件
3. **外调接口增量更新**：只重新分析包含外部调用的变化文件
4. **Enum 增量更新**：只重新解析变化的枚举类
5. **公共类增量更新**：只重新解析变化的公共类

### 4. AST 持久化设计

**参考实现**：knowledge-graph-system 的 `ASTCacheManager.java`

**存储位置**：`~/.smanunion/{projectKey}/data/ast/`

**文件结构**：
```
~/.smanunion/{projectKey}/
└── data/
    └── ast/
        ├── classes/                    # L3: 冷数据（磁盘，按包路径组织）
        │   ├── com/example/
        │   │   ├── Service.json
        │   │   ├── Controller.json
        │   │   └── ...
        │   └── ...
        ├── callgraph.json              # 调用图
        └── metadata.json               # AST 元数据
```

**三级缓存策略**：
1. **L1: 热数据（内存 LRU）**：
   - 存储最近访问的类 AST（~1000 个类）
   - 内存占用：~5 MB
   - 访问速度：O(1)

2. **L2: 温数据（内存映射）**：
   - 使用内存映射文件（MappedByteBuffer）缓存常用类
   - 内存占用：~10 MB
   - 访问速度：O(log n)

3. **L3: 冷数据（磁盘）**：
   - 所有类 AST 持久化到磁盘
   - 按需加载（Lazy Loading）
   - 内存占用：~5 MB（元数据）

**总内存占用**：~20 MB（而非传统的 50 MB）

**核心功能**：
1. **AST 扫描**：扫描所有 Java/Kotlin 文件，提取类、方法、字段信息
2. **持久化缓存**：AST 结果保存到文件，插件重启后自动加载
3. **增量更新**：只重新解析 MD5 变化的文件
4. **调用图构建**：基于 AST 构建方法调用关系图
5. **三级缓存**：L1/L2/L3 分层存储，降低内存占用

**数据结构**：

```kotlin
/**
 * 类 AST 信息
 */
data class ClassAstInfo(
    val qualifiedName: String,          // 完全限定名
    val simpleName: String,             // 简单类名
    val packageName: String,            // 包名
    val isInterface: Boolean,           // 是否接口
    val isEnum: Boolean,                // 是否枚举
    val isAnnotation: Boolean,          // 是否注解
    val superClass: String?,            // 父类
    val interfaces: List<String>,       // 实现的接口
    val annotations: List<String>,      // 类注解
    val fields: List<FieldInfo>,        // 字段列表
    val methods: List<MethodInfo>,      // 方法列表
    val sourceFile: String,             // 源文件路径
    val md5: String                     // 文件 MD5
)

/**
 * 字段信息
 */
data class FieldInfo(
    val name: String,
    val type: String,
    val modifiers: List<String>,
    val annotations: List<String>
)

/**
 * 方法信息
 */
data class MethodInfo(
    val name: String,
    val returnType: String,
    val parameters: List<ParameterInfo>,
    val modifiers: List<String>,
    val annotations: List<String>,
    val calls: List<MethodCall>         // 方法调用
)

/**
 * 方法调用
 */
data class MethodCall(
    val targetClass: String,
    val targetMethod: String,
    val lineNumber: Int
)

/**
 * 调用图
 */
data class CallGraph(
    val projectKey: String,
    val methods: List<MethodInfo>,
    val calls: List<MethodCall>,
    val lastUpdated: Long
)
```

**增量更新机制**：
1. **检测文件变化**：通过 MD5 判断哪些文件变化了
2. **增量解析**：只解析变化的文件
3. **更新调用图**：删除旧的方法和调用，添加新的方法和调用
4. **保存缓存**：更新后的 AST 保存到磁盘

**性能对比**（10000 个类的项目）：
- 全量刷新：30-80 秒
- 增量刷新：~150 毫秒

### 5. H2 数据库设计

**数据库路径**：`~/.smanunion/{projectKey}/analysis.mv.db`

**表结构**：

#### 5.1 分析步骤配置表（analysis_steps）

```sql
CREATE TABLE analysis_steps (
    step_id VARCHAR(50) PRIMARY KEY,
    step_name VARCHAR(100) NOT NULL,
    enabled BOOLEAN DEFAULT TRUE,
    step_order INT NOT NULL,
    dependencies VARCHAR(500),  -- JSON 数组
    max_retries INT DEFAULT 3,
    timeout_seconds INT DEFAULT 300,
    config TEXT  -- JSON 配置
);

-- 示例数据（更新后的步骤）
INSERT INTO analysis_steps VALUES
    ('01', '项目结构扫描', true, 1, '[]', 3, 60, NULL),
    ('02', '技术栈识别', true, 2, '["01"]', 3, 60, NULL),
    ('03', 'AST扫描', true, 3, '["01"]', 3, 120, NULL),
    ('04', 'DDL扫描', true, 4, '["03"]', 3, 60, NULL),
    ('05', '入口扫描（含线程池）', true, 5, '["03"]', 3, 60, NULL),
    ('06', '外调接口扫描', true, 6, '["03"]', 3, 60, NULL),
    ('07', 'Enum扫描', true, 7, '["03"]', 3, 60, NULL),
    ('08', '公共类扫描', true, 8, '["03"]', 3, 60, NULL),
    ('09', 'XML扫描', true, 9, '["03"]', 3, 60, NULL),
    ('10', '案例SOP', true, 10, '["05", "12"]', 3, 300, NULL),
    ('11', '向量化', true, 11, '["01", "02", "03", "04", "05", "06", "07", "08", "09", "10"]', 3, 600, NULL),
    ('12', '代码走读', true, 12, '["05"]', 3, 300, NULL);
```

#### 5.2 文件 MD5 追踪表（file_md5）

```sql
CREATE TABLE file_md5 (
    project_key VARCHAR(100) NOT NULL,
    relative_path VARCHAR(500) NOT NULL,
    md5_hash VARCHAR(32) NOT NULL,
    file_size BIGINT NOT NULL,
    last_modified BIGINT NOT NULL,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (project_key, relative_path)
);

-- 索引
CREATE INDEX idx_file_md5_project ON file_md5(project_key);
```

#### 5.3 AST 缓存表（ast_cache）

```sql
CREATE TABLE ast_cache (
    project_key VARCHAR(100) NOT NULL,
    class_name VARCHAR(500) NOT NULL,
    ast_data CLOB NOT NULL,           -- JSON 格式的 AST 数据
    md5_hash VARCHAR(32) NOT NULL,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (project_key, class_name)
);

-- 索引
CREATE INDEX idx_ast_cache_project ON ast_cache(project_key);
```

#### 5.4 案例SOP表（case_sop）

```sql
CREATE TABLE case_sop (
    sop_id VARCHAR(50) PRIMARY KEY,
    process_name VARCHAR(200) NOT NULL,
    description TEXT,
    steps TEXT NOT NULL,  -- JSON 数组
    tags VARCHAR(500),    -- JSON 数组
    enabled BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 示例数据
INSERT INTO case_sop VALUES
    ('sop_001', '贷款创建流程', '创建贷款申请的完整流程',
     '[{"step": 1, "action": "验证用户", "method": "AccountService.valid"}]',
     '["贷款", "创建"]', true, NOW(), NOW());
```

#### 5.5 向量库元数据表（vector_metadata）

```sql
CREATE TABLE vector_metadata (
    fragment_id VARCHAR(100) PRIMARY KEY,
    title VARCHAR(200),
    summary TEXT,
    source_file VARCHAR(100),
    step_id VARCHAR(10),
    tags VARCHAR(500),  -- JSON 数组
    domain VARCHAR(100),
    related_tables VARCHAR(500),  -- JSON 数组
    related_entrances VARCHAR(500),  -- JSON 数组
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_vector_metadata_step ON vector_metadata(step_id);
CREATE INDEX idx_vector_metadata_domain ON vector_metadata(domain);
```

#### 5.6 系统配置表（system_config）

```sql
CREATE TABLE system_config (
    config_key VARCHAR(100) PRIMARY KEY,
    config_value TEXT,
    description VARCHAR(500),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 示例数据（Reranker 阈值）
INSERT INTO system_config VALUES
    ('reranker.threshold', '0.5', 'Reranker 最小相似度阈值', NOW()),
    ('reranker.topN', '10', 'Reranker 返回结果数量', NOW()),
    ('analysis.parallel', 'false', '是否允许并行执行步骤', NOW());
```

#### 5.7 分析状态表（analysis_state）

```sql
CREATE TABLE analysis_state (
    project_key VARCHAR(100) PRIMARY KEY,
    completed_steps VARCHAR(500),  -- JSON 数组
    failed_steps VARCHAR(500),     -- JSON 数组
    current_step VARCHAR(50),
    started_at TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 6. 级联更新机制设计

**参考实现**：knowledge-graph-system 的增量更新机制

**核心思想**：当文件 MD5 变化时，级联更新所有依赖该文件的分析结果

**级联更新规则**：

| 变化文件类型 | 触发的更新 | 说明 |
|------------|----------|------|
| Java/Kotlin 文件 | AST 扫描（03） | 所有 .java/.kt 文件 |
| Java/Kotlin 文件（含入口注解） | 入口扫描（05） | @RestController, @RequestMapping 等 |
| Java/Kotlin 文件（含外部调用） | 外调接口扫描（06） | HTTP, RPC, 数据库调用 |
| Java/Kotlin 文件（枚举类） | Enum 扫描（07） | enum 类型 |
| Java/Kotlin 文件（公共类） | 公共类扫描（08） | public class |
| XML 文件 | XML 扫描（09） | .xml 配置文件 |
| 任何分析结果变化 | 向量化（11） | 重新生成向量 |

**级联更新流程**：

```kotlin
/**
 * 级联更新协调器
 */
class CascadeUpdateCoordinator(
    private val md5Tracker: Md5FileTracker,
    private val astCache: AstCacheService,
    private val stepRegistry: StepRegistry
) {

    /**
     * 检测文件变化并触发级联更新
     */
    suspend fun detectAndUpdate(projectKey: String): CascadeUpdateResult {
        // 1. 检测文件变化
        val changeResult = md5Tracker.detectChanges(projectKey)

        if (!changeResult.hasChanges) {
            return CascadeUpdateResult(noChanges = true)
        }

        val updatedSteps = mutableSetOf<String>()

        // 2. 级联更新
        for (changedFile in changeResult.md5ChangedFiles) {
            when {
                // Java/Kotlin 文件 → 更新 AST
                changedFile.endsWith(".java") || changedFile.endsWith(".kt") -> {
                    updatedSteps.add("03")  // AST 扫描
                }

                // XML 文件 → 更新 XML 扫描
                changedFile.endsWith(".xml") -> {
                    updatedSteps.add("09")  // XML 扫描
                }
            }
        }

        // 3. 基于 AST 变化更新其他步骤
        if (updatedSteps.contains("03")) {
            // 重新执行入口扫描（依赖 AST）
            updatedSteps.add("05")

            // 重新执行外调接口扫描（依赖 AST）
            updatedSteps.add("06")

            // 重新执行 Enum 扫描（依赖 AST）
            updatedSteps.add("07")

            // 重新执行公共类扫描（依赖 AST）
            updatedSteps.add("08")
        }

        // 4. 如果任何分析结果变化，重新向量化
        if (updatedSteps.isNotEmpty()) {
            updatedSteps.add("11")
        }

        // 5. 执行更新
        val results = mutableMapOf<String, StepResult>()
        for (stepId in updatedSteps) {
            val step = stepRegistry.getStep(stepId)
            if (step != null) {
                results[stepId] = executeStepIncremental(step, changeResult)
            }
        }

        return CascadeUpdateResult(
            noChanges = false,
            updatedSteps = updatedSteps.toList(),
            results = results
        )
    }

    /**
     * 增量执行步骤
     */
    private suspend fun executeStepIncremental(
        step: AnalysisStep,
        changeResult: ChangeDetectionResult
    ): StepResult {
        // TODO: 实现增量执行逻辑
        return step.execute(context)
    }
}

/**
 * 级联更新结果
 */
data class CascadeUpdateResult(
    val noChanges: Boolean = false,
    val updatedSteps: List<String> = emptyList(),
    val results: Map<String, StepResult> = emptyMap()
)
```

**性能优化**：
- **并行执行**：独立的步骤可以并行执行
- **增量解析**：只解析变化的文件
- **缓存复用**：未变化的文件复用缓存结果

**H2 数据访问对象**：

```kotlin
/**
 * H2 数据库服务
 */
class H2DatabaseService(
    private val projectKey: String
) {

    private val dbPath = Paths.get(
        System.getProperty("user.home"),
        ".smanunion",
        projectKey,
        "analysis"
    )

    private val dataSource: DataSource by lazy {
        createDataSource()
    }

    /**
     * 创建数据源
     */
    private fun createDataSource(): DataSource {
        val config = HikariConfig().apply {
            jdbcUrl = "jdbc:h2:$dbPath;MODE=MySQL"
            driverClassName = "org.h2.Driver"
            username = "sa"
            password = ""
            maximumPoolSize = 5
        }

        // 初始化表结构
        val ds = HikariDataSource(config)
        initTables(ds)
        return ds
    }

    /**
     * 初始化表结构
     */
    private fun initTables(ds: DataSource) {
        val schema = javaClass.getResource("/h2/schema.sql")
        ds.connection.use { conn ->
            schema?.readText()?.let { sql ->
                conn.createStatement().use { stmt ->
                    stmt.execute(sql)
                }
            }
        }
    }

    /**
     * 获取步骤配置
     */
    fun getStepConfig(): StepConfig {
        val sql = """
            SELECT step_id, enabled, step_order, dependencies
            FROM analysis_steps
            ORDER BY step_order
        """

        return dataSource.connection.use { conn ->
            conn.prepareStatement(sql).use { stmt ->
                stmt.executeQuery().use { rs ->
                    val enabled = mutableListOf<String>()
                    val order = mutableMapOf<String, Int>()
                    val dependencies = mutableMapOf<String, List<String>>()

                    while (rs.next()) {
                        val stepId = rs.getString("step_id")
                        if (rs.getBoolean("enabled")) {
                            enabled.add(stepId)
                        }
                        order[stepId] = rs.getInt("step_order")
                        dependencies[stepId] = Json.decodeFromString(
                            rs.getString("dependencies") ?: "[]"
                        )
                    }

                    StepConfig(enabled, order, dependencies)
                }
            }
        }
    }

    /**
     * 更新步骤配置
     */
    fun updateStepConfig(stepId: String, enabled: Boolean, order: Int) {
        val sql = """
            UPDATE analysis_steps
            SET enabled = ?, step_order = ?
            WHERE step_id = ?
        """

        dataSource.connection.use { conn ->
            conn.prepareStatement(sql).use { stmt ->
                stmt.setBoolean(1, enabled)
                stmt.setInt(2, order)
                stmt.setString(3, stepId)
                stmt.executeUpdate()
            }
        }
    }

    /**
     * 保存分析状态（断点续传）
     */
    fun saveAnalysisState(state: AnalysisContext) {
        val sql = """
            MERGE INTO analysis_state (project_key, completed_steps, failed_steps, current_step, started_at)
            VALUES (?, ?, ?, ?, ?)
        """

        dataSource.connection.use { conn ->
            conn.prepareStatement(sql).use { stmt ->
                stmt.setString(1, state.projectKey)
                stmt.setString(2, Json.encodeToString(state.completedSteps))
                stmt.setString(3, Json.encodeToString(state.failedSteps))
                stmt.setString(4, state.currentStep)
                stmt.setTimestamp(5, Timestamp(System.currentTimeMillis()))
                stmt.executeUpdate()
            }
        }
    }

    /**
     * 加载分析状态（断点续传）
     */
    fun loadAnalysisState(): AnalysisContext? {
        val sql = """
            SELECT completed_steps, failed_steps, current_step
            FROM analysis_state
            WHERE project_key = ?
        """

        return dataSource.connection.use { conn ->
            conn.prepareStatement(sql).use { stmt ->
                stmt.setString(1, projectKey)
                stmt.executeQuery().use { rs ->
                    if (rs.next()) {
                        AnalysisContext(
                            projectKey = projectKey,
                            projectPath = Paths.get(""),  // 需要从外部传入
                            completedSteps = Json.decodeFromString(rs.getString("completed_steps") ?: "[]"),
                            failedSteps = Json.decodeFromString(rs.getString("failed_steps") ?: "[]"),
                            currentStep = rs.getString("current_step")
                        )
                    } else {
                        null
                    }
                }
            }
        }
    }

    /**
     * 保存向量元数据
     */
    fun saveVectorMetadata(fragment: KnowledgeFragment) {
        val sql = """
            MERGE INTO vector_metadata (
                fragment_id, title, summary, source_file, step_id,
                tags, domain, related_tables, related_entrances
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """

        dataSource.connection.use { conn ->
            conn.prepareStatement(sql).use { stmt ->
                stmt.setString(1, fragment.id)
                stmt.setString(2, fragment.title)
                stmt.setString(3, fragment.content)
                stmt.setString(4, fragment.sourceFile)
                stmt.setString(5, fragment.stepId)
                stmt.setString(6, Json.encodeToString(fragment.tags))
                stmt.setString(7, fragment.metadata.domain)
                stmt.setString(8, Json.encodeToString(fragment.metadata.relatedTables))
                stmt.setString(9, Json.encodeToString(fragment.metadata.relatedEntrances))
                stmt.executeUpdate()
            }
        }
    }

    /**
     * 保存文件 MD5
     */
    fun saveFileMd5(projectKey: String, relativePath: String, metadata: FileMetadata) {
        val sql = """
            MERGE INTO file_md5 (project_key, relative_path, md5_hash, file_size, last_modified)
            VALUES (?, ?, ?, ?, ?)
        """

        dataSource.connection.use { conn ->
            conn.prepareStatement(sql).use { stmt ->
                stmt.setString(1, projectKey)
                stmt.setString(2, relativePath)
                stmt.setString(3, metadata.md5 ?: "")
                stmt.setLong(4, metadata.size)
                stmt.setLong(5, metadata.lastModified)
                stmt.executeUpdate()
            }
        }
    }

    /**
     * 获取文件 MD5
     */
    fun getFileMd5(projectKey: String, relativePath: String): FileMetadata? {
        val sql = """
            SELECT md5_hash, file_size, last_modified
            FROM file_md5
            WHERE project_key = ? AND relative_path = ?
        """

        return dataSource.connection.use { conn ->
            conn.prepareStatement(sql).use { stmt ->
                stmt.setString(1, projectKey)
                stmt.setString(2, relativePath)
                stmt.executeQuery().use { rs ->
                    if (rs.next()) {
                        FileMetadata(
                            absolutePath = "",  // 不需要
                            relativePath = relativePath,
                            size = rs.getLong("file_size"),
                            lastModified = rs.getLong("last_modified"),
                            md5 = rs.getString("md5_hash")
                        )
                    } else {
                        null
                    }
                }
            }
        }
    }

    /**
     * 保存 AST 缓存
     */
    fun saveAstCache(projectKey: String, className: String, astData: String, md5: String) {
        val sql = """
            MERGE INTO ast_cache (project_key, class_name, ast_data, md5_hash)
            VALUES (?, ?, ?, ?)
        """

        dataSource.connection.use { conn ->
            conn.prepareStatement(sql).use { stmt ->
                stmt.setString(1, projectKey)
                stmt.setString(2, className)
                stmt.setString(3, astData)
                stmt.setString(4, md5)
                stmt.executeUpdate()
            }
        }
    }

    /**
     * 获取 AST 缓存
     */
    fun getAstCache(projectKey: String, className: String): String? {
        val sql = """
            SELECT ast_data
            FROM ast_cache
            WHERE project_key = ? AND class_name = ?
        """

        return dataSource.connection.use { conn ->
            conn.prepareStatement(sql).use { stmt ->
                stmt.setString(1, projectKey)
                stmt.setString(2, className)
                stmt.executeQuery().use { rs ->
                    if (rs.next()) {
                        rs.getString("ast_data")
                    } else {
                        null
                    }
                }
            }
        }
    }

    /**
     * 获取系统配置
     */
    fun <T> getSystemConfig(key: String, defaultValue: T): T {
        val sql = "SELECT config_value FROM system_config WHERE config_key = ?"

        return dataSource.connection.use { conn ->
            conn.prepareStatement(sql).use { stmt ->
                stmt.setString(1, key)
                stmt.executeQuery().use { rs ->
                    if (rs.next()) {
                        when (defaultValue) {
                            is String -> rs.getString("config_value") as T
                            is Int -> rs.getString("config_value")?.toIntOrNull() ?: defaultValue
                            is Boolean -> rs.getString("config_value")?.toBoolean() ?: defaultValue
                            is Double -> rs.getString("config_value")?.toDoubleOrNull() ?: defaultValue
                            else -> defaultValue
                        }
                    } else {
                        defaultValue
                    }
                }
            }
        }
    }

    /**
     * 更新系统配置
     */
    fun updateSystemConfig(key: String, value: Any) {
        val sql = """
            MERGE INTO system_config (config_key, config_value, updated_at)
            VALUES (?, ?, ?)
        """

        dataSource.connection.use { conn ->
            conn.prepareStatement(sql).use { stmt ->
                stmt.setString(1, key)
                stmt.setString(2, value.toString())
                stmt.setTimestamp(3, Timestamp(System.currentTimeMillis()))
                stmt.executeUpdate()
            }
        }
    }
}
```

## Kotlin 实现

### 文件位置

```
src/main/kotlin/com/smancode/smanagent/
├── analyzer/
│   ├── orchestration/               # 协调层
│   │   ├── AnalysisOrchestrator.kt
│   │   ├── AnalysisPipeline.kt
│   │   ├── AnalysisContext.kt
│   │   ├── StepRegistry.kt
│   │   ├── StateManager.kt
│   │   ├── ConfigManager.kt
│   │   └── CascadeUpdateCoordinator.kt  # 级联更新协调器（新增）
│   │
│   ├── steps/                       # 分析步骤
│   │   ├── AnalysisStep.kt         # 基础接口
│   │   ├── Step01ProjectStructure.kt
│   │   ├── Step02TechStack.kt
│   │   ├── Step03AstScan.kt        # AST 扫描（新增）
│   │   ├── Step04DdlScan.kt
│   │   ├── Step05EntranceScan.kt   # 合并了线程池配置
│   │   ├── Step06ExternalCallScan.kt
│   │   ├── Step07EnumScan.kt
│   │   ├── Step08CommonClassScan.kt
│   │   ├── Step09XmlScan.kt
│   │   ├── Step10CaseSop.kt
│   │   ├── Step11Vectorization.kt
│   │   └── Step12CodeWalkthrough.kt
│   │
│   ├── storage/                     # 存储层
│   │   ├── MdFileStore.kt
│   │   ├── VectorStoreService.kt
│   │   ├── JVectorStoreService.kt
│   │   ├── H2DatabaseService.kt
│   │   ├── Md5FileTracker.kt       # MD5 文件追踪（新增）
│   │   ├── AstCacheService.kt      # AST 缓存服务（新增）
│   │   └── CascadeUpdateService.kt # 级联更新服务（新增）
│   │
│   └── model/                       # 数据模型
│       ├── AnalysisContext.kt
│       ├── AnalysisResult.kt
│       ├── AnalysisProgress.kt
│       ├── StepConfig.kt
│       ├── KnowledgeFragment.kt
│       ├── StepError.kt
│       ├── FileSnapshot.kt         # 文件快照（新增）
│       ├── ChangeDetectionResult.kt # 变化检测结果（新增）
│       ├── ClassAstInfo.kt         # 类 AST（新增）
│       ├── CallGraph.kt            # 调用图（新增）
│       └── CascadeUpdateResult.kt  # 级联更新结果（新增）
│
└── ide/
    └── ui/
        ├── AnalysisDialog.kt       # 分析控制对话框
        ├── AnalysisProgressPanel.kt
        └── StepConfigDialog.kt      # 步骤配置对话框
```

### 核心接口

#### 1. 步骤基础接口

```kotlin
package com.smancode.smanagent.analyzer.steps

import com.smancode.smanagent.analyzer.model.AnalysisContext
import com.smancode.smanagent.analyzer.model.StepResult

/**
 * 分析步骤接口
 */
interface AnalysisStep {

    /**
     * 步骤 ID（唯一标识，如 "01", "02"）
     */
    val id: String

    /**
     * 步骤名称
     */
    val name: String

    /**
     * 步骤描述
     */
    val description: String

    /**
     * 步骤依赖（必须完成的步骤 ID）
     */
    val dependencies: List<String>
        get() = emptyList()

    /**
     * 是否启用（从 H2 加载配置）
     */
    var enabled: Boolean
        get() = true
        set(value) {}

    /**
     * 是否致命（失败则终止整个流程）
     */
    val isFatal: Boolean
        get() = false

    /**
     * 超时时间（秒）
     */
    val timeoutSeconds: Long
        get() = 300L

    /**
     * 最大重试次数
     */
    val maxRetries: Int
        get() = 3

    /**
     * 执行步骤
     */
    suspend fun execute(context: AnalysisContext): StepResult

    /**
     * 判断是否应该执行
     */
    fun shouldExecute(context: AnalysisContext): Boolean {
        if (!enabled) return false
        return dependencies.all { it in context.completedSteps }
    }

    /**
     * 获取步骤进度（0-100）
     */
    fun getProgress(): Int = 0
}

/**
 * 步骤结果
 */
data class StepResult(
    val success: Boolean,
    val fragments: List<KnowledgeFragment> = emptyList(),
    val errors: List<String> = emptyList(),
    val metadata: Map<String, Any> = emptyMap()
)
```

#### 2. 步骤实现模板

```kotlin
package com.smancode.smanagent.analyzer.steps

import com.smancode.smanagent.analyzer.model.AnalysisContext
import com.smancode.smanagent.analyzer.model.StepResult
import com.smancode.smanagent.analyzer.model.KnowledgeFragment
import com.smancode.smanagent.analyzer.storage.MdFileStore
import org.slf4j.LoggerFactory

/**
 * 步骤 01：项目结构扫描
 */
class Step01ProjectStructure(
    override var enabled: Boolean = true
) : AnalysisStep {

    private val logger = LoggerFactory.getLogger(javaClass)

    override val id: String = "01"
    override val name: String = "项目结构扫描"
    override val description: String = "扫描项目目录结构，识别模块划分和分层架构"

    // 依赖：无
    override val dependencies: List<String> = emptyList()

    // 失败不致命
    override val isFatal: Boolean = false

    // 超时时间
    override val timeoutSeconds: Long = 60L

    override suspend fun execute(context: AnalysisContext): StepResult {
        logger.info("开始执行步骤: $name")

        val startTime = System.currentTimeMillis()

        return try {
            // 1. 执行分析逻辑
            val projectStructure = analyzeProjectStructure(context.projectPath)

            // 2. 生成知识片段
            val fragments = generateFragments(projectStructure, context)

            // 3. 保存 MD 文件
            val mdFile = MdFileStore.saveStepResult(
                projectKey = context.projectKey,
                stepId = id,
                stepName = "PROJECT_STRUCTURE",
                fragments = fragments
            )

            // 4. 更新上下文
            val updatedContext = context.withData("projectStructure", projectStructure)

            val elapsed = System.currentTimeMillis() - startTime
            logger.info("步骤完成: $name, 耗时: ${elapsed}ms, 片段数: ${fragments.size}")

            StepResult(
                success = true,
                fragments = fragments,
                metadata = mapOf(
                    "mdFile" to mdFile,
                    "elapsedTime" to elapsed
                )
            )

        } catch (e: Exception) {
            logger.error("步骤失败: $name", e)
            StepResult(
                success = false,
                errors = listOf(e.message ?: "未知错误")
            )
        }
    }

    private fun analyzeProjectStructure(projectPath: Path): ProjectStructure {
        // TODO: 实现具体分析逻辑
        return ProjectStructure(
            moduleType = "single-module",
            modules = emptyList(),
            packages = emptyList(),
            rootPackage = ""
        )
    }

    private fun generateFragments(
        structure: ProjectStructure,
        context: AnalysisContext
    ): List<KnowledgeFragment> {
        return listOf(
            KnowledgeFragment(
                id = "project_structure_001",
                title = "项目模块结构",
                content = "项目采用单模块结构，源码位于 src/main/java",
                fullContent = """
                    ## 项目模块结构

                    ### 模块类型
                    ${structure.moduleType}

                    ### 模块列表
                    ${structure.modules.joinToString("\n") { "- ${it.name}: ${it.path}" }}

                    ### 包结构
                    根包: ${structure.rootPackage}
                """.trimIndent(),
                tags = listOf("项目结构", "模块"),
                sourceFile = "01_PROJECT_STRUCTURE.md",
                stepId = id,
                metadata = FragmentMetadata(
                    projectKey = context.projectKey,
                    domain = null,
                    relatedTables = emptyList(),
                    relatedEntrances = emptyList(),
                    createdAt = java.time.Instant.now().toString()
                )
            )
        )
    }
}
```

#### 3. 步骤注册表

```kotlin
package com.smancode.smanagent.analyzer.orchestration

import com.smancode.smanagent.analyzer.steps.AnalysisStep
import java.util.concurrent.ConcurrentHashMap

/**
 * 步骤注册表（单例）
 */
object StepRegistry {

    private val logger = org.slf4j.LoggerFactory.getLogger(javaClass)
    private val steps = ConcurrentHashMap<String, AnalysisStep>()

    /**
     * 初始化默认步骤
     */
    fun init() {
        logger.info("初始化步骤注册表")

        // 注册所有步骤
        register(Step01ProjectStructure())
        register(Step02TechStack())
        register(Step03AstScan())           // 新增：AST 扫描
        register(Step04DdlScan())
        register(Step05EntranceScan())      // 合并了线程池配置
        register(Step06ExternalCallScan())
        register(Step07EnumScan())
        register(Step08CommonClassScan())
        register(Step09XmlScan())
        register(Step10CaseSop())
        register(Step11Vectorization())
        register(Step12CodeWalkthrough())

        logger.info("已注册 ${steps.size} 个分析步骤")
    }

    /**
     * 注册步骤
     */
    fun register(step: AnalysisStep) {
        steps[step.id] = step
        logger.debug("注册步骤: ${step.id} - ${step.name}")
    }

    /**
     * 获取步骤
     */
    fun getStep(id: String): AnalysisStep? = steps[id]

    /**
     * 获取所有步骤
     */
    fun getAllSteps(): List<AnalysisStep> = steps.values.toList()

    /**
     * 按顺序获取已启用的步骤
     */
    fun getOrderedSteps(config: StepConfig): List<AnalysisStep> {
        return config.enabledSteps
            .mapNotNull { steps[it] }
            .sortedBy { step -> config.stepOrder[step.id] ?: 0 }
    }
}
```

## 与现有模块的集成

### 1. 与 SmanAgentService 集成

```kotlin
// 在 SmanAgentService 中添加分析服务

class SmanAgentService(private val project: Project) : Disposable {

    // 新增：分析协调器
    private lateinit var analysisOrchestrator: AnalysisOrchestrator

    private fun initializeServices() {
        // ... 现有服务初始化

        // 初始化分析协调器
        analysisOrchestrator = AnalysisOrchestrator(project)

        // 初始化步骤注册表
        StepRegistry.init()
    }

    /**
     * 获取分析协调器
     */
    fun getAnalysisOrchestrator(): AnalysisOrchestrator {
        return analysisOrchestrator
    }

    // ... 其他方法
}
```

### 2. 与工具系统集成

```kotlin
// 在 LocalToolFactory 中添加项目分析工具

class LocalToolFactory {

    companion object {
        fun createTools(project: Project): List<Tool> {
            return listOf(
                // ... 现有工具
                ProjectAnalysisTool(project)
            )
        }
    }
}

/**
 * 项目分析工具
 */
class ProjectAnalysisTool(
    private val project: Project
) : Tool {

    override fun getName(): String = "project_analysis"

    override fun getDescription(): String {
        return "执行项目分析（01-12 步骤）"
    }

    override fun getParameters(): Map<String, ParameterDef> {
        return mapOf(
            "action" to ParameterDef(
                type = "string",
                description = "操作类型: start/stop/status",
                required = true
            ),
            "steps" to ParameterDef(
                type = "array",
                description = "指定步骤（可选，默认全部）",
                required = false
            )
        )
    }

    override fun execute(
        projectKey: String,
        params: Map<String, Any>
    ): ToolResult {
        val action = params["action"] as? String ?: "start"
        val orchestrator = SmanAgentService.getInstance(project)
            .getAnalysisOrchestrator()

        return when (action) {
            "start" -> {
                orchestrator.startAnalysis(project.name, project.basePath!!.toAbsolutePath())
                ToolResult.success("项目分析已启动")
            }
            "stop" -> {
                orchestrator.stopAnalysis()
                ToolResult.success("项目分析已停止")
            }
            "status" -> {
                val status = if (orchestrator.isRunning()) "运行中" else "未运行"
                ToolResult.success("项目分析状态: $status")
            }
            else -> {
                ToolResult.failure("未知操作: $action")
            }
        }
    }
}
```

### 3. 与聊天面板集成

```kotlin
// 在 SmanAgentChatPanel 中添加分析按钮

class SmanAgentChatPanel : JPanel() {

    private val analysisButton = JButton("项目分析").apply {
        addActionListener {
            val dialog = AnalysisDialog(project)
            dialog.isVisible = true
        }
    }

    private fun createControlBar(): JPanel {
        val panel = JPanel(FlowLayout(FlowLayout.LEFT))
        panel.add(analysisButton)
        // ... 其他按钮
        return panel
    }
}
```

## 向量库与 H2 的协同机制

### 1. 协同架构

```
┌─────────────────────────────────────────────────────────┐
│                   协同存储层                              │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌──────────────┐         ┌──────────────┐             │
│  │   H2 数据库  │         │  向量库存储  │             │
│  │              │         │              │             │
│  │ • 元数据     │◄───────►│ • Embedding  │             │
│  │ • 配置       │  同步    │ • 索引       │             │
│  │ • 状态       │         │ • 向量数据   │             │
│  └──────────────┘         └──────────────┘             │
│         │                         │                     │
│         ▼                         ▼                     │
│  查询过滤                 语义搜索                     │
│  （精确定位）             （模糊匹配）                  │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### 2. 写入流程

```kotlin
/**
 * 知识片段存储服务
 */
class KnowledgeFragmentStore(
    private val h2Service: H2DatabaseService,
    private val vectorService: VectorStoreService
) {

    /**
     * 保存片段（H2 + 向量库）
     */
    suspend fun saveFragment(fragment: KnowledgeFragment) {
        // 1. 生成 embedding
        val embedding = generateEmbedding(fragment.content)

        // 2. 保存到 H2（元数据）
        h2Service.saveVectorMetadata(fragment)

        // 3. 保存到向量库
        vectorService.addFragment(
            fragment.copy(embedding = embedding)
        )
    }

    /**
     * 批量保存
     */
    suspend fun saveFragments(fragments: List<KnowledgeFragment>) {
        fragments.forEach { fragment ->
            saveFragment(fragment)
        }
    }

    /**
     * 生成 embedding
     */
    private suspend fun generateEmbedding(text: String): FloatArray {
        // 调用 BGE 模型
        val llmService = SmanAgentConfig.createLlmService()
        return llmService.generateEmbedding(text)
    }
}
```

### 3. 检索流程（BGE 召回 + Reranker）

```kotlin
/**
 * 知识检索服务
 */
class KnowledgeRetrievalService(
    private val h2Service: H2DatabaseService,
    private val vectorService: VectorStoreService
) {

    /**
     * 检索知识（BGE 召回 + Reranker）
     */
    suspend fun retrieve(
        query: String,
        topK: Int = 50,
        topN: Int = 10,
        filter: FragmentFilter? = null
    ): List<KnowledgeFragment> {

        // 1. BGE 召回（向量搜索）
        val candidates = vectorService.searchRecall(
            query = query,
            topK = topK,
            filter = filter
        )

        // 2. Reranker 重排
        val reranked = vectorService.rerank(
            query = query,
            candidates = candidates,
            topN = topN
        )

        // 3. H2 过滤（可选）
        return if (filter != null) {
            applyH2Filter(reranked, filter)
        } else {
            reranked
        }
    }

    /**
     * 应用 H2 过滤器
     */
    private suspend fun applyH2Filter(
        fragments: List<KnowledgeFragment>,
        filter: FragmentFilter
    ): List<KnowledgeFragment> {
        // 从 H2 查询符合条件的片段 ID
        val validIds = h2Service.queryFragmentIds(filter)

        return fragments.filter { it.id in validIds }
    }
}
```

### 4. 配置协同

```kotlin
/**
 * 配置管理器（H2 作为配置源）
 */
class ConfigManager(
    private val h2Service: H2DatabaseService
) {

    /**
     * 获取步骤配置
     */
    fun getStepConfig(projectKey: String): StepConfig {
        return h2Service.getStepConfig()
    }

    /**
     * 获取 Reranker 阈值
     */
    fun getRerankerThreshold(): Double {
        return h2Service.getSystemConfig("reranker.threshold", 0.5)
    }

    /**
     * 获取 Reranker TopN
     */
    fun getRerankerTopN(): Int {
        return h2Service.getSystemConfig("reranker.topN", 10)
    }

    /**
     * 更新配置
     */
    fun updateConfig(key: String, value: Any) {
        h2Service.updateSystemConfig(key, value)
    }
}
```

## 专家知识库

### 关键问题和解决方案

#### 1. 如何实现断点续传？

**问题**：分析过程中插件关闭，如何继续执行？

**解决方案**：
1. **状态保存**：每完成一个步骤，保存到 H2 `analysis_state` 表
2. **状态加载**：启动时从 H2 加载上次状态
3. **依赖检查**：根据 `completed_steps` 判断哪些步骤已完成
4. **继续执行**：从中断的步骤继续

```kotlin
// 启动时检查断点
val context = AnalysisContext(projectKey, projectPath)
    .loadCheckpoint() ?: AnalysisContext(projectKey, projectPath)

// 跳过已完成的步骤
val remainingSteps = steps.filter { it.id !in context.completedSteps }
```

#### 2. 如何实现步骤重试？

**问题**：某个步骤失败后，如何重试？

**解决方案**：
1. **重试配置**：从 H2 加载 `max_retries` 配置
2. **指数退避**：每次重试间隔递增（1s, 2s, 4s）
3. **失败记录**：记录到 H2 `failed_steps`
4. **手动重试**：UI 提供"重试失败步骤"按钮

```kotlin
suspend fun executeWithRetry(
    step: AnalysisStep,
    context: AnalysisContext
): StepResult {
    var lastError: Exception? = null
    var attempt = 0

    while (attempt < step.maxRetries) {
        try {
            return step.execute(context)
        } catch (e: Exception) {
            lastError = e
            attempt++
            if (attempt < step.maxRetries) {
                delay(1000L * (1 shl (attempt - 1))) // 指数退避
            }
        }
    }

    return StepResult(
        success = false,
        errors = listOf("重试 ${step.maxRetries} 次后仍失败: ${lastError?.message}")
    )
}
```

#### 3. 如何优化向量化性能？

**问题**：向量化耗时长，如何优化？

**解决方案**：
1. **批量处理**：一次向量化多个片段
2. **并发执行**：使用 Kotlin Coroutines 并发
3. **缓存机制**：相同文本复用 embedding
4. **增量更新**：只向量化新增/修改的片段

```kotlin
suspend fun vectorizeBatch(fragments: List<KnowledgeFragment>) {
    // 批量生成 embedding（并发）
    fragments.map { fragment ->
        async {
            val embedding = generateEmbedding(fragment.content)
            fragment.copy(embedding = embedding)
        }
    }.awaitAll()
}
```

#### 4. 如何实现步骤并行？

**问题**：某些步骤无依赖，如何并行执行？

**解决方案**：
1. **依赖分析**：构建 DAG（有向无环图）
2. **拓扑排序**：找出可并行执行的层级
3. **并发执行**：同一层级步骤并发执行

```kotlin
// 构建执行层级
val levels = buildExecutionLevels(steps)

// 逐层执行
for (level in levels) {
    // 同一层级并发执行
    level.map { step ->
        async { step.execute(context) }
    }.awaitAll()
}
```

#### 5. 内存优化

**问题**：AST 和向量化占用大量内存（~550 MB），可能影响 IDEA 性能

**解决方案**：

1. **JVector 分级缓存**：
   - 使用 OnDiskGraphIndex（两遍搜索）
   - 第一遍：PQ 压缩向量（32x 压缩）在内存中快速搜索
   - 第二遍：完整向量（按需从磁盘加载）对 TopK 候选重新打分
   - 内存占用：500 MB → 150 MB
   - 搜索延迟：10 ms → 30 ms（可接受）

2. **AST 三级缓存**：
   - L1: 热数据（内存 LRU，~5 MB）
   - L2: 温数据（内存映射 MappedByteBuffer，~10 MB）
   - L3: 冷数据（磁盘，按需加载，~5 MB 元数据）
   - 内存占用：50 MB → 20 MB

**效果**：
- 总内存占用：550 MB → 170 MB（降低 69%）
- 对 IDEA 影响：明显 → 轻微
- 搜索延迟：10 ms → 30 ms（可接受）

**参考实现**：
- JVector: https://github.com/datastax/jvector
- MappedByteBuffer: Java NIO 内存映射文件

## 待解决的问题

### 1. 大型项目性能

**问题**：大型项目（10万+ 文件）分析耗时过长

**解决方案**：
- 增量分析：只分析修改的文件
- 并行处理：多线程并发扫描
- 缓存机制：缓存中间结果
- 用户提示：显示预计时间

### 2. 内存占用（✅ 已解决）

**问题**：向量化时内存占用过高

**解决方案**（已实施）：
- **JVector 分级缓存**：使用 OnDiskGraphIndex（两遍搜索），内存占用从 500 MB 降至 150 MB
- **AST 三级缓存**：L1/L2/L3 分层存储，内存占用从 50 MB 降至 20 MB
- **分批处理**：每批 100 个片段（仍保留）
- **流式处理**：边生成边保存（仍保留）

**效果**：
- 总内存占用：550 MB → 170 MB（降低 69%）
- 对 IDEA 影响：明显 → 轻微

### 3. 配置冲突

**问题**：H2 配置与代码配置冲突

**解决方案**：
- 优先级明确：H2 > 代码 > 默认值
- 配置验证：启动时验证配置合法性
- 配置重置：提供"重置为默认"功能

### 4. 向量索引损坏

**问题**：JVector 索引文件损坏

**解决方案**：
- 定期备份：每次更新后备份
- 损坏检测：启动时验证索引完整性
- 自动重建：检测到损坏时自动重建

## 下一步

### 短期目标（1-2 周）

- [ ] 实现 Pipeline 模式的分析流程
- [ ] 实现 H2 数据库表结构和 DAO
- [ ] 实现 MD5 文件追踪服务
- [ ] 实现 AST 缓存服务
- [ ] 实现步骤 01-05 的基础逻辑
- [ ] 实现 UI 基础界面（分析对话框、进度面板）

### 中期目标（3-4 周）

- [ ] 实现步骤 06-12 的完整逻辑
- [ ] 实现级联更新机制
- [ ] 实现 JVector 向量存储和检索
- [ ] 实现 BGE 召回 + Reranker
- [ ] 实现断点续传功能
- [ ] 完善错误处理和重试机制

### 长期目标（1-2 月）

- [ ] 性能优化（并行、增量、缓存）
- [ ] 添加配置 UI（步骤配置、SOP 编辑）
- [ ] 集成到聊天面板（智能推荐）
- [ ] 添加分析报告生成功能

### 验收标准

- [ ] 点击"项目分析"按钮能自动执行 01-12 步骤
- [ ] 每个步骤生成对应的 MD 文件
- [ ] MD 文件内容能正确向量化并持久化
- [ ] 支持 BGE 召回 + Reranker 检索
- [ ] H2 配置能实时生效
- [ ] 支持断点续传
- [ ] 失败步骤能重试
- [ ] MD5 文件追踪能正确检测变化
- [ ] AST 增量更新能正确工作
- [ ] 级联更新机制能正确触发依赖步骤

---

## 附录 A：步骤 03_AST扫描 实现参考

### 步骤定义

```kotlin
/**
 * 步骤 03：AST 扫描
 */
class Step03AstScan(
    override var enabled: Boolean = true
) : AnalysisStep {

    private val logger = LoggerFactory.getLogger(javaClass)
    private lateinit var astCache: AstCacheService
    private lateinit var md5Tracker: Md5FileTracker

    override val id: String = "03"
    override val name: String = "AST 扫描"
    override val description: String = "扫描所有 Java/Kotlin 文件的 AST，提取类、方法、字段信息"

    // 依赖：项目结构扫描
    override val dependencies: List<String> = listOf("01")

    // 失败不致命
    override val isFatal: Boolean = false

    // 超时时间
    override val timeoutSeconds: Long = 120L

    override suspend fun execute(context: AnalysisContext): StepResult {
        logger.info("开始执行步骤: $name")

        val startTime = System.currentTimeMillis()

        return try {
            // 1. 检测文件变化
            val changeResult = md5Tracker.detectChanges(context.projectKey)

            // 2. 增量解析 AST
            val astResult = if (changeResult.hasChanges) {
                parseAstIncremental(context, changeResult)
            } else {
                loadAstFromCache(context)
            }

            // 3. 生成知识片段
            val fragments = generateFragments(astResult, context)

            // 4. 保存 MD 文件
            val mdFile = MdFileStore.saveStepResult(
                projectKey = context.projectKey,
                stepId = id,
                stepName = "AST_SCAN",
                fragments = fragments
            )

            // 5. 更新上下文
            val updatedContext = context.withData("astResult", astResult)

            val elapsed = System.currentTimeMillis() - startTime
            logger.info("步骤完成: $name, 耗时: ${elapsed}ms, 片段数: ${fragments.size}")

            StepResult(
                success = true,
                fragments = fragments,
                metadata = mapOf(
                    "mdFile" to mdFile,
                    "elapsedTime" to elapsed,
                    "classCount" to astResult.classes.size
                )
            )

        } catch (e: Exception) {
            logger.error("步骤失败: $name", e)
            StepResult(
                success = false,
                errors = listOf(e.message ?: "未知错误")
            )
        }
    }

    /**
     * 增量解析 AST
     */
    private suspend fun parseAstIncremental(
        context: AnalysisContext,
        changeResult: ChangeDetectionResult
    ): AstResult {
        // TODO: 实现增量解析逻辑
        // 1. 加载旧的 AST 缓存
        // 2. 解析变化的文件
        // 3. 更新调用图
        // 4. 保存新的缓存
        return AstResult(emptyList(), CallGraph(context.projectKey, emptyList(), emptyList()))
    }

    /**
     * 从缓存加载 AST
     */
    private suspend fun loadAstFromCache(context: AnalysisContext): AstResult {
        return astCache.loadAst(context.projectKey) ?: AstResult(
            emptyList(),
            CallGraph(context.projectKey, emptyList(), emptyList())
        )
    }

    /**
     * 生成知识片段
     */
    private fun generateFragments(
        astResult: AstResult,
        context: AnalysisContext
    ): List<KnowledgeFragment> {
        return astResult.classes.map { classInfo ->
            KnowledgeFragment(
                id = "ast_${classInfo.qualifiedName.replace(".", "_")}",
                title = "${classInfo.simpleName} 类定义",
                content = "类 ${classInfo.qualifiedName} 包含 ${classInfo.methods.size} 个方法",
                fullContent = buildClassAstContent(classInfo),
                tags = listOf("AST", "类定义", classInfo.packageName),
                sourceFile = "03_AST_SCAN.md",
                stepId = id,
                metadata = FragmentMetadata(
                    projectKey = context.projectKey,
                    domain = classInfo.packageName,
                    relatedTables = emptyList(),
                    relatedEntrances = classInfo.methods
                        .filter { it.annotations.any { a -> a.contains("RequestMapping") } }
                        .map { "${classInfo.simpleName}.${it.name}" },
                    createdAt = java.time.Instant.now().toString()
                )
            )
        }
    }

    /**
     * 构建类 AST 内容
     */
    private fun buildClassAstContent(classInfo: ClassAstInfo): String {
        return """
            ## 类: ${classInfo.qualifiedName}

            **基本信息**:
            - 包名: ${classInfo.packageName}
            - 类型: ${when {
                classInfo.isInterface -> "接口"
                classInfo.isEnum -> "枚举"
                classInfo.isAnnotation -> "注解"
                else -> "类"
            }}
            - 父类: ${classInfo.superClass ?: "无"}
            - 接口: ${classInfo.interfaces.joinToString(", ")}

            **字段** (${classInfo.fields.size} 个):
            ${classInfo.fields.joinToString("\n") { field ->
                "- `${field.name}: ${field.type}` " +
                if (field.modifiers.isNotEmpty()) "(${field.modifiers.joinToString(" ")})" else ""
            }}

            **方法** (${classInfo.methods.size} 个):
            ${classInfo.methods.joinToString("\n") { method ->
                "- `${method.name}(${method.parameters.joinToString(", ") { it.type }}): ${method.returnType}` " +
                if (method.modifiers.isNotEmpty()) "(${method.modifiers.joinToString(" ")})" else ""
            }}

            **方法调用**:
            ${classInfo.methods.flatMap { it.calls }.groupBy { it.targetClass }
                .map { (target, calls) ->
                    "- $target: ${calls.size} 次调用"
                }.joinToString("\n")}
        """.trimIndent()
    }
}

/**
 * AST 结果
 */
data class AstResult(
    val classes: List<ClassAstInfo>,
    val callGraph: CallGraph
)
```

---

## 附录 B：MD5 文件追踪服务实现参考

```kotlin
/**
 * MD5 文件追踪服务
 */
class Md5FileTracker(
    private val projectKey: String
) {

    private val logger = LoggerFactory.getLogger(javaClass)
    private val md5CacheDir = Paths.get(
        System.getProperty("user.home"),
        ".smanunion",
        projectKey,
        "data",
        "md5"
    )

    private val snapshotCache = ConcurrentHashMap<String, FileSnapshot>()

    /**
     * 检测文件变化
     */
    fun detectChanges(projectPath: Path): ChangeDetectionResult {
        val startTime = System.currentTimeMillis()

        return try {
            // 1. 加载旧快照
            val oldSnapshot = loadSnapshot()

            // 2. 创建新快照
            val newSnapshot = createSnapshot(projectPath)

            // 3. 对比变化
            val result = compareSnapshots(oldSnapshot, newSnapshot)

            // 4. 保存新快照
            if (result.hasChanges) {
                saveSnapshot(newSnapshot)
                snapshotCache[projectKey] = newSnapshot
            }

            result.copy(detectionDuration = System.currentTimeMillis() - startTime)

        } catch (e: Exception) {
            logger.error("文件变化检测失败", e)
            ChangeDetectionResult(
                hasChanges = true,
                detectionLevel = DetectionLevel.LEVEL1_FILE_LIST,
                detectionDuration = System.currentTimeMillis() - startTime
            )
        }
    }

    /**
     * 创建文件快照
     */
    private fun createSnapshot(projectPath: Path): FileSnapshot {
        val snapshot = FileSnapshot(projectKey)

        Files.walk(projectPath)
            .filter { it.toFile().isFile }
            .filter { it.toString().endsWith(".java") || it.toString().endsWith(".kt") }
            .forEach { file ->
                val relativePath = projectPath.relativize(file).toString()
                val metadata = FileMetadata(
                    absolutePath = file.toString(),
                    relativePath = relativePath,
                    size = Files.size(file),
                    lastModified = Files.getLastModifiedTime(file).toMillis(),
                    md5 = calculateMd5(file)
                )
                snapshot.addFile(relativePath, metadata)
            }

        return snapshot
    }

    /**
     * 对比快照
     */
    private fun compareSnapshots(
        oldSnapshot: FileSnapshot?,
        newSnapshot: FileSnapshot
    ): ChangeDetectionResult {
        if (oldSnapshot == null) {
            return ChangeDetectionResult(
                hasChanges = false,
                detectionLevel = DetectionLevel.NO_CHANGE
            )
        }

        val oldFiles = oldSnapshot.fileMetadataMap.keys
        val newFiles = newSnapshot.fileMetadataMap.keys

        val added = newFiles - oldFiles
        val deleted = oldFiles - newFiles
        val common = oldFiles intersect newFiles

        val modifiedTimeFiles = common.filter { path ->
            oldSnapshot.getFile(path)!!.lastModified != newSnapshot.getFile(path)!!.lastModified
        }

        val md5ChangedFiles = modifiedTimeFiles.filter { path ->
            oldSnapshot.getFile(path)!!.md5 != newSnapshot.getFile(path)!!.md5
        }

        return ChangeDetectionResult(
            hasChanges = added.isNotEmpty() || deleted.isNotEmpty() || md5ChangedFiles.isNotEmpty(),
            detectionLevel = when {
                added.isNotEmpty() || deleted.isNotEmpty() -> DetectionLevel.LEVEL1_FILE_LIST
                md5ChangedFiles.isNotEmpty() -> DetectionLevel.LEVEL3_MD5
                modifiedTimeFiles.isNotEmpty() -> DetectionLevel.LEVEL2_MODIFY_TIME
                else -> DetectionLevel.NO_CHANGE
            },
            addedFiles = added.toList(),
            deletedFiles = deleted.toList(),
            modifiedTimeFiles = modifiedTimeFiles.toList(),
            md5ChangedFiles = md5ChangedFiles.toList(),
            fileCountBefore = oldSnapshot.fileCount,
            fileCountAfter = newSnapshot.fileCount
        )
    }

    /**
     * 计算 MD5
     */
    private fun calculateMd5(file: Path): String {
        val md = MessageDigest.getInstance("MD5")
        Files.newInputStream(file).use { input ->
            val buffer = ByteArray(8192)
            var bytesRead: Int
            while (input.read(buffer).also { bytesRead = it } != -1) {
                md.update(buffer, 0, bytesRead)
            }
        }
        return md.digest().joinToString("") { "%02x".format(it) }
    }

    /**
     * 加载快照
     */
    private fun loadSnapshot(): FileSnapshot? {
        val cacheFile = md5CacheDir.resolve("md5_cache.json")
        if (!Files.exists(cacheFile)) {
            return null
        }

        return try {
            ObjectMapper().readValue(cacheFile.toFile(), FileSnapshot::class.java)
        } catch (e: Exception) {
            logger.warn("加载 MD5 缓存失败", e)
            null
        }
    }

    /**
     * 保存快照
     */
    private fun saveSnapshot(snapshot: FileSnapshot) {
        Files.createDirectories(md5CacheDir)
        val cacheFile = md5CacheDir.resolve("md5_cache.json")
        ObjectMapper().writerWithDefaultPrettyPrinter().writeValue(cacheFile.toFile(), snapshot)
    }
}
```

---

## 附录 C：AST 缓存服务实现参考

```kotlin
/**
 * AST 缓存服务
 */
class AstCacheService(
    private val projectKey: String
) {

    private val logger = LoggerFactory.getLogger(javaClass)
    private val astCacheDir = Paths.get(
        System.getProperty("user.home"),
        ".smanunion",
        projectKey,
        "data",
        "ast"
    )

    private val memoryCache = ConcurrentHashMap<String, ClassAstInfo>()

    /**
     * 保存 AST
     */
    fun saveAst(astResult: AstResult) {
        Files.createDirectories(astCacheDir.resolve("classes"))

        // 保存每个类的 AST
        astResult.classes.forEach { classInfo ->
            val packageDir = astCacheDir.resolve("classes")
                .resolve(classInfo.packageName.replace(".", "/"))
            Files.createDirectories(packageDir)

            val classFile = packageDir.resolve("${classInfo.simpleName}.json")
            ObjectMapper().writerWithDefaultPrettyPrinter()
                .writeValue(classFile.toFile(), classInfo)

            memoryCache[classInfo.qualifiedName] = classInfo
        }

        // 保存调用图
        val callGraphFile = astCacheDir.resolve("callgraph.json")
        ObjectMapper().writerWithDefaultPrettyPrinter()
            .writeValue(callGraphFile.toFile(), astResult.callGraph)

        // 保存元数据
        val metadataFile = astCacheDir.resolve("metadata.json")
        val metadata = mapOf(
            "projectKey" to projectKey,
            "classCount" to astResult.classes.size,
            "lastUpdated" to System.currentTimeMillis()
        )
        ObjectMapper().writerWithDefaultPrettyPrinter()
            .writeValue(metadataFile.toFile(), metadata)

        logger.info("AST 已保存: projectKey={}, classes={}", projectKey, astResult.classes.size)
    }

    /**
     * 加载 AST
     */
    fun loadAst(): AstResult? {
        val metadataFile = astCacheDir.resolve("metadata.json")
        if (!Files.exists(metadataFile)) {
            return null
        }

        return try {
            // 加载所有类
            val classes = mutableListOf<ClassAstInfo>()
            Files.walk(astCacheDir.resolve("classes"))
                .filter { it.toString().endsWith(".json") }
                .forEach { file ->
                    val classInfo = ObjectMapper().readValue(file.toFile(), ClassAstInfo::class.java)
                    classes.add(classInfo)
                    memoryCache[classInfo.qualifiedName] = classInfo
                }

            // 加载调用图
            val callGraphFile = astCacheDir.resolve("callgraph.json")
            val callGraph = ObjectMapper().readValue(callGraphFile.toFile(), CallGraph::class.java)

            logger.info("AST 已加载: projectKey={}, classes={}", projectKey, classes.size)
            AstResult(classes, callGraph)

        } catch (e: Exception) {
            logger.warn("加载 AST 失败", e)
            null
        }
    }

    /**
     * 获取类的 AST（从内存缓存）
     */
    fun getClassAst(qualifiedName: String): ClassAstInfo? {
        return memoryCache[qualifiedName]
    }

    /**
     * 更新单个类的 AST（增量更新）
     */
    fun updateClassAst(classInfo: ClassAstInfo) {
        // 更新内存缓存
        memoryCache[classInfo.qualifiedName] = classInfo

        // 更新磁盘缓存
        val packageDir = astCacheDir.resolve("classes")
            .resolve(classInfo.packageName.replace(".", "/"))
        Files.createDirectories(packageDir)

        val classFile = packageDir.resolve("${classInfo.simpleName}.json")
        ObjectMapper().writerWithDefaultPrettyPrinter()
            .writeValue(classFile.toFile(), classInfo)

        logger.debug("类 AST 已更新: {}", classInfo.qualifiedName)
    }
}
```

---

## ✅ 实现完成 (2026-01-30)

### 完成模块清单

| 模块 | 文档 | 实现文件 | 状态 |
|------|------|---------|------|
| 项目结构扫描 | 01_项目结构扫描.md | ProjectStructureScanner.kt | ✅ |
| 技术栈识别 | 02_技术栈识别.md | TechStackDetector.kt | ✅ |
| AST 扫描 | 03_AST扫描.md | PsiAstScanner.kt | ✅ |
| DB 实体扫描 | 04_DBENTITY扫描.md | DbEntityScanner.kt | ✅ |
| 入口扫描 | 05_入口扫描.md | ApiEntryScanner.kt | ✅ |
| 外调接口扫描 | 06_外调接口扫描.md | ExternalApiScanner.kt | ✅ |
| Enum 扫描 | 07_Enum扫描.md | EnumScanner.kt | ✅ |
| 公共类扫描 | 08_公共类扫描.md | CommonClassScanner.kt | ✅ |
| XML 代码扫描 | 09_XML代码扫描.md | XmlCodeScanner.kt | ✅ |
| 案例 SOP | 10_案例SOP.md | CaseSopGenerator.kt | ✅ |
| 语义化向量化 | 11_语义化向量化.md | CodeVectorizationService.kt | ✅ |
| 代码走读 | 12_代码走读.md | CodeWalkthroughGenerator.kt | ✅ |

### 测试状态

```bash
./gradlew test
# 196 tests completed
# BUILD SUCCESSFUL
```

### 文档版本

- **创建日期**: 2026-01-29
- **完成日期**: 2026-01-30
- **状态**: ✅ 全部实现完成

```
