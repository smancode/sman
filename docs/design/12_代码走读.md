# 12 - 代码走读

## 目标

为 SmanAgent 项目添加代码走读能力，从入口点开始追踪完整的业务流程，分析调用链、数据流转、业务规则等，生成可读的业务功能描述。结合向量化能力，实现智能代码理解和业务知识提取。

**核心价值**：
- 自动生成业务功能文档
- 理解复杂业务流程
- 发现代码与业务的关系
- 支持跨项目的业务知识迁移

## 参考

- knowledge-graph-system 的 `LLMCodeWalker.java`
- knowledge-graph-system 的 `CodeWalkerIntegrationGuide.md`
- knowledge-graph-system 的 `WalkResultToThickGraphExplained.md`
- knowledge-graph-system 的 `ParameterSemanticEngine.java`

## 核心概念

### 什么是代码走读？

代码走读（Code Walk）是从一个入口点（如 HTTP 接口）开始，沿着调用链追踪代码执行路径，分析每个方法的功能、数据操作、业务规则，最终生成完整的业务流程描述。

**与静态分析的区别**：
- 静态分析：分析代码结构（类、方法、依赖关系）
- 代码走读：分析业务流程（数据如何流转、业务规则如何执行）

**示例**：
```
入口: LoanController.createLoan()
   ↓
调用链:
   1. LoanController.createLoan()
      ↓
   2. LoanService.createLoan()
      ↓
   3. AccountValidService.valid()       # 账户验证
      ↓
   4. RiskCheckService.check()          # 风控检查
      ↓
   5. LoanRepository.save()             # 保存贷款记录
      ↓
   6. InventoryService.decrease()       # 扣减库存

业务流程: 创建贷款 → 验证账户 → 风控检查 → 保存记录 → 扣减库存
```

### 为什么需要代码走读？

1. **业务理解**：快速理解新项目的业务流程
2. **文档生成**：自动生成业务功能文档
3. **代码审查**：发现潜在的业务逻辑问题
4. **知识沉淀**：将隐性知识转化为显式文档

## 核心功能

### 1. 入口分析

**目标**：分析入口的业务功能和上下文

**输入**：入口信息（来自第 5 节入口扫描）

```kotlin
data class EntranceInfo(
    val className: String,
    val methodName: String,
    val methodId: String,
    val entranceType: EntranceType,
    val urlPath: String?,
    val httpMethod: String?,
    val reqDto: String?,
    val rspDto: String?,
    val businessDescription: String?,
    val businessDomain: String?,
    val keywords: List<String>
)
```

**分析内容**：
1. **入口元数据提取**
   - URL 路径、HTTP 方法
   - 请求参数、返回值
   - 所在包、类名

2. **业务功能分析**（LLM）
   - 业务功能描述
   - 业务领域
   - 关键业务概念

3. **入口上下文构建**
   - 项目上下文摘要（来自第 1 节）
   - 技术栈信息（来自第 2 节）
   - 相关 DDL（来自第 4 节）
   - 相关 Enum（来自第 7 节）

**输出**：
```kotlin
data class EntranceAnalysis(
    val entranceInfo: EntranceInfo,
    val businessDescription: String,
    val businessDomain: String,
    val businessConcepts: List<String>,
    val relatedTables: List<String>,       # 操作的数据库表
    val relatedEnums: List<String>,        # 使用的 Enum
    val contextSummary: String             # 项目上下文摘要
)
```

### 2. 调用链追踪

**目标**：从入口开始追踪完整调用链

**策略**：
1. **深度优先遍历**
   - 从入口方法开始
   - 递归调用子方法
   - 记录调用栈

2. **调用深度控制**
   - 最大深度：5 层（可配置）
   - 超过深度则标记为"太深"

3. **循环检测**
   - 记录调用路径
   - 检测循环调用
   - 跳过已访问的方法

4. **过滤规则**
   - 跳过 JDK/SDK 方法
   - 跳过 Getter/Setter
   - 跳过 toString/equals/hashCode

**数据结构**：
```kotlin
/**
 * 调用链帧
 */
data class CallStackFrame(
    val className: String,
    val methodName: String,
    val methodId: String,
    val depth: Int,
    val lineNumber: Int,
    val parameters: List<ParameterInfo>,
    val returnType: String,
    val callees: List<CallStackFrame>,
    val isTooDeep: Boolean = false,
    val isCircular: Boolean = false
)

/**
 * 调用链分析结果
 */
data class CallChainAnalysis(
    val entranceMethodId: String,
    val callStack: List<CallStackFrame>,
    val totalMethods: Int,
    val maxDepth: Int,
    val circularCalls: List<String>,
    val tooDeepMethods: List<String>
)
```

**实现**：
```kotlin
/**
 * 调用链追踪器
 */
class CallChainTracker(
    private val maxDepth: Int = 5,
    private val psiService: PsiService
) {

    private val visited = mutableSetOf<String>()
    private val circular = mutableSetOf<String>()
    private val callPath = mutableListOf<String>()

    /**
     * 追踪调用链
     */
    fun track(entranceMethodId: String): CallChainAnalysis {
        visited.clear()
        circular.clear()
        callPath.clear()

        val (psiClass, psiMethod) = parseMethodId(entranceMethodId)
        val callStack = trackMethod(psiClass, psiMethod, depth = 0)

        return CallChainAnalysis(
            entranceMethodId = entranceMethodId,
            callStack = listOf(callStack),
            totalMethods = visited.size,
            maxDepth = calculateMaxDepth(callStack),
            circularCalls = circular.toList(),
            tooDeepMethods = extractTooDeepMethods(callStack)
        )
    }

    /**
     * 追踪方法
     */
    private fun trackMethod(
        psiClass: PsiClass,
        psiMethod: PsiMethod,
        depth: Int
    ): CallStackFrame {
        val methodId = generateMethodId(psiClass, psiMethod)

        // 检查循环
        if (methodId in callPath) {
            circular.add(methodId)
            return CallStackFrame(
                className = psiClass.qualifiedName ?: "",
                methodName = psiMethod.name,
                methodId = methodId,
                depth = depth,
                lineNumber = psiMethod.navigationElement?.textOffset ?: 0,
                parameters = extractParameters(psiMethod),
                returnType = psiMethod.returnType.canonicalText,
                callees = emptyList(),
                isCircular = true
            )
        }

        // 检查深度
        if (depth > maxDepth) {
            return CallStackFrame(
                className = psiClass.qualifiedName ?: "",
                methodName = psiMethod.name,
                methodId = methodId,
                depth = depth,
                lineNumber = psiMethod.navigationElement?.textOffset ?: 0,
                parameters = extractParameters(psiMethod),
                returnType = psiMethod.returnType.canonicalText,
                callees = emptyList(),
                isTooDeep = true
            )
        }

        // 记录访问
        visited.add(methodId)
        callPath.add(methodId)

        // 提取子方法调用
        val callees = extractMethodCalls(psiMethod).mapNotNull { call ->
            val (calleeClass, calleeMethod) = resolveMethodCall(call) ?: return@mapNotNull null
            trackMethod(calleeClass, calleeMethod, depth + 1)
        }

        // 恢复路径
        callPath.removeLast()

        return CallStackFrame(
            className = psiClass.qualifiedName ?: "",
            methodName = psiMethod.name,
            methodId = methodId,
            depth = depth,
            lineNumber = psiMethod.navigationElement?.textOffset ?: 0,
            parameters = extractParameters(psiMethod),
            returnType = psiMethod.returnType.canonicalText,
            callees = callees,
            isCircular = false,
            isTooDeep = false
        )
    }

    /**
     * 提取方法调用
     */
    private fun extractMethodCalls(psiMethod: PsiMethod): List<PsiMethodCallExpression> {
        val calls = mutableListOf<PsiMethodCallExpression>()

        psiMethod.body?.accept(object : PsiRecursiveElementVisitor() {
            override fun visitMethodCallExpression(expression: PsiMethodCallExpression) {
                calls.add(expression)
                super.visitMethodCallExpression(expression)
            }
        })

        return calls
    }

    /**
     * 解析方法调用
     */
    private fun resolveMethodCall(call: PsiMethodCallExpression): Pair<PsiClass, PsiMethod>? {
        // 解析方法引用
        val methodReference = call.methodExpression
        val methodName = methodReference.referenceName ?: return null

        // 解析类型
        val qualifier = methodReference.qualifierExpression
        val targetType = when (qualifier) {
            is PsiReferenceExpression -> {
                val ref = qualifier.reference?.resolve()
                when (ref) {
                    is PsiField -> ref.type
                    is PsiParameter -> ref.type
                    else -> null
                }
            }
            else -> null
        } ?: return null

        // 解析类
        val psiClass = (targetType as? PsiClassType)?.resolve() ?: return null

        // 查找方法
        val psiMethod = psiClass.findMethodsByName(methodName, false).firstOrNull()
            ?: return null

        return psiClass to psiMethod
    }

    private fun parseMethodId(methodId: String): Pair<PsiClass, PsiMethod> {
        // 解析 methodId: com.example.Service#method(param1, param2)
        val hashIndex = methodId.indexOf('#')
        val classQualifiedName = methodId.substring(0, hashIndex)

        val psiClass = psiService.findClass(classQualifiedName) ?: error("Class not found: $classQualifiedName")
        val methodName = methodId.substring(hashIndex + 1, methodId.indexOf('('))

        val psiMethod = psiClass.findMethodsByName(methodName, false).firstOrNull()
            ?: error("Method not found: $methodName in $classQualifiedName")

        return psiClass to psiMethod
    }

    private fun generateMethodId(psiClass: PsiClass, psiMethod: PsiMethod): String {
        val className = psiClass.qualifiedName ?: ""
        val methodName = psiMethod.name
        val params = psiMethod.parameterList.parameters.joinToString(",") {
            it.type.canonicalText
        }
        return "$className#$methodName($params)"
    }

    private fun extractParameters(psiMethod: PsiMethod): List<ParameterInfo> {
        return psiMethod.parameterList.parameters.map { param ->
            ParameterInfo(
                name = param.name,
                type = param.type.canonicalText
            )
        }
    }

    private fun calculateMaxDepth(frame: CallStackFrame): Int {
        return if (frame.callees.isEmpty()) {
            frame.depth
        } else {
            frame.callees.maxOfOrNull { calculateMaxDepth(it) } ?: frame.depth
        }
    }

    private fun extractTooDeepMethods(frame: CallStackFrame): List<String> {
        val result = mutableListOf<String>()
        if (frame.isTooDeep) {
            result.add(frame.methodId)
        }
        frame.callees.forEach {
            result.addAll(extractTooDeepMethods(it))
        }
        return result
    }
}
```

### 3. 数据流转分析

**目标**：追踪数据在调用链中的流转

**分析内容**：
1. **数据库操作**
   - INSERT/UPDATE/DELETE/SELECT
   - 操作的表名
   - 影响的行数（如果可推断）

2. **外部接口调用**
   - HTTP 请求
   - RPC 调用
   - MQ 消息

3. **数据转换**
   - DTO → Entity 转换
   - MapStruct 映射
   - JSON 序列化

**数据结构**：
```kotlin
/**
 * 数据操作
 */
sealed class DataOperation {
    abstract val tableName: String?
    abstract val operation: String
    abstract val description: String
}

/**
 * 数据库操作
 */
data class DatabaseOperation(
    override val tableName: String,
    override val operation: String, // INSERT, UPDATE, DELETE, SELECT
    val entity: String?,
    val condition: String?,
    override val description: String
) : DataOperation()

/**
 * HTTP 请求
 */
data class HttpCall(
    override val tableName: String?,
    val url: String,
    val httpMethod: String,
    val requestType: String?,
    val responseType: String?,
    override val operation: String = "HTTP_CALL",
    override val description: String
) : DataOperation()

/**
 * RPC 调用
 */
data class RpcCall(
    override val tableName: String?,
    val service: String,
    val method: String,
    val requestType: String?,
    override val operation: String = "RPC_CALL",
    override val description: String
) : DataOperation()

/**
 * MQ 消息
 */
data class MqMessage(
    override val tableName: String?,
    val topic: String,
    val messageType: String?,
    override val operation: String = "MQ_SEND",
    override val description: String
) : DataOperation()

/**
 * 数据流转分析结果
 */
data class DataFlowAnalysis(
    val entranceMethodId: String,
    val operations: List<DataOperation>,
    val tables: Set<String>,
    val externalCalls: List<HttpCall>,
    val rpcCalls: List<RpcCall>,
    val mqMessages: List<MqMessage>
)
```

**实现**：
```kotlin
/**
 * 数据流转分析器
 */
class DataFlowAnalyzer(
    private val ddlScanner: DdlScanner,
    private val psiService: PsiService
) {

    /**
     * 分析数据流转
     */
    fun analyze(callStack: List<CallStackFrame>): DataFlowAnalysis {
        val operations = mutableListOf<DataOperation>()

        callStack.forEach { frame ->
            operations.addAll(analyzeFrame(frame))
        }

        return DataFlowAnalysis(
            entranceMethodId = callStack.firstOrNull()?.methodId ?: "",
            operations = operations,
            tables = operations.filterIsInstance<DatabaseOperation>().map { it.tableName }.toSet(),
            externalCalls = operations.filterIsInstance<HttpCall>(),
            rpcCalls = operations.filterIsInstance<RpcCall>(),
            mqMessages = operations.filterIsInstance<MqMessage>()
        )
    }

    /**
     * 分析帧
     */
    private fun analyzeFrame(frame: CallStackFrame): List<DataOperation> {
        val operations = mutableListOf<DataOperation>()

        // 1. 分析数据库操作
        operations.addAll(analyzeDatabaseOperations(frame))

        // 2. 分析 HTTP 调用
        operations.addAll(analyzeHttpCalls(frame))

        // 3. 分析 RPC 调用
        operations.addAll(analyzeRpcCalls(frame))

        // 4. 分析 MQ 消息
        operations.addAll(analyzeMqMessages(frame))

        return operations
    }

    /**
     * 分析数据库操作
     */
    private fun analyzeDatabaseOperations(frame: CallStackFrame): List<DatabaseOperation> {
        val operations = mutableListOf<DatabaseOperation>()

        // 通过方法名推断操作类型
        val operation = when {
            frame.methodName.startsWith("save") ||
            frame.methodName.startsWith("create") ||
            frame.methodName.startsWith("insert") -> "INSERT"

            frame.methodName.startsWith("update") ||
            frame.methodName.startsWith("modify") -> "UPDATE"

            frame.methodName.startsWith("delete") ||
            frame.methodName.startsWith("remove") -> "DELETE"

            frame.methodName.startsWith("get") ||
            frame.methodName.startsWith("find") ||
            frame.methodName.startsWith("query") ||
            frame.methodName.startsWith("select") ||
            frame.methodName.startsWith("list") -> "SELECT"

            else -> null
        }

        if (operation != null) {
            // 推断表名
            val tableName = inferTableName(frame)

            operations.add(
                DatabaseOperation(
                    tableName = tableName,
                    operation = operation,
                    entity = frame.returnType.takeIf { operation == "SELECT" },
                    condition = null,
                    description = "${operation} ${if (tableName != null) "table $tableName" else ""}"
                )
            )
        }

        return operations
    }

    /**
     * 推断表名
     */
    private fun inferTableName(frame: CallStackFrame): String? {
        // 策略1: 从 Repository 类名推断
        if (frame.className.endsWith("Repository") ||
            frame.className.endsWith("Dao") ||
            frame.className.endsWith("Mapper")) {

            val entityName = frame.className.substringBefore("Repository")
                .substringBefore("Dao")
                .substringBefore("Mapper")
                .substringAfterLast('.')

            // 查找 DDL 中的表名
            val tables = ddlScanner.scanAll()
            return tables.find { it.entityName == entityName }?.tableName
        }

        // 策略2: 从方法参数推断
        val entityType = frame.parameters.firstOrNull()?.type
        if (entityType != null) {
            val tables = ddlScanner.scanAll()
            return tables.find { it.entityName == entityType.substringAfterLast('.') }?.tableName
        }

        return null
    }

    /**
     * 分析 HTTP 调用
     */
    private fun analyzeHttpCalls(frame: CallStackFrame): List<HttpCall> {
        // 检查是否使用了 RestTemplate/WebClient 等
        val hasHttpCall = frame.className.contains("RestTemplate") ||
            frame.className.contains("WebClient") ||
            frame.methodName.contains("request") ||
            frame.methodName.contains("post") ||
            frame.methodName.contains("get")

        if (!hasHttpCall) return emptyList()

        return listOf(
            HttpCall(
                tableName = null,
                url = "推断中...", // 可以从方法调用中提取
                httpMethod = "POST",
                requestType = frame.parameters.firstOrNull()?.type,
                responseType = frame.returnType,
                description = "HTTP 调用"
            )
        )
    }

    /**
     * 分析 RPC 调用
     */
    private fun analyzeRpcCalls(frame: CallStackFrame): List<RpcCall> {
        // 检查是否是 Dubbo/Feign 调用
        val hasRpcCall = frame.className.contains("Service") &&
            !frame.className.contains(projectPackageName(frame.className))

        if (!hasRpcCall) return emptyList()

        return listOf(
            RpcCall(
                tableName = null,
                service = frame.className,
                method = frame.methodName,
                requestType = frame.parameters.firstOrNull()?.type,
                description = "RPC 调用"
            )
        )
    }

    /**
     * 分析 MQ 消息
     */
    private fun analyzeMqMessages(frame: CallStackFrame): List<MqMessage> {
        // 检查是否使用了 KafkaTemplate/RocketMQTemplate
        val hasMqCall = frame.className.contains("KafkaTemplate") ||
            frame.className.contains("RocketMQTemplate") ||
            frame.methodName.contains("send") ||
            frame.methodName.contains("publish")

        if (!hasMqCall) return emptyList()

        return listOf(
            MqMessage(
                tableName = null,
                topic = "推断中...", // 可以从方法参数中提取
                messageType = frame.parameters.firstOrNull()?.type,
                description = "MQ 消息"
            )
        )
    }

    private fun projectPackageName(className: String): String {
        // 提取项目包名（前两级）
        val parts = className.split('.')
        return parts.take(2).joinToString(".")
    }
}
```

### 4. 业务规则提取

**目标**：从代码中提取业务规则

**提取内容**：
1. **参数校验规则**
   - `@NotNull`, `@NotEmpty`, `@Size`
   - `@Min`, `@Max`, `@Pattern`
   - 手动校验逻辑（if 语句）

2. **业务条件判断**
   - if 条件语句
   - 三元表达式
   - 逻辑运算（&&, ||, !）

3. **异常抛出**
   - 业务异常类型
   - 异常消息
   - 抛出条件

**数据结构**：
```kotlin
/**
 * 业务规则
 */
data class BusinessRule(
    val ruleId: String,
    val ruleType: RuleType,
    val description: String,
    val condition: String?,
    val thenAction: String?,
    val elseAction: String?,
    val exceptionThrown: String?,
    val methodName: String,
    val lineNumber: Int
)

/**
 * 规则类型
 */
enum class RuleType {
    VALIDATION,        # 参数校验
    BUSINESS_LOGIC,    # 业务逻辑
    ERROR_HANDLING,    # 错误处理
    STATE_TRANSITION   # 状态转换
}

/**
 * 业务规则分析结果
 */
data class BusinessRuleAnalysis(
    val entranceMethodId: String,
    val rules: List<BusinessRule>,
    val validationRules: List<BusinessRule>,
    val businessLogicRules: List<BusinessRule>,
    val errorHandlingRules: List<BusinessRule>
)
```

**实现**：
```kotlin
/**
 * 业务规则提取器
 */
class BusinessRuleExtractor(
    private val llmService: LlmService
) {

    /**
     * 提取业务规则
     */
    suspend fun extract(callStack: List<CallStackFrame>): BusinessRuleAnalysis {
        val rules = mutableListOf<BusinessRule>()

        callStack.forEach { frame ->
            rules.addAll(extractRulesFromFrame(frame))
        }

        return BusinessRuleAnalysis(
            entranceMethodId = callStack.firstOrNull()?.methodId ?: "",
            rules = rules,
            validationRules = rules.filter { it.ruleType == RuleType.VALIDATION },
            businessLogicRules = rules.filter { it.ruleType == RuleType.BUSINESS_LOGIC },
            errorHandlingRules = rules.filter { it.ruleType == RuleType.ERROR_HANDLING }
        )
    }

    /**
     * 从帧中提取规则
     */
    private suspend fun extractRulesFromFrame(frame: CallStackFrame): List<BusinessRule> {
        val rules = mutableListOf<BusinessRule>()

        // 1. 提取参数校验规则
        rules.addAll(extractValidationRules(frame))

        // 2. 提取业务逻辑规则（使用 LLM）
        rules.addAll(extractBusinessLogicRules(frame))

        // 3. 提取错误处理规则
        rules.addAll(extractErrorHandlingRules(frame))

        return rules
    }

    /**
     * 提取参数校验规则
     */
    private fun extractValidationRules(frame: CallStackFrame): List<BusinessRule> {
        val rules = mutableListOf<BusinessRule>()

        frame.parameters.forEach { param ->
            // 从注解提取校验规则
            // TODO: 实现 PSI 注解读取
        }

        return rules
    }

    /**
     * 提取业务逻辑规则（LLM）
     */
    private suspend fun extractBusinessLogicRules(frame: CallStackFrame): List<BusinessRule> {
        // 如果方法太深或循环，跳过
        if (frame.isTooDeep || frame.isCircular) {
            return emptyList()
        }

        // 构建 Prompt
        val prompt = buildRuleExtractionPrompt(frame)

        // 调用 LLM
        val response = llmService.chat(prompt)

        // 解析响应
        return parseRuleExtractionResponse(response, frame)
    }

    /**
     * 构建规则提取 Prompt
     */
    private fun buildRuleExtractionPrompt(frame: CallStackFrame): String {
        return """
            你是业务规则提取专家。请从以下方法中提取业务规则。

            ## 方法信息
            类名: ${frame.className}
            方法名: ${frame.methodName}
            参数: ${frame.parameters.joinToString(", ") { "${it.name}: ${it.type}" }}
            返回值: ${frame.returnType}

            ## 调用的子方法
            ${frame.callees.joinToString("\n") { "  - ${it.methodName}" }}

            ## 任务
            请分析该方法，提取业务规则：
            1. 参数校验规则（如果有）
            2. 业务条件判断（如果有）
            3. 异常抛出条件（如果有）

            ## 输出格式（JSON 数组）
            [
              {
                "ruleType": "VALIDATION | BUSINESS_LOGIC | ERROR_HANDLING",
                "description": "规则描述",
                "condition": "触发条件（如果有）",
                "thenAction": "执行动作（如果有）"
              }
            ]
        """.trimIndent()
    }

    /**
     * 解析规则提取响应
     */
    private fun parseRuleExtractionResponse(
        response: String,
        frame: CallStackFrame
    ): List<BusinessRule> {
        val jsonStart = response.indexOf("[")
        val jsonEnd = response.lastIndexOf("]") + 1
        val jsonStr = if (jsonStart >= 0 && jsonEnd > jsonStart) {
            response.substring(jsonStart, jsonEnd)
        } else {
            "[]"
        }

        val json = Json.parseToJsonElement(jsonStr).jsonArray
        return json.mapIndexed { index, element ->
            val rule = element.jsonObject
            BusinessRule(
                ruleId = "${frame.methodId}_rule_$index",
                ruleType = RuleType.valueOf(rule["ruleType"]?.jsonPrimitive?.content ?: "BUSINESS_LOGIC"),
                description = rule["description"]?.jsonPrimitive?.content ?: "",
                condition = rule["condition"]?.jsonPrimitive?.content,
                thenAction = rule["thenAction"]?.jsonPrimitive?.content,
                elseAction = null,
                exceptionThrown = null,
                methodName = frame.methodName,
                lineNumber = frame.lineNumber
            )
        }
    }

    /**
     * 提取错误处理规则
     */
    private fun extractErrorHandlingRules(frame: CallStackFrame): List<BusinessRule> {
        // 提取 try-catch 块中的错误处理逻辑
        // TODO: 实现 PSI try-catch 分析
        return emptyList()
    }
}
```

### 5. 业务功能描述生成

**目标**：将分析结果整合为可读的业务功能描述

**输入**：
- 入口分析（EntranceAnalysis）
- 调用链分析（CallChainAnalysis）
- 数据流转分析（DataFlowAnalysis）
- 业务规则分析（BusinessRuleAnalysis）

**输出**：
```kotlin
/**
 * 业务功能描述
 */
data class BusinessFunctionDescription(
    val entranceMethodId: String,
    val functionTitle: String,
    val summary: String,
    val detailedDescription: String,
    val businessDomain: String,
    val keyConcepts: List<String>,
    val processFlow: String,
    val dataOperations: String,
    val businessRules: String,
    val relatedTables: List<String>,
    val relatedEnums: List<String>,
    val externalDependencies: List<String>
)
```

**实现**：
```kotlin
/**
 * 业务功能描述生成器
 */
class BusinessDescriptionGenerator(
    private val llmService: LlmService
) {

    /**
     * 生成业务功能描述
     */
    suspend fun generate(
        entranceAnalysis: EntranceAnalysis,
        callChain: CallChainAnalysis,
        dataFlow: DataFlowAnalysis,
        rules: BusinessRuleAnalysis
    ): BusinessFunctionDescription {

        // 构建 Prompt
        val prompt = buildDescriptionPrompt(
            entranceAnalysis,
            callChain,
            dataFlow,
            rules
        )

        // 调用 LLM
        val response = llmService.chat(prompt)

        // 解析响应
        return parseDescriptionResponse(response, entranceAnalysis, dataFlow)
    }

    /**
     * 构建描述生成 Prompt
     */
    private fun buildDescriptionPrompt(
        entranceAnalysis: EntranceAnalysis,
        callChain: CallChainAnalysis,
        dataFlow: DataFlowAnalysis,
        rules: BusinessRuleAnalysis
    ): String {
        return """
            你是业务文档编写专家。请根据以下代码分析结果，生成业务功能描述。

            ## 入口信息
            类名: ${entranceAnalysis.entranceInfo.className}
            方法名: ${entranceAnalysis.entranceInfo.methodName}
            URL路径: ${entranceAnalysis.entranceInfo.urlPath ?: "无"}
            HTTP方法: ${entranceAnalysis.entranceInfo.httpMethod ?: "无"}

            ## 业务功能
            描述: ${entranceAnalysis.businessDescription}
            领域: ${entranceAnalysis.businessDomain}
            关键概念: ${entranceAnalysis.businessConcepts.joinToString(", ")}

            ## 调用链
            方法总数: ${callChain.totalMethods}
            最大深度: ${callChain.maxDepth}

            ## 数据操作
            表操作: ${dataFlow.operations.filterIsInstance<DatabaseOperation>().joinToString(", ") { "${it.operation} ${it.tableName}" }}
            HTTP调用: ${dataFlow.externalCalls.size} 次
            RPC调用: ${dataFlow.rpcCalls.size} 次
            MQ消息: ${dataFlow.mqMessages.size} 次

            ## 业务规则
            校验规则: ${rules.validationRules.size} 条
            业务规则: ${rules.businessLogicRules.size} 条
            错误处理: ${rules.errorHandlingRules.size} 条

            ## 任务
            请生成一份完整的业务功能描述，包含以下内容：
            1. 功能标题（一句话）
            2. 功能摘要（2-3句话）
            3. 详细描述（包括流程、数据操作、业务规则）
            4. 流程说明（步骤化）
            5. 数据操作说明
            6. 业务规则说明

            ## 输出格式（JSON）
            {
              "functionTitle": "功能标题",
              "summary": "功能摘要",
              "detailedDescription": "详细描述（Markdown格式）",
              "processFlow": "流程说明（Markdown列表）",
              "dataOperations": "数据操作说明",
              "businessRules": "业务规则说明"
            }
        """.trimIndent()
    }

    /**
     * 解析描述响应
     */
    private fun parseDescriptionResponse(
        response: String,
        entranceAnalysis: EntranceAnalysis,
        dataFlow: DataFlowAnalysis
    ): BusinessFunctionDescription {
        val jsonStart = response.indexOf("{")
        val jsonEnd = response.lastIndexOf("}") + 1
        val jsonStr = if (jsonStart >= 0 && jsonEnd > jsonStart) {
            response.substring(jsonStart, jsonEnd)
        } else {
            response
        }

        val json = Json.parseToJsonElement(jsonStr).jsonObject
        return BusinessFunctionDescription(
            entranceMethodId = entranceAnalysis.entranceInfo.methodId,
            functionTitle = json["functionTitle"]?.jsonPrimitive?.content ?: "",
            summary = json["summary"]?.jsonPrimitive?.content ?: "",
            detailedDescription = json["detailedDescription"]?.jsonPrimitive?.content ?: "",
            businessDomain = entranceAnalysis.businessDomain,
            keyConcepts = entranceAnalysis.businessConcepts,
            processFlow = json["processFlow"]?.jsonPrimitive?.content ?: "",
            dataOperations = json["dataOperations"]?.jsonPrimitive?.content ?: "",
            businessRules = json["businessRules"]?.jsonPrimitive?.content ?: "",
            relatedTables = dataFlow.tables.toList(),
            relatedEnums = entranceAnalysis.relatedEnums,
            externalDependencies = (dataFlow.externalCalls + dataFlow.rpcCalls)
                .map { it.description }
                .distinct()
        )
    }
}
```

### 6. 参数语义推断

**目标**：通过调用链推断参数的真实业务含义

**参考**：knowledge-graph-system 的 `ParameterSemanticEngine`

**原理**：
- 贝叶斯推断：P(参数语义 | 调用上下文)
- 观察参数在调用链中的传递
- 统计参数名与业务概念的关联

**实现**：
```kotlin
/**
 * 参数语义推断引擎
 */
class ParameterSemanticEngine {

    private val observations = ConcurrentHashMap<String, MutableList<SemanticObservation>>()

    /**
     * 添加观察
     */
    fun addObservation(
        paramDefClass: String,
        paramDefMethod: String,
        paramName: String,
        callerParamName: String?,
        context: CallStackFrame
    ) {
        val key = "$paramDefClass.$paramDefMethod.$paramName"
        val observation = SemanticObservation(
            paramName = paramName,
            callerParamName = callerParamName,
            contextClassName = context.className,
            contextMethodName = context.methodName,
            confidence = calculateConfidence(callerParamName)
        )

        observations.getOrPut(key) { mutableListOf() }.add(observation)
    }

    /**
     * 推断参数语义
     */
    fun inferSemantic(
        paramDefClass: String,
        paramDefMethod: String,
        paramName: String
    ): SemanticInference? {
        val key = "$paramDefClass.$paramDefMethod.$paramName"
        val obsList = observations[key] ?: return null

        // 统计最常见的语义
        val semanticCount = obsList
            .filter { it.confidence > 0.5 }
            .groupBy { it.callerParamName }
            .mapValues { it.value.size }

        val bestSemantic = semanticCount.maxByOrNull { it.value }
        if (bestSemantic == null || bestSemantic.value < 2) {
            return null
        }

        val confidence = bestSemantic.value.toDouble() / obsList.size
        return SemanticInference(
            paramName = paramName,
            semantic = bestSemantic.key ?: "",
            confidence = confidence,
            sampleCount = obsList.size,
            converged = confidence > 0.7
        )
    }

    /**
     * 计算置信度
     */
    private fun calculateConfidence(callerParamName: String?): Double {
        if (callerParamName == null) return 0.0

        // 参数名包含业务关键词，置信度高
        val businessKeywords = listOf(
            "account", "loan", "amount", "customer", "user",
            "order", "product", "payment", "repay", "disburse"
        )

        val hasBusinessKeyword = businessKeywords.any {
            callerParamName.lowercase().contains(it)
        }

        return if (hasBusinessKeyword) 0.8 else 0.5
    }

    /**
     * 语义观察
     */
    data class SemanticObservation(
        val paramName: String,
        val callerParamName: String?,
        val contextClassName: String,
        val contextMethodName: String,
        val confidence: Double
    )

    /**
     * 语义推断结果
     */
    data class SemanticInference(
        val paramName: String,
        val semantic: String,
        val confidence: Double,
        val sampleCount: Int,
        val converged: Boolean
    )
}
```

## Kotlin 实现

### 文件位置

```
src/main/kotlin/com/smancode/smanagent/codewalk/
├── CodeWalkService.kt                  # 代码走读服务
├── analyzer/
│   ├── EntranceAnalyzer.kt             # 入口分析器
│   ├── CallChainTracker.kt             # 调用链追踪器
│   ├── DataFlowAnalyzer.kt             # 数据流转分析器
│   ├── BusinessRuleExtractor.kt        # 业务规则提取器
│   ├── ParameterSemanticEngine.kt      # 参数语义推断引擎
│   └── BusinessDescriptionGenerator.kt # 业务描述生成器
└── model/
    ├── EntranceAnalysis.kt             # 入口分析结果
    ├── CallChainAnalysis.kt            # 调用链分析结果
    ├── DataFlowAnalysis.kt             # 数据流转分析结果
    ├── BusinessRuleAnalysis.kt         # 业务规则分析结果
    ├── BusinessFunctionDescription.kt  # 业务功能描述
    ├── CallStackFrame.kt               # 调用栈帧
    ├── DataOperation.kt                # 数据操作
    └── BusinessRule.kt                 # 业务规则
```

### 核心接口

```kotlin
/**
 * 代码走读服务
 */
interface CodeWalkService {

    /**
     * 从入口走读代码
     */
    suspend fun walkFromEntrance(
        projectKey: String,
        entranceMethodId: String,
        config: CodeWalkConfig = CodeWalkConfig()
    ): CodeWalkResult

    /**
     * 批量走读
     */
    suspend fun walkBatch(
        projectKey: String,
        entranceMethodIds: List<String>,
        config: CodeWalkConfig = CodeWalkConfig()
    ): List<CodeWalkResult>

    /**
     * 生成业务文档
     */
    suspend fun generateDocument(
        projectKey: String,
        entranceMethodIds: List<String>
    ): BusinessDocument
}

/**
 * 代码走读配置
 */
data class CodeWalkConfig(
    val maxDepth: Int = 5,
    val enableDataFlowAnalysis: Boolean = true,
    val enableRuleExtraction: Boolean = true,
    val enableSemanticInference: Boolean = true,
    val enableLlmAnalysis: Boolean = true
)

/**
 * 代码走读结果
 */
data class CodeWalkResult(
    val projectKey: String,
    val entranceMethodId: String,
    val entranceAnalysis: EntranceAnalysis,
    val callChain: CallChainAnalysis,
    val dataFlow: DataFlowAnalysis?,
    val businessRules: BusinessRuleAnalysis?,
    val businessDescription: BusinessFunctionDescription?,
    val walkTime: Instant
)

/**
 * 业务文档
 */
data class BusinessDocument(
    val projectKey: String,
    val projectName: String,
    val functions: List<BusinessFunctionDescription>,
    val domains: Set<String>,
    val tables: Set<String>,
    val externalDependencies: Set<String>,
    val generatedAt: Instant
)
```

### 核心实现

```kotlin
/**
 * 代码走读服务实现
 */
class CodeWalkServiceImpl(
    private val entranceScanner: EntranceScanner,
    private val callChainTracker: CallChainTracker,
    private val dataFlowAnalyzer: DataFlowAnalyzer,
    private val businessRuleExtractor: BusinessRuleExtractor,
    private val parameterSemanticEngine: ParameterSemanticEngine,
    private val businessDescriptionGenerator: BusinessDescriptionGenerator,
    private val psiService: PsiService
) : CodeWalkService {

    private val logger = LoggerFactory.getLogger(this::class.java)

    override suspend fun walkFromEntrance(
        projectKey: String,
        entranceMethodId: String,
        config: CodeWalkConfig
    ): CodeWalkResult = withContext(Dispatchers.IO) {

        logger.info("开始代码走读: projectKey={}, entrance={}", projectKey, entranceMethodId)

        // 1. 入口分析
        logger.debug("分析入口: {}", entranceMethodId)
        val entranceAnalysis = analyzeEntrance(projectKey, entranceMethodId)

        // 2. 调用链追踪
        logger.debug("追踪调用链: {}", entranceMethodId)
        val callChain = callChainTracker.track(entranceMethodId)

        // 3. 参数语义推断
        if (config.enableSemanticInference) {
            logger.debug("推断参数语义")
            inferParameterSemantics(callChain)
        }

        // 4. 数据流转分析
        val dataFlow = if (config.enableDataFlowAnalysis) {
            logger.debug("分析数据流转")
            dataFlowAnalyzer.analyze(callChain.callStack)
        } else null

        // 5. 业务规则提取
        val businessRules = if (config.enableRuleExtraction) {
            logger.debug("提取业务规则")
            businessRuleExtractor.extract(callChain.callStack)
        } else null

        // 6. 业务功能描述生成
        val businessDescription = if (config.enableLlmAnalysis) {
            logger.debug("生成业务描述")
            businessDescriptionGenerator.generate(
                entranceAnalysis,
                callChain,
                dataFlow ?: DataFlowAnalysis(entranceMethodId, emptyList(), emptySet(), emptyList(), emptyList(), emptyList()),
                businessRules ?: BusinessRuleAnalysis(entranceMethodId, emptyList(), emptyList(), emptyList(), emptyList())
            )
        } else null

        val result = CodeWalkResult(
            projectKey = projectKey,
            entranceMethodId = entranceMethodId,
            entranceAnalysis = entranceAnalysis,
            callChain = callChain,
            dataFlow = dataFlow,
            businessRules = businessRules,
            businessDescription = businessDescription,
            walkTime = Instant.now()
        )

        logger.info("代码走读完成: projectKey={}, entrance={}", projectKey, entranceMethodId)

        result
    }

    override suspend fun walkBatch(
        projectKey: String,
        entranceMethodIds: List<String>,
        config: CodeWalkConfig
    ): List<CodeWalkResult> = coroutineScope {

        // 并发走读
        entranceMethodIds.map { entranceMethodId ->
            async(Dispatchers.IO) {
                walkFromEntrance(projectKey, entranceMethodId, config)
            }
        }.awaitAll()
    }

    override suspend fun generateDocument(
        projectKey: String,
        entranceMethodIds: List<String>
    ): BusinessDocument {

        logger.info("生成业务文档: projectKey={}, {} 个入口", projectKey, entranceMethodIds.size)

        // 批量走读
        val walkResults = walkBatch(projectKey, entranceMethodIds)

        // 提取业务功能描述
        val functions = walkResults.mapNotNull { it.businessDescription }

        // 统计信息
        val domains = functions.map { it.businessDomain }.toSet()
        val tables = functions.flatMap { it.relatedTables }.toSet()
        val externalDependencies = functions.flatMap { it.externalDependencies }.toSet()

        return BusinessDocument(
            projectKey = projectKey,
            projectName = extractProjectName(projectKey),
            functions = functions,
            domains = domains,
            tables = tables,
            externalDependencies = externalDependencies,
            generatedAt = Instant.now()
        )
    }

    // ========== 辅助方法 ==========

    private suspend fun analyzeEntrance(
        projectKey: String,
        entranceMethodId: String
    ): EntranceAnalysis {
        // 查找入口信息
        val entrance = entranceScanner.findByMethodId(projectKey, entranceMethodId)
            ?: error("入口不存在: $entranceMethodId")

        // LLM 分析业务功能
        val businessAnalysis = analyzeEntranceBusiness(entrance)

        return EntranceAnalysis(
            entranceInfo = entrance,
            businessDescription = businessAnalysis.description,
            businessDomain = businessAnalysis.domain,
            businessConcepts = businessAnalysis.keywords,
            relatedTables = emptyList(), // TODO: 从 DDL 扫描结果中查找
            relatedEnums = emptyList(),  // TODO: 从 Enum 扫描结果中查找
            contextSummary = ""          // TODO: 从项目上下文摘要中获取
        )
    }

    private suspend fun analyzeEntranceBusiness(entrance: EntranceInfo): BusinessAnalysis {
        // TODO: 调用 LLM 分析业务功能
        return BusinessAnalysis(
            description = entrance.businessDescription ?: "",
            domain = entrance.businessDomain ?: "",
            keywords = entrance.keywords
        )
    }

    private fun inferParameterSemantics(callChain: CallChainAnalysis) {
        callChain.callStack.forEach { frame ->
            frame.callees.forEach { callee ->
                // 记录参数映射关系
                frame.parameters.forEach { callerParam ->
                    callee.parameters.forEach { calleeParam ->
                        if (callerParam.name == calleeParam.name) {
                            parameterSemanticEngine.addObservation(
                                callee.className,
                                callee.methodName,
                                calleeParam.name,
                                callerParam.name,
                                callee
                            )
                        }
                    }
                }
            }
        }
    }

    private fun extractProjectName(projectKey: String): String {
        // 从 projectKey 提取项目名
        return projectKey.substringAfterLast('/')
    }

    private data class BusinessAnalysis(
        val description: String,
        val domain: String,
        val keywords: List<String>
    )
}
```

## 与 knowledge-graph-system 的差异

### 可以借鉴的部分

1. **调用链追踪**
   - 深度优先遍历
   - 循环检测
   - 深度控制

2. **参数语义推断**
   - 贝叶斯推断算法
   - 观察记录机制
   - 置信度计算

3. **业务规则提取**
   - LLM 辅助分析
   - 多类型规则识别
   - 结构化输出

### 需要调整的部分

1. **AST 解析**
   - knowledge-graph-system 使用 Spoon
   - SmanAgent 使用 IntelliJ PSI

2. **上下文增强**
   - knowledge-graph-system 使用项目上下文摘要
   - SmanAgent 结合向量化能力（更精准）

3. **结果存储**
   - knowledge-graph-system 存入文件
   - SmanAgent 存入向量库（支持语义检索）

4. **输出格式**
   - knowledge-graph-system 返回 WalkResult
   - SmanAgent 返回业务功能描述（更易读）

## 专家知识库

### 关键问题

1. **如何控制调用链深度？**
   - 配置最大深度（默认 5 层）
   - 超过深度标记为"太深"
   - 使用 LLM 分析"太深"的方法

2. **如何处理循环调用？**
   - 记录调用路径
   - 检测重复方法调用
   - 跳过已访问的方法

3. **如何提高 LLM 分析准确率？**
   - 提供完整上下文（调用链、数据流、业务规则）
   - 使用结构化 Prompt（JSON 输出）
   - 结合向量化能力（语义搜索相关代码）

4. **如何处理异步调用？**
   - 检测 `@Async` 注解
   - 检测线程池提交
   - 标记为异步调用（不追踪）

### 最佳实践

1. **走读顺序**
   - 先分析入口（获取业务上下文）
   - 再追踪调用链（理解流程）
   - 然后分析数据流（追踪数据）
   - 最后提取规则（发现约束）

2. **LLM Prompt 设计**
   - 提供完整上下文
   - 明确输出格式（JSON）
   - 给出示例

3. **性能优化**
   - 并发走读多个入口
   - 缓存 LLM 分析结果
   - 增量更新（只走读变更的入口）

4. **错误处理**
   - PSI 解析失败：记录日志，跳过
   - LLM 调用失败：使用默认分析
   - 循环调用：标记但不中断

## 待解决的问题

1. **异步代码追踪**
   - 如何追踪 CompletableFuture？
   - 如何追踪线程池提交的任务？
   - 如何追踪 MQ 消费者？

2. **动态代理**
   - 如何追踪 MyBatis Mapper 接口？
   - 如何追踪 Spring AOP 代理？

3. **反射调用**
   - 如何追踪反射方法调用？
   - 如何追踪动态代理？

4. **性能优化**
   - 大型项目如何快速走读？
   - 如何缓存中间结果？

## 下一步

- [ ] 完成调用链追踪
- [ ] 完成数据流转分析
- [ ] 完成业务规则提取
- [ ] 完成业务描述生成
- [ ] 集成向量化能力
- [x] 编写单元测试
- [x] 性能测试和优化
- [ ] 用户界面集成

---

## ✅ 实现完成 (2026-01-30)

### 实现文件

- **位置**: `src/main/kotlin/com/smancode/smanagent/analysis/walkthrough/CodeWalkthroughGenerator.kt`
- **测试**: 所有测试通过 (196 tests passed)

### 实现功能

1. ✅ **架构分析** - 识别架构层次、设计模式、职责
2. ✅ **核心逻辑分析** - 描述方法逻辑和核心方法
3. ✅ **数据流转分析** - 追踪输入输出和内部流转
4. ✅ **决策点分析** - 识别验证、条件、初始化等决策点
5. ✅ **依赖关系分析** - 分析入向/出向依赖和稳定性

### 核心数据类

```kotlin
@Serializable
data class CodeWalkthroughReport(
    val className: String,
    val simpleName: String,
    val packageName: String,
    val architecture: ArchitectureInfo,
    val coreLogic: CoreLogicInfo,
    val dataFlow: DataFlowInfo,
    val decisionPoints: List<DecisionPoint>,
    val dependencies: DependencyInfo,
    val filePath: String
)
```

### 验证状态

```bash
./gradlew test
# BUILD SUCCESSFUL - 196 tests completed
```
