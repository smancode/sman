# 06 - 外调接口扫描

## 目标

为 SmanAgent 项目添加外部调用扫描能力，自动识别项目中所有外部依赖调用（HTTP、RPC、数据库、缓存、消息队列等），提取调用元数据，分析外部依赖关系。最终将分析结果存入向量库，支持 BGE 召回 + 重排。

**核心价值**：
- 识别系统外部依赖，评估依赖风险
- 支持调用链分析和影响范围评估
- 建立"业务 → 外调 → 外部系统"的映射关系
- 为故障排查提供上下文信息

## 参考

- knowledge-graph-system 的 `MethodCallInfo.java`（CallType 枚举）
- knowledge-graph-system 的 `SpecialPattern.java`（PatternType 枚举）
- Spring Boot 官方文档（各种客户端使用方式）
- 行业最佳实践（外部调用监控和治理）

## 核心功能

### 1. HTTP 客户端识别

**目标**：识别所有 HTTP 客户端调用

**识别规则**：

| 客户端类型 | 识别特征 | 置信度 | 说明 |
|-----------|---------|--------|------|
| RestTemplate | 类名为 `RestTemplate` | 0.95 | Spring 同步 HTTP 客户端 |
| WebClient | 类名为 `WebClient` | 0.95 | Spring 响应式 HTTP 客户端 |
| OkHttp | 类名为 `OkHttpClient` | 0.95 | OkHttp 客户端 |
| Feign Client | 注解 `@FeignClient` | 0.95 | Spring Cloud OpenFeign |
| Apache HttpClient | 类名为 `HttpClient` | 0.90 | Apache HTTP 客户端 |

**提取元数据**：
- **目标 URL**：从方法调用参数提取
- **HTTP 方法**：GET、POST、PUT、DELETE 等
- **超时配置**：连接超时、读取超时
- **重试策略**：是否重试、重试次数
- **调用方法**：调用的客户端方法名
- **调用位置**：类名、方法名、行号

**检测示例**：
```kotlin
@Service
class PaymentService {
    @Autowired
    private lateinit var restTemplate: RestTemplate

    fun pay(orderId: String, amount: BigDecimal) {
        val url = "https://bank-api.com/api/pay"
        val request = PaymentRequest(orderId, amount)
        restTemplate.postForObject(url, request, PaymentResponse::class.java)
    }
}
```

**检测结果**：
```json
{
  "callType": "HTTP",
  "clientType": "RestTemplate",
  "targetUrl": "https://bank-api.com/api/pay",
  "httpMethod": "POST",
  "timeout": "未配置",
  "retry": "未配置",
  "callerClass": "com.example.service.PaymentService",
  "callerMethod": "pay",
  "lineNumber": 42
}
```

**Feign Client 特殊处理**：
```kotlin
@FeignClient(name = "user-service", url = "https://user-api.com")
interface UserClient {
    @GetMapping("/api/users/{id}")
    fun getUser(@PathVariable id: String): User
}
```

**检测结果**：
```json
{
  "callType": "HTTP",
  "clientType": "FeignClient",
  "serviceName": "user-service",
  "targetUrl": "https://user-api.com/api/users/{id}",
  "httpMethod": "GET",
  "callerClass": "com.example.client.UserClient",
  "callerMethod": "getUser",
  "lineNumber": 15
}
```

### 2. RPC 客户端识别

**目标**：识别所有 RPC 客户端调用

**识别规则**：

| RPC 类型 | 识别特征 | 置信度 | 说明 |
|---------|---------|--------|------|
| Dubbo Reference | 注解 `@DubboReference` | 0.95 | Dubbo 消费者 |
| Dubbo Reference | 注解 `@Reference` | 0.85 | 可能是 Dubbo 引用（需验证） |
| gRPC | 类名为 `*GrpcClient` 或 `*BlockingStub` | 0.90 | gRPC 客户端 |

**提取元数据**：
- **服务接口**：引用的接口类型
- **服务版本**：从注解属性提取
- **调用方法**：调用的 RPC 方法名
- **超时配置**：从注解或配置提取
- **重试策略**：从配置提取
- **调用位置**：类名、方法名、行号

**检测示例**：
```kotlin
@Service
class OrderService {
    @DubboReference(version = "1.0.0", timeout = 5000)
    private lateinit var userService: UserService

    fun createOrder(userId: String, productId: String) {
        val user = userService.getUser(userId)
        // ...
    }
}
```

**检测结果**：
```json
{
  "callType": "RPC",
  "rpcType": "DUBBO",
  "serviceInterface": "com.example.api.UserService",
  "serviceVersion": "1.0.0",
  "timeout": 5000,
  "callerMethod": "getUser",
  "callerClass": "com.example.service.OrderService",
  "lineNumber": 35
}
```

### 3. 数据库调用识别

**目标**：识别所有数据库调用

**识别规则**：

| ORM/框架 | 识别特征 | 置信度 | 说明 |
|---------|---------|--------|------|
| JPA Repository | 继承 `JpaRepository`、`CrudRepository` | 0.95 | Spring Data JPA |
| MyBatis Mapper | 接口名以 `Mapper` 结尾 + `@Mapper` | 0.95 | MyBatis Mapper |
| JDBC Template | 类名为 `JdbcTemplate` | 0.95 | Spring JDBC |
| MyBatis SqlSession | 类名为 `SqlSession` | 0.90 | MyBatis 原生 |

**提取元数据**：
- **表名**：从实体类或 SQL 提取
- **操作类型**：INSERT、UPDATE、DELETE、SELECT
- **查询方法**：调用的 Repository/Mapper 方法
- **动态 SQL**：是否有动态 SQL（MyBatis）
- **调用位置**：类名、方法名、行号

**检测示例**：
```kotlin
@Service
class LoanService {
    @Autowired
    private lateinit var loanRepository: LoanRepository

    fun createLoan(loan: Loan) {
        loanRepository.save(loan)
    }
}

@Repository
interface LoanRepository : JpaRepository<Loan, Long> {
    fun findByStatus(status: LoanStatus): List<Loan>
}
```

**检测结果**：
```json
{
  "callType": "DATABASE",
  "ormType": "JPA",
  "entityClass": "com.example.entity.Loan",
  "tableName": "loan",
  "operationType": "INSERT",
  "repositoryMethod": "save",
  "callerClass": "com.example.service.LoanService",
  "callerMethod": "createLoan",
  "lineNumber": 28
}
```

**MyBatis 特殊处理**：
```kotlin
@Mapper
interface LoanMapper {
    @Insert("INSERT INTO loan (id, amount) VALUES (#{id}, #{amount})")
    fun insert(loan: Loan): Int

    @Select("SELECT * FROM loan WHERE status = #{status}")
    fun findByStatus(@Param("status") status: String): List<Loan>
}
```

**检测结果**：
```json
{
  "callType": "DATABASE",
  "ormType": "MYBATIS",
  "tableName": "loan",
  "operationType": "INSERT",
  "sqlStatement": "INSERT INTO loan (id, amount) VALUES (#{id}, #{amount})",
  "mapperMethod": "insert",
  "callerClass": "com.example.mapper.LoanMapper",
  "callerMethod": "insert",
  "lineNumber": 18
}
```

### 4. 缓存调用识别

**目标**：识别所有缓存调用

**识别规则**：

| 缓存类型 | 识别特征 | 置信度 | 说明 |
|---------|---------|--------|------|
| Redis Template | 类名为 `RedisTemplate`、`StringRedisTemplate` | 0.95 | Spring Data Redis |
| Redisson | 类名为 `RedissonClient` | 0.95 | Redisson 分布式锁 |
| Cache 注解 | 注解 `@Cacheable`、`@CachePut`、`@CacheEvict` | 0.95 | Spring Cache 抽象 |
| Caffeine | 类名为 `Cache`（Caffeine 包） | 0.90 | Caffeine 本地缓存 |

**提取元数据**：
- **缓存键**：从方法参数或注解属性提取
- **缓存操作**：GET、PUT、DELETE
- **过期时间**：从注解或配置提取
- **缓存名称**：从注解属性提取
- **调用位置**：类名、方法名、行号

**检测示例**：
```kotlin
@Service
class UserService {
    @Autowired
    private lateinit var redisTemplate: RedisTemplate<String, Any>

    fun getUser(userId: String): User? {
        val key = "user:$userId"
        return redisTemplate.opsForValue().get(key) as? User
    }

    @Cacheable(value = ["user"], key = "#userId")
    fun loadUser(userId: String): User {
        // 从数据库加载
    }
}
```

**检测结果**：
```json
{
  "callType": "CACHE",
  "cacheType": "REDIS",
  "cacheOperation": "GET",
  "cacheKey": "user:$userId",
  "cacheName": null,
  "callerClass": "com.example.service.UserService",
  "callerMethod": "getUser",
  "lineNumber": 42
}
```

**Spring Cache 特殊处理**：
```json
{
  "callType": "CACHE",
  "cacheType": "SPRING_CACHE",
  "cacheOperation": "GET",
  "cacheKey": "#userId",
  "cacheName": "user",
  "ttl": "未配置",
  "callerClass": "com.example.service.UserService",
  "callerMethod": "loadUser",
  "lineNumber": 48
}
```

### 5. 消息队列调用识别

**目标**：识别所有消息队列发送

**识别规则**：

| MQ 类型 | 识别特征 | 置信度 | 说明 |
|---------|---------|--------|------|
| Kafka Template | 类名为 `KafkaTemplate` | 0.95 | Spring Kafka |
| RocketMQ Template | 类名为 `RocketMQTemplate` | 0.95 | RocketMQ |
| RabbitMQ Template | 类名为 `RabbitTemplate` | 0.95 | Spring AMQP |
| JMS Template | 类名为 `JmsTemplate` | 0.95 | Spring JMS |

**提取元数据**：
- **Topic/Queue 名称**：从方法调用参数提取
- **消息类型**：发送的消息类型
- **发送方式**：同步/异步
- **调用位置**：类名、方法名、行号

**检测示例**：
```kotlin
@Service
class OrderService {
    @Autowired
    private lateinit var kafkaTemplate: KafkaTemplate<String, String>

    fun createOrder(order: Order) {
        // 保存订单
        orderRepository.save(order)

        // 发送订单创建消息
        val message = ObjectMapper().writeValueAsString(order)
        kafkaTemplate.send("order.created", order.id, message)
    }
}
```

**检测结果**：
```json
{
  "callType": "MESSAGE_QUEUE",
  "mqType": "KAFKA",
  "topic": "order.created",
  "messageType": "com.example.entity.Order",
  "sendMethod": "send",
  "callerClass": "com.example.service.OrderService",
  "callerMethod": "createOrder",
  "lineNumber": 58
}
```

### 6. 外部依赖关系分析

**目标**：分析外部依赖之间的关系

**分析维度**：
1. **依赖拓扑**
   - 识别依赖的外部服务数量
   - 分析服务间的调用关系
   - 构建依赖图

2. **依赖风险评估**
   - **高风险**：调用支付系统、核心交易系统
   - **中风险**：调用第三方 API、外部数据源
   - **低风险**：调用内部服务、缓存

3. **依赖集中度**
   - 分析哪些服务被频繁调用
   - 识别关键依赖点

4. **超时配置分析**
   - 统计未配置超时的外部调用
   - 统计超时时间过长的调用

5. **重试策略分析**
   - 统计未配置重试的外部调用
   - 识别可能需要重试的调用（网络相关）

**分析结果示例**：
```json
{
  "totalExternalCalls": 15,
  "externalServices": {
    "https://bank-api.com": {
      "callCount": 5,
      "riskLevel": "HIGH",
      "avgTimeout": 3000
    },
    "user-service": {
      "callCount": 8,
      "riskLevel": "MEDIUM",
      "avgTimeout": 5000
    }
  },
  "riskSummary": {
    "highRiskCount": 1,
    "mediumRiskCount": 3,
    "lowRiskCount": 11
  },
  "timeoutIssueCount": 3,
  "retryIssueCount": 7
}
```

### 7. PSI 扫描策略

**目标**：通过 PSI 精准扫描外部调用

**扫描流程**：
```kotlin
// 1. 扫描所有类的字段声明
val fields = psiClass.fields
for (field in fields) {
    // 2. 检查字段类型是否是外部客户端
    val fieldType = field.type
    when {
        isHttpClient(fieldType) -> extractHttpCalls(field)
        isRpcClient(fieldType) -> extractRpcCalls(field)
        isDatabaseClient(fieldType) -> extractDatabaseCalls(field)
        isCacheClient(fieldType) -> extractCacheCalls(field)
        isMqClient(fieldType) -> extractMqCalls(field)
    }
}

// 3. 扫描所有方法的方法体
val methods = psiClass.methods
for (method in methods) {
    // 4. 遍历方法体中的方法调用表达式
    method.body?.accept(object : PsiRecursiveElementVisitor() {
        override fun visitMethodCallExpression(call: PsiMethodCallExpression) {
            // 5. 检查是否是外部客户端的方法调用
            val methodRef = call.methodExpression
            val qualifier = methodRef.qualifier
            val qualifierType = qualifier?.type

            when {
                isHttpClientMethodCall(qualifierType, methodRef) -> extractHttpCallDetails(call)
                isRpcMethodCall(qualifierType, methodRef) -> extractRpcCallDetails(call)
                isDatabaseMethodCall(qualifierType, methodRef) -> extractDatabaseCallDetails(call)
                isCacheMethodCall(qualifierType, methodRef) -> extractCacheCallDetails(call)
                isMqMethodCall(qualifierType, methodRef) -> extractMqCallDetails(call)
            }

            super.visitMethodCallExpression(call)
        }
    })
}
```

**类型检测辅助函数**：
```kotlin
/**
 * 检查是否是 HTTP 客户端
 */
private fun isHttpClient(type: PsiType?): Boolean {
    if (type == null) return false
    val canonicalText = type.canonicalText
    return canonicalText.endsWith("RestTemplate") ||
           canonicalText.endsWith("WebClient") ||
           canonicalText.endsWith("OkHttpClient") ||
           canonicalText.endsWith("HttpClient")
}

/**
 * 检查是否是 Feign Client
 */
private fun isFeignClient(field: PsiField): Boolean {
    return field.annotations.any {
        it.qualifiedReferenceName?.endsWith("FeignClient") == true
    }
}

/**
 * 检查是否是 Dubbo Reference
 */
private fun isDubboReference(field: PsiField): Boolean {
    return field.annotations.any {
        it.qualifiedReferenceName?.endsWith("DubboReference") == true ||
        it.qualifiedReferenceName?.endsWith("Reference") == true
    }
}

/**
 * 检查是否是 JPA Repository
 */
private fun isJpaRepository(type: PsiType?): Boolean {
    if (type == null) return false
    val canonicalText = type.canonicalText
    return canonicalText.endsWith("Repository") &&
           (canonicalText.contains("JpaRepository") ||
            canonicalText.contains("CrudRepository"))
}

/**
 * 检查是否是 MyBatis Mapper
 */
private fun isMyBatisMapper(type: PsiType?): Boolean {
    if (type == null) return false
    val canonicalText = type.canonicalText
    return canonicalText.endsWith("Mapper")
}

/**
 * 检查是否是 Redis Template
 */
private fun isRedisTemplate(type: PsiType?): Boolean {
    if (type == null) return false
    val canonicalText = type.canonicalText
    return canonicalText.endsWith("RedisTemplate") ||
           canonicalText.endsWith("StringRedisTemplate")
}

/**
 * 检查是否是 Kafka Template
 */
private fun isKafkaTemplate(type: PsiType?): Boolean {
    if (type == null) return false
    val canonicalText = type.canonicalText
    return canonicalText.endsWith("KafkaTemplate")
}
```

**方法调用细节提取**：
```kotlin
/**
 * 提取 HTTP 调用细节
 */
private fun extractHttpCallDetails(call: PsiMethodCallExpression): HttpCallDetails {
    val methodName = call.methodExpression.referenceName
    val args = call.argumentList.expressions

    return when (methodName) {
        "getForObject", "getForEntity" -> {
            val url = extractUrl(args[0])
            HttpCallDetails(
                httpMethod = "GET",
                targetUrl = url,
                timeout = null,
                retry = null
            )
        }
        "postForObject", "postForEntity" -> {
            val url = extractUrl(args[0])
            HttpCallDetails(
                httpMethod = "POST",
                targetUrl = url,
                timeout = null,
                retry = null
            )
        }
        else -> {
            // WebClient、OkHttp 等其他客户端
            extractGenericHttpCall(call)
        }
    }
}

/**
 * 提取 URL
 */
private fun extractUrl(expr: PsiExpression): String {
    return when (expr) {
        is PsiLiteralExpression -> {
            // 字符串字面量
            expr.text.removeSurrounding("\"")
        }
        is PsiReferenceExpression -> {
            // 变量引用
            "@Variable"
        }
        is PsiMethodCallExpression -> {
            // 方法调用（如 URL 拼接）
            "@DynamicURL"
        }
        else -> "@Unknown"
    }
}
```

## Kotlin 实现

### 文件位置

```
src/main/kotlin/com/smancode/smanagent/analyzer/
├── external/
│   ├── ExternalCallDetector.kt          # 主检测器
│   ├── HttpClientDetector.kt            # HTTP 客户端检测
│   ├── RpcClientDetector.kt             # RPC 客户端检测
│   ├── DatabaseCallDetector.kt          # 数据库调用检测
│   ├── CacheCallDetector.kt             # 缓存调用检测
│   ├── MqCallDetector.kt                # 消息队列调用检测
│   ├── DependencyAnalyzer.kt            # 依赖关系分析
│   └── model/
│       ├── ExternalCall.kt              # 外部调用基类
│       ├── HttpCall.kt                  # HTTP 调用
│       ├── RpcCall.kt                   # RPC 调用
│       ├── DatabaseCall.kt              # 数据库调用
│       ├── CacheCall.kt                 # 缓存调用
│       ├── MqCall.kt                    # 消息队列调用
│       ├── CallType.kt                  # 调用类型枚举
│       ├── DependencyRisk.kt            # 依赖风险评估
│       └── DependencyReport.kt          # 依赖报告
```

### 核心接口

```kotlin
/**
 * 外部调用检测器接口
 */
interface ExternalCallDetector {
    /**
     * 检测所有外部调用
     * @param projectKey 项目标识
     * @param psiClasses 所有类
     * @return 检测结果
     */
    suspend fun detectAll(
        projectKey: String,
        psiClasses: Collection<PsiClass>
    ): ExternalCallDetectionResult
}

/**
 * 外部调用检测结果
 */
data class ExternalCallDetectionResult(
    val projectKey: String,
    val scanTime: Instant,
    val httpCalls: List<HttpCall>,
    val rpcCalls: List<RpcCall>,
    val databaseCalls: List<DatabaseCall>,
    val cacheCalls: List<CacheCall>,
    val mqCalls: List<MqCall>,
    val dependencyReport: DependencyReport
)

/**
 * HTTP 调用
 */
data class HttpCall(
    override val callType: CallType = CallType.HTTP,
    val clientType: HttpClientType,
    val targetUrl: String?,
    val httpMethod: String?,
    val timeout: Long?,
    val retry: RetryConfig?,
    override val callerClass: String,
    override val callerMethod: String,
    override val lineNumber: Int,
    val description: String? = null,
    val riskLevel: RiskLevel = RiskLevel.MEDIUM
) : ExternalCall()

/**
 * HTTP 客户端类型
 */
enum class HttpClientType {
    REST_TEMPLATE,
    WEB_CLIENT,
    OK_HTTP,
    FEIGN_CLIENT,
    APACHE_HTTP_CLIENT,
    UNKNOWN
}

/**
 * RPC 调用
 */
data class RpcCall(
    override val callType: CallType = CallType.RPC,
    val rpcType: RpcType,
    val serviceInterface: String?,
    val serviceVersion: String?,
    val targetMethod: String?,
    val timeout: Long?,
    val retry: RetryConfig?,
    override val callerClass: String,
    override val callerMethod: String,
    override val lineNumber: Int,
    val description: String? = null,
    val riskLevel: RiskLevel = RiskLevel.MEDIUM
) : ExternalCall()

/**
 * RPC 类型
 */
enum class RpcType {
    DUBBO,
    GRPC,
    UNKNOWN
}

/**
 * 数据库调用
 */
data class DatabaseCall(
    override val callType: CallType = CallType.DATABASE,
    val ormType: OrmType,
    val entityClass: String?,
    val tableName: String?,
    val operationType: DatabaseOperationType,
    val repositoryMethod: String?,
    val sqlStatement: String?,
    override val callerClass: String,
    override val callerMethod: String,
    override val lineNumber: Int,
    val description: String? = null
) : ExternalCall()

/**
 * ORM 类型
 */
enum class OrmType {
    JPA,
    MYBATIS,
    JDBC,
    UNKNOWN
}

/**
 * 数据库操作类型
 */
enum class DatabaseOperationType {
    INSERT,
    UPDATE,
    DELETE,
    SELECT,
    BATCH,
    UNKNOWN
}

/**
 * 缓存调用
 */
data class CacheCall(
    override val callType: CallType = CallType.CACHE,
    val cacheType: CacheType,
    val cacheOperation: CacheOperationType,
    val cacheKey: String?,
    val cacheName: String?,
    val ttl: Long?,
    override val callerClass: String,
    override val callerMethod: String,
    override val lineNumber: Int,
    val description: String? = null
) : ExternalCall()

/**
 * 缓存类型
 */
enum class CacheType {
    REDIS,
    REDDISSON,
    SPRING_CACHE,
    CAFFEINE,
    MEMCACHED,
    UNKNOWN
}

/**
 * 缓存操作类型
 */
enum class CacheOperationType {
    GET,
    PUT,
    DELETE,
    CLEAR,
    UNKNOWN
}

/**
 * 消息队列调用
 */
data class MqCall(
    override val callType: CallType = CallType.MESSAGE_QUEUE,
    val mqType: MqType,
    val topic: String?,
    val messageType: String?,
    val sendMethod: String?,
    override val callerClass: String,
    override val callerMethod: String,
    override val lineNumber: Int,
    val description: String? = null
) : ExternalCall()

/**
 * MQ 类型
 */
enum class MqType {
    KAFKA,
    ROCKETMQ,
    RABBITMQ,
    JMS,
    UNKNOWN
}

/**
 * 调用类型枚举
 */
enum class CallType {
    HTTP,           // HTTP 调用
    RPC,            // RPC 调用
    DATABASE,       // 数据库调用
    CACHE,          // 缓存调用
    MESSAGE_QUEUE,  // 消息队列调用
    UNKNOWN         // 未知类型
}

/**
 * 重试配置
 */
data class RetryConfig(
    val enabled: Boolean,
    val maxAttempts: Int?,
    val backoff: BackoffPolicy?
)

/**
 * 退避策略
 */
enum class BackoffPolicy {
    FIXED,
    EXPONENTIAL,
    NONE
}

/**
 * 风险等级
 */
enum class RiskLevel {
    HIGH,       // 高风险：支付、核心交易
    MEDIUM,     // 中风险：第三方 API
    LOW         // 低风险：内部服务、缓存
}

/**
 * 外部调用基类
 */
sealed class ExternalCall {
    abstract val callType: CallType
    abstract val callerClass: String
    abstract val callerMethod: String
    abstract val lineNumber: Int
    val description: String? = null
}

/**
 * 依赖报告
 */
data class DependencyReport(
    val totalExternalCalls: Int,
    val externalServices: Map<String, ServiceDependency>,
    val riskSummary: RiskSummary,
    val timeoutIssueCount: Int,
    val retryIssueCount: Int,
    val recommendations: List<String>
)

/**
 * 服务依赖
 */
data class ServiceDependency(
    val serviceName: String,
    val callCount: Int,
    val riskLevel: RiskLevel,
    val avgTimeout: Long?,
    val callTypes: List<CallType>
)

/**
 * 风险汇总
 */
data class RiskSummary(
    val highRiskCount: Int,
    val mediumRiskCount: Int,
    val lowRiskCount: Int
)
```

### 核心实现

```kotlin
/**
 * HTTP 客户端检测器
 */
class HttpClientDetector(
    private val llmService: LlmService
) {

    companion object {
        // HTTP 客户端类名后缀
        private val HTTP_CLIENT_SUFFIXES = setOf(
            "RestTemplate",
            "WebClient",
            "OkHttpClient",
            "HttpClient"
        )

        // HTTP 方法名
        private val HTTP_METHOD_NAMES = setOf(
            "getForObject",
            "getForEntity",
            "postForObject",
            "postForEntity",
            "exchange",
            "execute"
        )
    }

    /**
     * 检测 HTTP 调用
     */
    suspend fun detect(psiClass: PsiClass): List<HttpCall> {
        val calls = mutableListOf<HttpCall>()

        // 1. 扫描字段声明（检测注入的客户端）
        val clientFields = scanClientFields(psiClass)

        // 2. 扫描方法体（检测方法调用）
        psiClass.methods.forEach { method ->
            if (!method.hasModifierProperty(PsiModifier.PUBLIC)) {
                return@forEach
            }

            calls.addAll(scanMethodCalls(method, clientFields))
        }

        // 3. 检测 Feign Client
        calls.addAll(detectFeignClients(psiClass))

        return calls
    }

    /**
     * 扫描客户端字段
     */
    private fun scanClientFields(psiClass: PsiClass): Map<String, HttpClientType> {
        val clients = mutableMapOf<String, HttpClientType>()

        psiClass.fields.forEach { field ->
            val fieldType = field.type.canonicalText
            val clientType = when {
                fieldType.endsWith("RestTemplate") -> HttpClientType.REST_TEMPLATE
                fieldType.endsWith("WebClient") -> HttpClientType.WEB_CLIENT
                fieldType.endsWith("OkHttpClient") -> HttpClientType.OK_HTTP
                fieldType.endsWith("HttpClient") -> HttpClientType.APACHE_HTTP_CLIENT
                else -> null
            }

            if (clientType != null) {
                clients[field.name] = clientType
            }
        }

        return clients
    }

    /**
     * 扫描方法调用
     */
    private fun scanMethodCalls(
        method: PsiMethod,
        clientFields: Map<String, HttpClientType>
    ): List<HttpCall> {
        val calls = mutableListOf<HttpCall>()

        method.body?.accept(object : PsiRecursiveElementVisitor() {
            override fun visitMethodCallExpression(call: PsiMethodCallExpression) {
                val methodRef = call.methodExpression
                val methodName = methodRef.referenceName
                val qualifier = methodRef.qualifier

                // 检查是否是 HTTP 客户端方法调用
                if (methodName in HTTP_METHOD_NAMES && qualifier != null) {
                    val fieldName = qualifier.referenceName
                    val clientType = clientFields[fieldName]

                    if (clientType != null) {
                        val details = extractHttpCallDetails(call, methodName)
                        val httpCall = HttpCall(
                            clientType = clientType,
                            targetUrl = details.url,
                            httpMethod = details.httpMethod,
                            timeout = null,
                            retry = null,
                            callerClass = method.containingClass?.qualifiedName ?: "",
                            callerMethod = method.name,
                            lineNumber = call.textOffset,
                            riskLevel = assessRisk(details.url)
                        )
                        calls.add(httpCall)
                    }
                }

                super.visitMethodCallExpression(call)
            }
        })

        return calls
    }

    /**
     * 检测 Feign Client
     */
    private fun detectFeignClients(psiClass: PsiClass): List<HttpCall> {
        val calls = mutableListOf<HttpCall>()

        // 检查类是否有 @FeignClient 注解
        val hasFeignClient = psiClass.annotations.any {
            it.qualifiedReferenceName?.endsWith("FeignClient") == true
        }

        if (hasFeignClient) {
            // 提取服务名和 URL
            val serviceName = extractServiceName(psiClass)
            val url = extractUrl(psiClass)

            // 扫描所有方法
            psiClass.methods.forEach { method ->
                if (!method.hasModifierProperty(PsiModifier.PUBLIC)) {
                    return@forEach
                }

                val httpMethod = extractHttpMethodFromAnnotation(method)
                val callPath = extractPathFromAnnotation(method)

                val call = HttpCall(
                    clientType = HttpClientType.FEIGN_CLIENT,
                    targetUrl = "$url$callPath",
                    httpMethod = httpMethod,
                    timeout = null,
                    retry = null,
                    callerClass = psiClass.qualifiedName ?: "",
                    callerMethod = method.name,
                    lineNumber = method.textOffset,
                    riskLevel = assessRisk(serviceName)
                )
                calls.add(call)
            }
        }

        return calls
    }

    /**
     * 提取 HTTP 调用细节
     */
    private fun extractHttpCallDetails(
        call: PsiMethodCallExpression,
        methodName: String
    ): HttpCallDetails {
        val args = call.argumentList.expressions
        val url = if (args.isNotEmpty()) {
            extractUrl(args[0])
        } else {
            null
        }

        val httpMethod = when (methodName) {
            "getForObject", "getForEntity" -> "GET"
            "postForObject", "postForEntity" -> "POST"
            "put" -> "PUT"
            "delete" -> "DELETE"
            "exchange", "execute" -> "@Dynamic"
            else -> "UNKNOWN"
        }

        return HttpCallDetails(
            url = url,
            httpMethod = httpMethod
        )
    }

    /**
     * 提取 URL
     */
    private fun extractUrl(expr: PsiExpression): String {
        return when (expr) {
            is PsiLiteralExpression -> {
                expr.text.removeSurrounding("\"")
            }
            is PsiReferenceExpression -> {
                "@Variable:${expr.referenceName}"
            }
            is PsiMethodCallExpression -> {
                "@DynamicURL"
            }
            else -> "@Unknown"
        }
    }

    /**
     * 提取服务名
     */
    private fun extractServiceName(psiClass: PsiClass): String {
        val feignClient = psiClass.annotations.find {
            it.qualifiedReferenceName?.endsWith("FeignClient") == true
        }

        return feignClient?.findAttributeValue("name")?.text?.removeSurrounding("\"")
            ?: feignClient?.findAttributeValue("value")?.text?.removeSurrounding("\"")
            ?: "@Unknown"
    }

    /**
     * 提取 URL
     */
    private fun extractUrl(psiClass: PsiClass): String {
        val feignClient = psiClass.annotations.find {
            it.qualifiedReferenceName?.endsWith("FeignClient") == true
        }

        return feignClient?.findAttributeValue("url")?.text?.removeSurrounding("\"")
            ?: ""
    }

    /**
     * 从注解提取 HTTP 方法
     */
    private fun extractHttpMethodFromAnnotation(method: PsiMethod): String {
        val mappingAnnotations = listOf(
            "GetMapping" to "GET",
            "PostMapping" to "POST",
            "PutMapping" to "PUT",
            "DeleteMapping" to "DELETE",
            "PatchMapping" to "PATCH",
            "RequestMapping" to "@Any"
        )

        for ((annotationName, httpMethod) in mappingAnnotations) {
            val hasAnnotation = method.annotations.any {
                it.qualifiedReferenceName?.endsWith(annotationName) == true
            }
            if (hasAnnotation) {
                return httpMethod
            }
        }

        return "@Unknown"
    }

    /**
     * 从注解提取路径
     */
    private fun extractPathFromAnnotation(method: PsiMethod): String {
        val mappingAnnotations = listOf(
            "GetMapping", "PostMapping", "PutMapping",
            "DeleteMapping", "PatchMapping", "RequestMapping"
        )

        for (annotationName in mappingAnnotations) {
            val annotation = method.annotations.find {
                it.qualifiedReferenceName?.endsWith(annotationName) == true
            }
            if (annotation != null) {
                val path = annotation.findAttributeValue("value")?.text?.removeSurrounding("\"")
                if (!path.isNullOrBlank()) {
                    return path
                }
            }
        }

        return ""
    }

    /**
     * 评估风险等级
     */
    private fun assessRisk(target: String?): RiskLevel {
        if (target == null) return RiskLevel.MEDIUM

        return when {
            target.contains("payment") ||
            target.contains("pay") ||
            target.contains("bank") ||
            target.contains("transaction") -> RiskLevel.HIGH

            target.contains("localhost") ||
            target.contains("127.0.0.1") ||
            target.contains("internal") -> RiskLevel.LOW

            else -> RiskLevel.MEDIUM
        }
    }

    /**
     * HTTP 调用细节
     */
    private data class HttpCallDetails(
        val url: String?,
        val httpMethod: String
    )
}
```

## 与 knowledge-graph-system 的差异

### 可以借鉴的部分

1. **CallType 枚举设计**
   - HTTP、RPC、DATABASE、CACHE、MESSAGE_QUEUE
   - 清晰的分类体系

2. **MethodCallInfo 数据模型**
   - 记录调用目标、方法名、调用类型
   - 支持远程调用标记

3. **SpecialPattern 模式识别**
   - RETRY_MECHANISM（重试机制）
   - CIRCUIT_BREAKER（熔断器）
   - RATE_LIMITING（限流）
   - 可用于增强外部调用分析

### 需要调整的部分

1. **PSI 优于 Spoon**
   - knowledge-graph-system 使用 Spoon（外部库）
   - SmanAgent 使用 IntelliJ PSI（内置）
   - PSI 提供更准确的类型信息

2. **更细粒度的分析**
   - knowledge-graph-system 只记录调用类型
   - SmanAgent 需要提取详细元数据（URL、超时、重试等）

3. **依赖关系分析**
   - knowledge-graph-system 主要关注调用链
   - SmanAgent 关注外部依赖风险评估

4. **存储方式**
   - knowledge-graph-system 存入内存和文件
   - SmanAgent 存入向量库（待第 11 节设计）

## 专家知识库

### 关键问题

1. **如何识别动态 URL？**
   - 变量引用：`restTemplate.getForObject(url, ...)`
   - 字符串拼接：`"https://" + domain + "/api"`
   - 配置文件：`@Value("${api.url}")`
   - 解决方案：标记为 `@DynamicURL`，建议配置化

2. **如何提取超时配置？**
   - RestTemplate：需要查看 `RequestConfig` 或 `SimpleClientHttpRequestFactory`
   - WebClient：查看 `HttpClient` 配置
   - Feign：查看 `@FeignClient` 的配置属性
   - 解决方案：扫描配置文件 + 客户端 Bean 定义

3. **如何识别重试策略？**
   - Spring Retry：`@Retryable` 注解
   - Resilience4j：`@CircuitBreaker` 注解
   - Feign：配置文件中的 `ribbon.MaxAutoRetries`
   - 解决方案：扫描注解 + 配置文件

4. **如何评估依赖风险？**
   - 高风险：支付、核心交易、外部敏感 API
   - 中风险：第三方 API、外部数据源
   - 低风险：内部服务、缓存
   - 解决方案：基于 URL/服务名 + 业务领域推断

5. **如何处理异步调用？**
   - `CompletableFuture` 包装的调用
   - `@Async` 注解的方法
   - Reactor 链式调用（`flatMap`、`subscribe`）
   - 解决方案：追踪异步操作的源头

### 最佳实践

1. **扫描顺序**
   - 先扫描字段声明（识别注入的客户端）
   - 再扫描方法调用（识别具体使用）
   - 最后扫描注解（识别声明式客户端）

2. **性能优化**
   - 使用 PSI 缓存
   - 并发扫描多个类
   - 增量扫描（只扫描变更的文件）

3. **错误处理**
   - PSI 解析失败：记录日志，跳过该类
   - URL 提取失败：标记为 `@Unknown`
   - 类型推断失败：使用 UNKNOWN 枚举值

4. **风险评级规则**
   - 基于 URL 关键词：payment、bank → HIGH
   - 基于 Service Name：*-service → MEDIUM
   - 基于调用频率：高频调用 → HIGH
   - 基于超时配置：无超时 → HIGH（风险）

## 待解决的问题

1. **增量扫描**
   - 如何识别变更的文件？
   - 如何更新已存储的外调数据？

2. **配置文件解析**
   - 如何解析 `application.yml` 中的超时配置？
   - 如何关联配置与代码？

3. **动态 URL 追踪**
   - 如何追踪变量的赋值链？
   - 如何推断运行时 URL？

4. **依赖风险评估**
   - 如何提高风险评估的准确率？
   - 如何引入业务上下文？

5. **向量库存储**
   - 如何设计外部调用的向量 Schema？
   - 如何生成外部调用的 embedding？
   - 如何支持 BGE 召回 + 重排？

## 下一步

- [ ] 实现基础的 HTTP 客户端检测
- [ ] 实现 RPC、数据库、缓存、MQ 调用检测
- [ ] 实现依赖关系分析和风险评估
- [x] 集成配置文件解析（提取超时、重试配置）
- [x] 设计向量库存储格式（第 11 节）
- [x] 编写单元测试
- [x] 性能优化和增量扫描
- [ ] 添加业务功能分析（LLM）

---

## ✅ 实现完成 (2026-01-30)

### 实现文件

- **位置**: `src/main/kotlin/com/smancode/smanagent/analysis/external/ExternalApiScanner.kt`
- **测试**: 所有测试通过 (196 tests passed)

### 实现功能

1. ✅ **Feign 客户端扫描** - 识别 @FeignClient 注解
2. ✅ **Retrofit 接口扫描** - 识别 @GET/@POST 等 HTTP 注解
3. ✅ **RestTemplate 调用扫描** - 识别 exchange/getForEntity 等方法
4. ✅ **HTTP 客户端扫描** - 识别 OkHttp/HttpClient 调用
5. ✅ **API 方法提取** - 提取 HTTP 方法、路径、参数

### 核心数据类

```kotlin
@Serializable
data class ExternalApiInfo(
    val apiName: String,
    val apiType: ExternalApiType,
    val baseUrl: String,
    val serviceName: String,
    val methods: List<ApiMethodInfo>,
    val qualifiedName: String,
    val filePath: String
)

enum class ExternalApiType {
    FEIGN,           // OpenFeign 声明式 HTTP 客户端
    RETROFIT,        // Retrofit 接口
    REST_TEMPLATE,   // Spring RestTemplate
    HTTP_CLIENT,     // OkHttp/Apache HttpClient
    UNKNOWN
}
```

### 验证状态

```bash
./gradlew test
# BUILD SUCCESSFUL - 196 tests completed
```
